import {
    m as Nt,
    n as Wt
} from "./Models-F5kqfqlD.js";
import {
    S as Ht,
    U as Gt,
    V as Xt,
    W as Ft,
    F as Yt,
    X as Ut,
    Y as Vt,
    Z as qt,
    $ as Kt,
    T as Zt,
    a0 as $t,
    J as _t,
    a1 as Jt,
    a2 as Qt,
    a3 as te,
    a4 as ee,
    a5 as ie,
    a6 as se,
    a7 as oe,
    c as re,
    a8 as ne,
    a as ae,
    a9 as he,
    v as le,
    I as de,
    g as ce,
    j as pe,
    aa as ue,
    ab as ge,
    ac as fe,
    ad as me,
    ae as xe,
    s as ye,
    m as be,
    k as ve,
    af as Se,
    n as ke,
    d as Me,
    ag as Ce,
    ah as we,
    ai as Te,
    aj as Ae,
    ak as Pe,
    al as Le,
    am as Oe,
    an as Ee,
    ao as De,
    ap as je,
    aq as Ie,
    z as Be,
    ar as Re,
    as as ze,
    at as Ne,
    h as We,
    au as He,
    av as Ge,
    aw as Xe,
    ax as Fe,
    ay as Ye,
    i as Ue,
    az as Ve,
    aA as qe,
    aB as Ke,
    aC as Ze,
    aD as $e,
    aE as _e,
    aF as Je,
    aG as Qe,
    aH as ti,
    aI as ei,
    aJ as ii,
    aK as si,
    A as oi,
    B as ri,
    aL as ni,
    aM as ai,
    aN as hi,
    aO as li,
    aP as di,
    aQ as ci,
    aR as pi,
    aS as ui,
    o as gi,
    aT as fi,
    aU as mi,
    aV as xi,
    aW as yi,
    b as bi,
    aX as vi,
    f as Si,
    Q as ki,
    p as Mi,
    aY as Ci,
    P as wi,
    aZ as Ti,
    y as Ai,
    a_ as Pi,
    r as Li,
    a$ as Oi,
    b0 as Ei,
    q as Di,
    C as ji,
    b1 as Ii,
    b2 as Bi,
    b3 as Ri,
    b4 as zi,
    b5 as Ni,
    b6 as Wi,
    b7 as Hi,
    b8 as Gi,
    b9 as Xi,
    ba as Fi,
    x as Yi,
    bb as Ui,
    bc as Vi,
    bd as qi,
    t as Ki,
    be as Zi,
    bf as $i,
    bg as _i,
    bh as Ji,
    bi as Qi,
    bj as ts,
    bk as es,
    bl as is,
    u as ss,
    bm as os,
    bn as rs,
    bo as ns,
    bp as as,
    bq as hs,
    br as ls,
    bs as ds,
    bt as cs,
    bu as ps,
    L as us,
    N as gs,
    M as fs,
    G as ms,
    bv as xs,
    bw as ys,
    e as bs,
    w as vs,
    bx as Ss,
    by as ks,
    bz as Ms,
    l as Cs,
    bA as ws,
    E as Ts,
    H as As,
    bB as Ps,
    D as Ls,
    bC as Os
} from "./index-niMaZqBZ.js";
const Es = () => {},
    Ds = Object.freeze(Object.defineProperty({
        __proto__: null,
        BaseTransition: Ht,
        BaseTransitionPropsValidators: Gt,
        Comment: Xt,
        EffectScope: Ft,
        Fragment: Yt,
        KeepAlive: Ut,
        ReactiveEffect: Vt,
        Static: qt,
        Suspense: Kt,
        Teleport: Zt,
        Text: $t,
        Transition: _t,
        TransitionGroup: Jt,
        VueElement: Qt,
        assertNumber: te,
        callWithAsyncErrorHandling: ee,
        callWithErrorHandling: ie,
        camelize: se,
        capitalize: oe,
        cloneVNode: re,
        compatUtils: ne,
        compile: Es,
        computed: ae,
        createApp: he,
        createBlock: le,
        createCommentVNode: de,
        createElementBlock: ce,
        createElementVNode: pe,
        createHydrationRenderer: ue,
        createPropsRestProxy: ge,
        createRenderer: fe,
        createSSRApp: me,
        createSlots: xe,
        createStaticVNode: ye,
        createTextVNode: be,
        createVNode: ve,
        customRef: Se,
        defineAsyncComponent: ke,
        defineComponent: Me,
        defineCustomElement: Ce,
        defineEmits: we,
        defineExpose: Te,
        defineModel: Ae,
        defineOptions: Pe,
        defineProps: Le,
        defineSSRCustomElement: Oe,
        defineSlots: Ee,
        get devtools() {
            return De
        },
        effect: je,
        effectScope: Ie,
        getCurrentInstance: Be,
        getCurrentScope: Re,
        getTransitionRawChildren: ze,
        guardReactiveProps: Ne,
        h: We,
        handleError: He,
        hasInjectionContext: Ge,
        hydrate: Xe,
        initCustomFormatter: Fe,
        initDirectivesForSSR: Ye,
        inject: Ue,
        isMemoSame: Ve,
        isProxy: qe,
        isReactive: Ke,
        isReadonly: Ze,
        isRef: $e,
        isRuntimeOnly: _e,
        isShallow: Je,
        isVNode: Qe,
        markRaw: ti,
        mergeDefaults: ei,
        mergeModels: ii,
        mergeProps: si,
        nextTick: oi,
        normalizeClass: ri,
        normalizeProps: ni,
        normalizeStyle: ai,
        onActivated: hi,
        onBeforeMount: li,
        onBeforeUnmount: di,
        onBeforeUpdate: ci,
        onDeactivated: pi,
        onErrorCaptured: ui,
        onMounted: gi,
        onRenderTracked: fi,
        onRenderTriggered: mi,
        onScopeDispose: xi,
        onServerPrefetch: yi,
        onUnmounted: bi,
        onUpdated: vi,
        openBlock: Si,
        popScopeId: ki,
        provide: Mi,
        proxyRefs: Ci,
        pushScopeId: wi,
        queuePostFlushCb: Ti,
        reactive: Ai,
        readonly: Pi,
        ref: Li,
        registerRuntimeCompiler: Oi,
        render: Ei,
        renderList: Di,
        renderSlot: ji,
        resolveComponent: Ii,
        resolveDirective: Bi,
        resolveDynamicComponent: Ri,
        resolveFilter: zi,
        resolveTransitionHooks: Ni,
        setBlockTracking: Wi,
        setDevtoolsHook: Hi,
        setTransitionHooks: Gi,
        shallowReactive: Xi,
        shallowReadonly: Fi,
        shallowRef: Yi,
        ssrContextKey: Ui,
        ssrUtils: Vi,
        stop: qi,
        toDisplayString: Ki,
        toHandlerKey: Zi,
        toHandlers: $i,
        toRaw: _i,
        toRef: Ji,
        toRefs: Qi,
        toValue: ts,
        transformVNodeArgs: es,
        triggerRef: is,
        unref: ss,
        useAttrs: os,
        useCssModule: rs,
        useCssVars: ns,
        useModel: as,
        useSSRContext: hs,
        useSlots: ls,
        useTransitionState: ds,
        vModelCheckbox: cs,
        vModelDynamic: ps,
        vModelRadio: us,
        vModelSelect: gs,
        vModelText: fs,
        vShow: ms,
        version: xs,
        warn: ys,
        watch: bs,
        watchEffect: vs,
        watchPostEffect: Ss,
        watchSyncEffect: ks,
        withAsyncContext: Ms,
        withCtx: Cs,
        withDefaults: ws,
        withDirectives: Ts,
        withKeys: As,
        withMemo: Ps,
        withModifiers: Ls,
        withScopeId: Os
    }, Symbol.toStringTag, {
        value: "Module"
    }));
var Rt = {
        exports: {}
    },
    It = {
        exports: {}
    },
    Bt;

function js() {
    return Bt || (Bt = 1, function(Pt) {
        (function(Tt, Y) {
            Pt.exports ? (Y.default = Y, Pt.exports = Tt.document ? Y(Tt) : Y) : (Tt.Highcharts && Tt.Highcharts.error(16, !0), Tt.Highcharts = Y(Tt))
        })(typeof window < "u" ? window : Nt, function(Tt) {
            var Y = {};

            function ft(et, Q, ht, rt) {
                et.hasOwnProperty(Q) || (et[Q] = rt.apply(null, ht), typeof CustomEvent == "function" && Tt.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", {
                    detail: {
                        path: Q,
                        module: et[Q]
                    }
                })))
            }
            return ft(Y, "Core/Globals.js", [], function() {
                var et, Q;
                return (Q = et || (et = {})).SVG_NS = "http://www.w3.org/2000/svg", Q.product = "Highcharts", Q.version = "11.2.0", Q.win = Tt !== void 0 ? Tt : {}, Q.doc = Q.win.document, Q.svg = Q.doc && Q.doc.createElementNS && !!Q.doc.createElementNS(Q.SVG_NS, "svg").createSVGRect, Q.userAgent = Q.win.navigator && Q.win.navigator.userAgent || "", Q.isChrome = Q.userAgent.indexOf("Chrome") !== -1, Q.isFirefox = Q.userAgent.indexOf("Firefox") !== -1, Q.isMS = /(edge|msie|trident)/i.test(Q.userAgent) && !Q.win.opera, Q.isSafari = !Q.isChrome && Q.userAgent.indexOf("Safari") !== -1, Q.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(Q.userAgent), Q.isWebKit = Q.userAgent.indexOf("AppleWebKit") !== -1, Q.deg2rad = 2 * Math.PI / 360, Q.hasBidiBug = Q.isFirefox && 4 > parseInt(Q.userAgent.split("Firefox/")[1], 10), Q.hasTouch = !!Q.win.TouchEvent, Q.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"], Q.noop = function() {}, Q.supportsPassiveEvents = function() {
                    let ht = !1;
                    if (!Q.isMS) {
                        let rt = Object.defineProperty({}, "passive", {
                            get: function() {
                                ht = !0
                            }
                        });
                        Q.win.addEventListener && Q.win.removeEventListener && (Q.win.addEventListener("testPassive", Q.noop, rt), Q.win.removeEventListener("testPassive", Q.noop, rt))
                    }
                    return ht
                }(), Q.charts = [], Q.dateFormats = {}, Q.seriesTypes = {}, Q.symbolSizes = {}, Q.chartCount = 0, et
            }), ft(Y, "Core/Utilities.js", [Y["Core/Globals.js"]], function(et) {
                let Q, {
                    charts: ht,
                    doc: rt,
                    win: it
                } = et;

                function nt(t, i, s, p) {
                    let x = i ? "Highcharts error" : "Highcharts warning";
                    t === 32 && (t = `${x}: Deprecated member`);
                    let O = E(t),
                        d = O ? `${x} #${t}: www.highcharts.com/errors/${t}/` : t.toString();
                    if (p !== void 0) {
                        let A = "";
                        O && (d += "?"), l(p, function(L, V) {
                            A += `
 - ${V}: ${L}`, O && (d += encodeURI(V) + "=" + encodeURI(L))
                        }), d += A
                    }
                    h(et, "displayError", {
                        chart: s,
                        code: t,
                        message: d,
                        params: p
                    }, function() {
                        if (i) throw Error(d);
                        it.console && nt.messages.indexOf(d) === -1 && console.warn(d)
                    }), nt.messages.push(d)
                }

                function ot(t, i) {
                    return parseInt(t, i || 10)
                }

                function K(t) {
                    return typeof t == "string"
                }

                function Z(t) {
                    let i = Object.prototype.toString.call(t);
                    return i === "[object Array]" || i === "[object Array Iterator]"
                }

                function U(t, i) {
                    return !!t && typeof t == "object" && (!i || !Z(t))
                }

                function S(t) {
                    return U(t) && typeof t.nodeType == "number"
                }

                function R(t) {
                    let i = t && t.constructor;
                    return !!(U(t, !0) && !S(t) && i && i.name && i.name !== "Object")
                }

                function E(t) {
                    return typeof t == "number" && !isNaN(t) && t < 1 / 0 && t > -1 / 0
                }

                function M(t) {
                    return t != null
                }

                function k(t, i, s) {
                    let p, x = K(i) && !M(s),
                        O = (d, A) => {
                            M(d) ? t.setAttribute(A, d) : x ? (p = t.getAttribute(A)) || A !== "class" || (p = t.getAttribute(A + "Name")) : t.removeAttribute(A)
                        };
                    return K(i) ? O(s, i) : l(i, O), p
                }

                function g(t) {
                    return Z(t) ? t : [t]
                }

                function f(t, i) {
                    let s;
                    for (s in t || (t = {}), i) t[s] = i[s];
                    return t
                }

                function m() {
                    let t = arguments,
                        i = t.length;
                    for (let s = 0; s < i; s++) {
                        let p = t[s];
                        if (p != null) return p
                    }
                }

                function C(t, i) {
                    et.isMS && !et.svg && i && M(i.opacity) && (i.filter = `alpha(opacity=${100*i.opacity})`), f(t.style, i)
                }

                function T(t) {
                    return Math.pow(10, Math.floor(Math.log(t) / Math.LN10))
                }

                function P(t, i) {
                    return t > 1e14 ? t : parseFloat(t.toPrecision(i || 14))
                }(nt || (nt = {})).messages = [], Math.easeInOutSine = function(t) {
                    return -.5 * (Math.cos(Math.PI * t) - 1)
                };
                let o = Array.prototype.find ? function(t, i) {
                    return t.find(i)
                } : function(t, i) {
                    let s, p = t.length;
                    for (s = 0; s < p; s++)
                        if (i(t[s], s)) return t[s]
                };

                function l(t, i, s) {
                    for (let p in t) Object.hasOwnProperty.call(t, p) && i.call(s || t[p], t[p], p, t)
                }

                function n(t, i, s) {
                    function p(d, A) {
                        let L = t.removeEventListener;
                        L && L.call(t, d, A, !1)
                    }

                    function x(d) {
                        let A, L;
                        t.nodeName && (i ? (A = {})[i] = !0 : A = d, l(A, function(V, B) {
                            if (d[B])
                                for (L = d[B].length; L--;) p(B, d[B][L].fn)
                        }))
                    }
                    let O = typeof t == "function" && t.prototype || t;
                    if (Object.hasOwnProperty.call(O, "hcEvents")) {
                        let d = O.hcEvents;
                        if (i) {
                            let A = d[i] || [];
                            s ? (d[i] = A.filter(function(L) {
                                return s !== L.fn
                            }), p(i, s)) : (x(d), d[i] = [])
                        } else x(d), delete O.hcEvents
                    }
                }

                function h(t, i, s, p) {
                    let x;
                    if (s = s || {}, rt.createEvent && (t.dispatchEvent || t.fireEvent && t !== et))(x = rt.createEvent("Events")).initEvent(i, !0, !0), s = f(x, s), t.dispatchEvent ? t.dispatchEvent(s) : t.fireEvent(i, s);
                    else if (t.hcEvents) {
                        s.target || f(s, {
                            preventDefault: function() {
                                s.defaultPrevented = !0
                            },
                            target: t,
                            type: i
                        });
                        let O = [],
                            d = t,
                            A = !1;
                        for (; d.hcEvents;) Object.hasOwnProperty.call(d, "hcEvents") && d.hcEvents[i] && (O.length && (A = !0), O.unshift.apply(O, d.hcEvents[i])), d = Object.getPrototypeOf(d);
                        A && O.sort((L, V) => L.order - V.order), O.forEach(L => {
                            L.fn.call(t, s) === !1 && s.preventDefault()
                        })
                    }
                    p && !s.defaultPrevented && p.call(t, s)
                }
                l({
                    map: "map",
                    each: "forEach",
                    grep: "filter",
                    reduce: "reduce",
                    some: "some"
                }, function(t, i) {
                    et[i] = function(s) {
                        return nt(32, !1, void 0, {
                            [`Highcharts.${i}`]: `use Array.${t}`
                        }), Array.prototype[t].apply(s, [].slice.call(arguments, 1))
                    }
                });
                let u = function() {
                    let t = Math.random().toString(36).substring(2, 9) + "-",
                        i = 0;
                    return function() {
                        return "highcharts-" + (Q ? "" : t) + i++
                    }
                }();
                return it.jQuery && (it.jQuery.fn.highcharts = function() {
                    let t = [].slice.call(arguments);
                    if (this[0]) return t[0] ? (new et[K(t[0]) ? t.shift() : "Chart"](this[0], t[0], t[1]), this) : ht[k(this[0], "data-highcharts-chart")]
                }), {
                    addEvent: function(t, i, s, p = {}) {
                        let x = typeof t == "function" && t.prototype || t;
                        Object.hasOwnProperty.call(x, "hcEvents") || (x.hcEvents = {});
                        let O = x.hcEvents;
                        et.Point && t instanceof et.Point && t.series && t.series.chart && (t.series.chart.runTrackerClick = !0);
                        let d = t.addEventListener;
                        d && d.call(t, i, s, !!et.supportsPassiveEvents && {
                            passive: p.passive === void 0 ? i.indexOf("touch") !== -1 : p.passive,
                            capture: !1
                        }), O[i] || (O[i] = []);
                        let A = {
                            fn: s,
                            order: typeof p.order == "number" ? p.order : 1 / 0
                        };
                        return O[i].push(A), O[i].sort((L, V) => L.order - V.order),
                            function() {
                                n(t, i, s)
                            }
                    },
                    arrayMax: function(t) {
                        let i = t.length,
                            s = t[0];
                        for (; i--;) t[i] > s && (s = t[i]);
                        return s
                    },
                    arrayMin: function(t) {
                        let i = t.length,
                            s = t[0];
                        for (; i--;) t[i] < s && (s = t[i]);
                        return s
                    },
                    attr: k,
                    clamp: function(t, i, s) {
                        return t > i ? t < s ? t : s : i
                    },
                    clearTimeout: function(t) {
                        M(t) && clearTimeout(t)
                    },
                    correctFloat: P,
                    createElement: function(t, i, s, p, x) {
                        let O = rt.createElement(t);
                        return i && f(O, i), x && C(O, {
                            padding: "0",
                            border: "none",
                            margin: "0"
                        }), s && C(O, s), p && p.appendChild(O), O
                    },
                    css: C,
                    defined: M,
                    destroyObjectProperties: function(t, i) {
                        l(t, function(s, p) {
                            s && s !== i && s.destroy && s.destroy(), delete t[p]
                        })
                    },
                    diffObjects: function(t, i, s, p) {
                        let x = {};
                        return function O(d, A, L, V) {
                            let B = s ? A : d;
                            l(d, function(r, c) {
                                if (!V && p && p.indexOf(c) > -1 && A[c]) {
                                    r = g(r), L[c] = [];
                                    for (let b = 0; b < Math.max(r.length, A[c].length); b++) A[c][b] && (r[b] === void 0 ? L[c][b] = A[c][b] : (L[c][b] = {}, O(r[b], A[c][b], L[c][b], V + 1)))
                                } else U(r, !0) && !r.nodeType ? (L[c] = Z(r) ? [] : {}, O(r, A[c] || {}, L[c], V + 1), Object.keys(L[c]).length !== 0 || c === "colorAxis" && V === 0 || delete L[c]) : (d[c] !== A[c] || c in d && !(c in A)) && (L[c] = B[c])
                            })
                        }(t, i, x, 0), x
                    },
                    discardElement: function(t) {
                        t && t.parentElement && t.parentElement.removeChild(t)
                    },
                    erase: function(t, i) {
                        let s = t.length;
                        for (; s--;)
                            if (t[s] === i) {
                                t.splice(s, 1);
                                break
                            }
                    },
                    error: nt,
                    extend: f,
                    extendClass: function(t, i) {
                        let s = function() {};
                        return s.prototype = new t, f(s.prototype, i), s
                    },
                    find: o,
                    fireEvent: h,
                    getClosestDistance: function(t, i) {
                        let s, p, x, O = !i;
                        return t.forEach(d => {
                            if (d.length > 1)
                                for (x = d.length - 1; x > 0; x--)(p = d[x] - d[x - 1]) < 0 && !O ? (i == null || i(), i = void 0) : p && (s === void 0 || p < s) && (s = p)
                        }), s
                    },
                    getMagnitude: T,
                    getNestedProperty: function(t, i) {
                        let s = t.split(".");
                        for (; s.length && M(i);) {
                            let p = s.shift();
                            if (p === void 0 || p === "__proto__") return;
                            if (p === "this") {
                                let O;
                                return U(i) && (O = i["@this"]), O ?? i
                            }
                            let x = i[p];
                            if (!M(x) || typeof x == "function" || typeof x.nodeType == "number" || x === it) return;
                            i = x
                        }
                        return i
                    },
                    getStyle: function t(i, s, p) {
                        let x;
                        if (s === "width") {
                            let d = Math.min(i.offsetWidth, i.scrollWidth),
                                A = i.getBoundingClientRect && i.getBoundingClientRect().width;
                            return A < d && A >= d - 1 && (d = Math.floor(A)), Math.max(0, d - (t(i, "padding-left", !0) || 0) - (t(i, "padding-right", !0) || 0))
                        }
                        if (s === "height") return Math.max(0, Math.min(i.offsetHeight, i.scrollHeight) - (t(i, "padding-top", !0) || 0) - (t(i, "padding-bottom", !0) || 0));
                        let O = it.getComputedStyle(i, void 0);
                        return O && (x = O.getPropertyValue(s), m(p, s !== "opacity") && (x = ot(x))), x
                    },
                    inArray: function(t, i, s) {
                        return nt(32, !1, void 0, {
                            "Highcharts.inArray": "use Array.indexOf"
                        }), i.indexOf(t, s)
                    },
                    insertItem: function(t, i) {
                        let s, p = t.options.index,
                            x = i.length;
                        for (s = t.options.isInternal ? x : 0; s < x + 1; s++)
                            if (!i[s] || E(p) && p < m(i[s].options.index, i[s]._i) || i[s].options.isInternal) {
                                i.splice(s, 0, t);
                                break
                            } return s
                    },
                    isArray: Z,
                    isClass: R,
                    isDOMElement: S,
                    isFunction: function(t) {
                        return typeof t == "function"
                    },
                    isNumber: E,
                    isObject: U,
                    isString: K,
                    keys: function(t) {
                        return nt(32, !1, void 0, {
                            "Highcharts.keys": "use Object.keys"
                        }), Object.keys(t)
                    },
                    merge: function() {
                        let t, i = arguments,
                            s = {},
                            p = function(O, d) {
                                return typeof O != "object" && (O = {}), l(d, function(A, L) {
                                    L !== "__proto__" && L !== "constructor" && (!U(A, !0) || R(A) || S(A) ? O[L] = d[L] : O[L] = p(O[L] || {}, A))
                                }), O
                            };
                        i[0] === !0 && (s = i[1], i = Array.prototype.slice.call(i, 2));
                        let x = i.length;
                        for (t = 0; t < x; t++) s = p(s, i[t]);
                        return s
                    },
                    normalizeTickInterval: function(t, i, s, p, x) {
                        let O, d = t;
                        s = m(s, T(t));
                        let A = t / s;
                        for (!i && (i = x ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], p === !1 && (s === 1 ? i = i.filter(function(L) {
                            return L % 1 == 0
                        }) : s <= .1 && (i = [1 / s]))), O = 0; O < i.length && (d = i[O], (!x || !(d * s >= t)) && (x || !(A <= (i[O] + (i[O + 1] || i[O])) / 2))); O++);
                        return P(d * s, -Math.round(Math.log(.001) / Math.LN10))
                    },
                    objectEach: l,
                    offset: function(t) {
                        let i = rt.documentElement,
                            s = t.parentElement || t.parentNode ? t.getBoundingClientRect() : {
                                top: 0,
                                left: 0,
                                width: 0,
                                height: 0
                            };
                        return {
                            top: s.top + (it.pageYOffset || i.scrollTop) - (i.clientTop || 0),
                            left: s.left + (it.pageXOffset || i.scrollLeft) - (i.clientLeft || 0),
                            width: s.width,
                            height: s.height
                        }
                    },
                    pad: function(t, i, s) {
                        return Array((i || 2) + 1 - String(t).replace("-", "").length).join(s || "0") + t
                    },
                    pick: m,
                    pInt: ot,
                    pushUnique: function(t, i) {
                        return 0 > t.indexOf(i) && !!t.push(i)
                    },
                    relativeLength: function(t, i, s) {
                        return /%$/.test(t) ? i * parseFloat(t) / 100 + (s || 0) : parseFloat(t)
                    },
                    removeEvent: n,
                    splat: g,
                    stableSort: function(t, i) {
                        let s, p, x = t.length;
                        for (p = 0; p < x; p++) t[p].safeI = p;
                        for (t.sort(function(O, d) {
                            return (s = i(O, d)) === 0 ? O.safeI - d.safeI : s
                        }), p = 0; p < x; p++) delete t[p].safeI
                    },
                    syncTimeout: function(t, i, s) {
                        return i > 0 ? setTimeout(t, i, s) : (t.call(0, s), -1)
                    },
                    timeUnits: {
                        millisecond: 1,
                        second: 1e3,
                        minute: 6e4,
                        hour: 36e5,
                        day: 864e5,
                        week: 6048e5,
                        month: 24192e5,
                        year: 314496e5
                    },
                    uniqueKey: u,
                    useSerialIds: function(t) {
                        return Q = m(t, Q)
                    },
                    wrap: function(t, i, s) {
                        let p = t[i];
                        t[i] = function() {
                            let x = arguments,
                                O = this;
                            return s.apply(this, [function() {
                                return p.apply(O, arguments.length ? arguments : x)
                            }].concat([].slice.call(arguments)))
                        }
                    }
                }
            }), ft(Y, "Core/Chart/ChartDefaults.js", [], function() {
                return {
                    alignThresholds: !1,
                    panning: {
                        enabled: !1,
                        type: "x"
                    },
                    styledMode: !1,
                    borderRadius: 0,
                    colorCount: 10,
                    allowMutatingData: !0,
                    ignoreHiddenSeries: !0,
                    spacing: [10, 10, 15, 10],
                    resetZoomButton: {
                        theme: {},
                        position: {}
                    },
                    reflow: !0,
                    type: "line",
                    zooming: {
                        singleTouch: !1,
                        resetButton: {
                            theme: {
                                zIndex: 6
                            },
                            position: {
                                align: "right",
                                x: -10,
                                y: 10
                            }
                        }
                    },
                    width: null,
                    height: null,
                    borderColor: "#334eff",
                    backgroundColor: "#ffffff",
                    plotBorderColor: "#cccccc"
                }
            }), ft(Y, "Core/Color/Palettes.js", [], function() {
                return {
                    colors: ["#2caffe", "#544fc5", "#00e272", "#fe6a35", "#6b8abc", "#d568fb", "#2ee0ca", "#fa4b42", "#feb56a", "#91e8e1"]
                }
            }), ft(Y, "Core/Time.js", [Y["Core/Globals.js"], Y["Core/Utilities.js"]], function(et, Q) {
                let {
                    win: ht
                } = et, {
                    defined: rt,
                    error: it,
                    extend: nt,
                    isObject: ot,
                    merge: K,
                    objectEach: Z,
                    pad: U,
                    pick: S,
                    splat: R,
                    timeUnits: E
                } = Q, M = et.isSafari && ht.Intl && ht.Intl.DateTimeFormat.prototype.formatRange, k = et.isSafari && ht.Intl && !ht.Intl.DateTimeFormat.prototype.formatRange;
                return class {
                    constructor(g) {
                        this.options = {}, this.useUTC = !1, this.variableTimezone = !1, this.Date = ht.Date, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.update(g)
                    }
                    get(g, f) {
                        if (this.variableTimezone || this.timezoneOffset) {
                            let m = f.getTime(),
                                C = m - this.getTimezoneOffset(f);
                            f.setTime(C);
                            let T = f["getUTC" + g]();
                            return f.setTime(m), T
                        }
                        return this.useUTC ? f["getUTC" + g]() : f["get" + g]()
                    }
                    set(g, f, m) {
                        if (this.variableTimezone || this.timezoneOffset) {
                            if (g === "Milliseconds" || g === "Seconds" || g === "Minutes" && this.getTimezoneOffset(f) % 36e5 == 0) return f["setUTC" + g](m);
                            let C = this.getTimezoneOffset(f),
                                T = f.getTime() - C;
                            f.setTime(T), f["setUTC" + g](m);
                            let P = this.getTimezoneOffset(f);
                            return T = f.getTime() + P, f.setTime(T)
                        }
                        return this.useUTC || M && g === "FullYear" ? f["setUTC" + g](m) : f["set" + g](m)
                    }
                    update(g = {}) {
                        let f = S(g.useUTC, !0);
                        this.options = g = K(!0, this.options, g), this.Date = g.Date || ht.Date || Date, this.useUTC = f, this.timezoneOffset = f && g.timezoneOffset || void 0, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.variableTimezone = f && !!(g.getTimezoneOffset || g.timezone)
                    }
                    makeTime(g, f, m, C, T, P) {
                        let o, l, n;
                        return this.useUTC ? (o = this.Date.UTC.apply(0, arguments), l = this.getTimezoneOffset(o), o += l, l !== (n = this.getTimezoneOffset(o)) ? o += n - l : l - 36e5 !== this.getTimezoneOffset(o - 36e5) || k || (o -= 36e5)) : o = new this.Date(g, f, S(m, 1), S(C, 0), S(T, 0), S(P, 0)).getTime(), o
                    }
                    timezoneOffsetFunction() {
                        let g = this,
                            f = this.options,
                            m = f.getTimezoneOffset,
                            C = f.moment || ht.moment;
                        if (!this.useUTC) return function(T) {
                            return 6e4 * new Date(T.toString()).getTimezoneOffset()
                        };
                        if (f.timezone) {
                            if (C) return function(T) {
                                return -(6e4 * C.tz(T, f.timezone).utcOffset())
                            };
                            it(25)
                        }
                        return this.useUTC && m ? function(T) {
                            return 6e4 * m(T.valueOf())
                        } : function() {
                            return 6e4 * (g.timezoneOffset || 0)
                        }
                    }
                    dateFormat(g, f, m) {
                        if (!rt(f) || isNaN(f)) return et.defaultOptions.lang && et.defaultOptions.lang.invalidDate || "";
                        g = S(g, "%Y-%m-%d %H:%M:%S");
                        let C = this,
                            T = new this.Date(f),
                            P = this.get("Hours", T),
                            o = this.get("Day", T),
                            l = this.get("Date", T),
                            n = this.get("Month", T),
                            h = this.get("FullYear", T),
                            u = et.defaultOptions.lang,
                            e = u && u.weekdays,
                            t = u && u.shortWeekdays,
                            i = nt({
                                a: t ? t[o] : e[o].substr(0, 3),
                                A: e[o],
                                d: U(l),
                                e: U(l, 2, " "),
                                w: o,
                                b: u.shortMonths[n],
                                B: u.months[n],
                                m: U(n + 1),
                                o: n + 1,
                                y: h.toString().substr(2, 2),
                                Y: h,
                                H: U(P),
                                k: P,
                                I: U(P % 12 || 12),
                                l: P % 12 || 12,
                                M: U(this.get("Minutes", T)),
                                p: P < 12 ? "AM" : "PM",
                                P: P < 12 ? "am" : "pm",
                                S: U(this.get("Seconds", T)),
                                L: U(Math.floor(f % 1e3), 3)
                            }, et.dateFormats);
                        return Z(i, function(s, p) {
                            for (; g.indexOf("%" + p) !== -1;) g = g.replace("%" + p, typeof s == "function" ? s.call(C, f) : s)
                        }), m ? g.substr(0, 1).toUpperCase() + g.substr(1) : g
                    }
                    resolveDTLFormat(g) {
                        return ot(g, !0) ? g : {
                            main: (g = R(g))[0],
                            from: g[1],
                            to: g[2]
                        }
                    }
                    getTimeTicks(g, f, m, C) {
                        let T, P, o, l, n = this,
                            h = n.Date,
                            u = [],
                            e = {},
                            t = new h(f),
                            i = g.unitRange,
                            s = g.count || 1;
                        if (C = S(C, 1), rt(f)) {
                            n.set("Milliseconds", t, i >= E.second ? 0 : s * Math.floor(n.get("Milliseconds", t) / s)), i >= E.second && n.set("Seconds", t, i >= E.minute ? 0 : s * Math.floor(n.get("Seconds", t) / s)), i >= E.minute && n.set("Minutes", t, i >= E.hour ? 0 : s * Math.floor(n.get("Minutes", t) / s)), i >= E.hour && n.set("Hours", t, i >= E.day ? 0 : s * Math.floor(n.get("Hours", t) / s)), i >= E.day && n.set("Date", t, i >= E.month ? 1 : Math.max(1, s * Math.floor(n.get("Date", t) / s))), i >= E.month && (n.set("Month", t, i >= E.year ? 0 : s * Math.floor(n.get("Month", t) / s)), P = n.get("FullYear", t)), i >= E.year && (P -= P % s, n.set("FullYear", t, P)), i === E.week && (l = n.get("Day", t), n.set("Date", t, n.get("Date", t) - l + C + (l < C ? -7 : 0))), P = n.get("FullYear", t);
                            let p = n.get("Month", t),
                                x = n.get("Date", t),
                                O = n.get("Hours", t);
                            f = t.getTime(), (n.variableTimezone || !n.useUTC) && rt(m) && (o = m - f > 4 * E.month || n.getTimezoneOffset(f) !== n.getTimezoneOffset(m));
                            let d = t.getTime();
                            for (T = 1; d < m;) u.push(d), i === E.year ? d = n.makeTime(P + T * s, 0) : i === E.month ? d = n.makeTime(P, p + T * s) : o && (i === E.day || i === E.week) ? d = n.makeTime(P, p, x + T * s * (i === E.day ? 1 : 7)) : o && i === E.hour && s > 1 ? d = n.makeTime(P, p, x, O + T * s) : d += i * s, T++;
                            u.push(d), i <= E.hour && u.length < 1e4 && u.forEach(function(A) {
                                A % 18e5 == 0 && n.dateFormat("%H%M%S%L", A) === "000000000" && (e[A] = "day")
                            })
                        }
                        return u.info = nt(g, {
                            higherRanks: e,
                            totalRange: i * s
                        }), u
                    }
                    getDateFormat(g, f, m, C) {
                        let T = this.dateFormat("%m-%d %H:%M:%S.%L", f),
                            P = "01-01 00:00:00.000",
                            o = {
                                millisecond: 15,
                                second: 12,
                                minute: 9,
                                hour: 6,
                                day: 3
                            },
                            l = "millisecond",
                            n = l;
                        for (l in E) {
                            if (g === E.week && +this.dateFormat("%w", f) === m && T.substr(6) === P.substr(6)) {
                                l = "week";
                                break
                            }
                            if (E[l] > g) {
                                l = n;
                                break
                            }
                            if (o[l] && T.substr(o[l]) !== P.substr(o[l])) break;
                            l !== "week" && (n = l)
                        }
                        return this.resolveDTLFormat(C[l]).main
                    }
                }
            }), ft(Y, "Core/Defaults.js", [Y["Core/Chart/ChartDefaults.js"], Y["Core/Globals.js"], Y["Core/Color/Palettes.js"], Y["Core/Time.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt, it) {
                let {
                    isTouchDevice: nt,
                    svg: ot
                } = Q, {
                    merge: K
                } = it, Z = {
                    colors: ht.colors,
                    symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
                    lang: {
                        loading: "Loading...",
                        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                        weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                        decimalPoint: ".",
                        numericSymbols: ["k", "M", "G", "T", "P", "E"],
                        resetZoom: "Reset zoom",
                        resetZoomTitle: "Reset zoom level 1:1",
                        thousandsSep: " "
                    },
                    global: {},
                    time: {
                        Date: void 0,
                        getTimezoneOffset: void 0,
                        timezone: void 0,
                        timezoneOffset: 0,
                        useUTC: !0
                    },
                    chart: et,
                    title: {
                        style: {
                            color: "#333333",
                            fontWeight: "bold"
                        },
                        text: "Chart title",
                        align: "center",
                        margin: 15,
                        widthAdjust: -44
                    },
                    subtitle: {
                        style: {
                            color: "#666666",
                            fontSize: "0.8em"
                        },
                        text: "",
                        align: "center",
                        widthAdjust: -44
                    },
                    caption: {
                        margin: 15,
                        style: {
                            color: "#666666",
                            fontSize: "0.8em"
                        },
                        text: "",
                        align: "left",
                        verticalAlign: "bottom"
                    },
                    plotOptions: {},
                    legend: {
                        enabled: !0,
                        align: "center",
                        alignColumns: !0,
                        className: "highcharts-no-tooltip",
                        layout: "horizontal",
                        itemMarginBottom: 2,
                        itemMarginTop: 2,
                        labelFormatter: function() {
                            return this.name
                        },
                        borderColor: "#999999",
                        borderRadius: 0,
                        navigation: {
                            style: {
                                fontSize: "0.8em"
                            },
                            activeColor: "#0022ff",
                            inactiveColor: "#cccccc"
                        },
                        itemStyle: {
                            color: "#333333",
                            cursor: "pointer",
                            fontSize: "0.8em",
                            textDecoration: "none",
                            textOverflow: "ellipsis"
                        },
                        itemHoverStyle: {
                            color: "#000000"
                        },
                        itemHiddenStyle: {
                            color: "#666666",
                            textDecoration: "line-through"
                        },
                        shadow: !1,
                        itemCheckboxStyle: {
                            position: "absolute",
                            width: "13px",
                            height: "13px"
                        },
                        squareSymbol: !0,
                        symbolPadding: 5,
                        verticalAlign: "bottom",
                        x: 0,
                        y: 0,
                        title: {
                            style: {
                                fontSize: "0.8em",
                                fontWeight: "bold"
                            }
                        }
                    },
                    loading: {
                        labelStyle: {
                            fontWeight: "bold",
                            position: "relative",
                            top: "45%"
                        },
                        style: {
                            position: "absolute",
                            backgroundColor: "#ffffff",
                            opacity: .5,
                            textAlign: "center"
                        }
                    },
                    tooltip: {
                        enabled: !0,
                        animation: ot,
                        borderRadius: 3,
                        dateTimeLabelFormats: {
                            millisecond: "%A, %e %b, %H:%M:%S.%L",
                            second: "%A, %e %b, %H:%M:%S",
                            minute: "%A, %e %b, %H:%M",
                            hour: "%A, %e %b, %H:%M",
                            day: "%A, %e %b %Y",
                            week: "Week from %A, %e %b %Y",
                            month: "%B %Y",
                            year: "%Y"
                        },
                        footerFormat: "",
                        headerShape: "callout",
                        hideDelay: 500,
                        padding: 8,
                        shape: "callout",
                        shared: !1,
                        snap: nt ? 25 : 10,
                        headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>',
                        pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>',
                        backgroundColor: "#ffffff",
                        borderWidth: void 0,
                        shadow: !0,
                        stickOnContact: !1,
                        style: {
                            color: "#333333",
                            cursor: "default",
                            fontSize: "0.8em"
                        },
                        useHTML: !1
                    },
                    credits: {
                        enabled: !0,
                        href: "https://www.highcharts.com?credits",
                        position: {
                            align: "right",
                            x: -10,
                            verticalAlign: "bottom",
                            y: -5
                        },
                        style: {
                            cursor: "pointer",
                            color: "#999999",
                            fontSize: "0.6em"
                        },
                        text: "Highcharts.com"
                    }
                };
                Z.chart.styledMode = !1;
                let U = new rt(Z.time);
                return {
                    defaultOptions: Z,
                    defaultTime: U,
                    getOptions: function() {
                        return Z
                    },
                    setOptions: function(S) {
                        return K(!0, Z, S), (S.time || S.global) && (Q.time ? Q.time.update(K(Z.global, Z.time, S.global, S.time)) : Q.time = U), Z
                    }
                }
            }), ft(Y, "Core/Color/Color.js", [Y["Core/Globals.js"], Y["Core/Utilities.js"]], function(et, Q) {
                let {
                    isNumber: ht,
                    merge: rt,
                    pInt: it
                } = Q;
                class nt {
                    static parse(K) {
                        return K ? new nt(K) : nt.None
                    }
                    constructor(K) {
                        this.rgba = [NaN, NaN, NaN, NaN], this.input = K;
                        let Z = et.Color;
                        if (Z && Z !== nt) return new Z(K);
                        this.init(K)
                    }
                    init(K) {
                        let Z, U, S, R;
                        if (typeof K == "object" && K.stops !== void 0) this.stops = K.stops.map(E => new nt(E[1]));
                        else if (typeof K == "string") {
                            if (this.input = K = nt.names[K.toLowerCase()] || K, K.charAt(0) === "#") {
                                let E = K.length,
                                    M = parseInt(K.substr(1), 16);
                                E === 7 ? U = [(16711680 & M) >> 16, (65280 & M) >> 8, 255 & M, 1] : E === 4 && (U = [(3840 & M) >> 4 | (3840 & M) >> 8, (240 & M) >> 4 | 240 & M, (15 & M) << 4 | 15 & M, 1])
                            }
                            if (!U)
                                for (S = nt.parsers.length; S-- && !U;)(Z = (R = nt.parsers[S]).regex.exec(K)) && (U = R.parse(Z))
                        }
                        U && (this.rgba = U)
                    }
                    get(K) {
                        let Z = this.input,
                            U = this.rgba;
                        if (typeof Z == "object" && this.stops !== void 0) {
                            let S = rt(Z);
                            return S.stops = [].slice.call(S.stops), this.stops.forEach((R, E) => {
                                S.stops[E] = [S.stops[E][0], R.get(K)]
                            }), S
                        }
                        return U && ht(U[0]) ? K !== "rgb" && (K || U[3] !== 1) ? K === "a" ? `${U[3]}` : "rgba(" + U.join(",") + ")" : "rgb(" + U[0] + "," + U[1] + "," + U[2] + ")" : Z
                    }
                    brighten(K) {
                        let Z = this.rgba;
                        if (this.stops) this.stops.forEach(function(U) {
                            U.brighten(K)
                        });
                        else if (ht(K) && K !== 0)
                            for (let U = 0; U < 3; U++) Z[U] += it(255 * K), Z[U] < 0 && (Z[U] = 0), Z[U] > 255 && (Z[U] = 255);
                        return this
                    }
                    setOpacity(K) {
                        return this.rgba[3] = K, this
                    }
                    tweenTo(K, Z) {
                        let U = this.rgba,
                            S = K.rgba;
                        if (!ht(U[0]) || !ht(S[0])) return K.input || "none";
                        let R = S[3] !== 1 || U[3] !== 1;
                        return (R ? "rgba(" : "rgb(") + Math.round(S[0] + (U[0] - S[0]) * (1 - Z)) + "," + Math.round(S[1] + (U[1] - S[1]) * (1 - Z)) + "," + Math.round(S[2] + (U[2] - S[2]) * (1 - Z)) + (R ? "," + (S[3] + (U[3] - S[3]) * (1 - Z)) : "") + ")"
                    }
                }
                return nt.names = {
                    white: "#ffffff",
                    black: "#000000"
                }, nt.parsers = [{
                    regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
                    parse: function(ot) {
                        return [it(ot[1]), it(ot[2]), it(ot[3]), parseFloat(ot[4], 10)]
                    }
                }, {
                    regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
                    parse: function(ot) {
                        return [it(ot[1]), it(ot[2]), it(ot[3]), 1]
                    }
                }], nt.None = new nt(""), nt
            }), ft(Y, "Core/Animation/Fx.js", [Y["Core/Color/Color.js"], Y["Core/Globals.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                let {
                    parse: rt
                } = et, {
                    win: it
                } = Q, {
                    isNumber: nt,
                    objectEach: ot
                } = ht;
                class K {
                    constructor(U, S, R) {
                        this.pos = NaN, this.options = S, this.elem = U, this.prop = R
                    }
                    dSetter() {
                        let U = this.paths,
                            S = U && U[0],
                            R = U && U[1],
                            E = this.now || 0,
                            M = [];
                        if (E !== 1 && S && R)
                            if (S.length === R.length && E < 1)
                                for (let k = 0; k < R.length; k++) {
                                    let g = S[k],
                                        f = R[k],
                                        m = [];
                                    for (let C = 0; C < f.length; C++) {
                                        let T = g[C],
                                            P = f[C];
                                        nt(T) && nt(P) && !(f[0] === "A" && (C === 4 || C === 5)) ? m[C] = T + E * (P - T) : m[C] = P
                                    }
                                    M.push(m)
                                } else M = R;
                        else M = this.toD || [];
                        this.elem.attr("d", M, void 0, !0)
                    }
                    update() {
                        let U = this.elem,
                            S = this.prop,
                            R = this.now,
                            E = this.options.step;
                        this[S + "Setter"] ? this[S + "Setter"]() : U.attr ? U.element && U.attr(S, R, null, !0) : U.style[S] = R + this.unit, E && E.call(U, R, this)
                    }
                    run(U, S, R) {
                        let E = this,
                            M = E.options,
                            k = function(m) {
                                return !k.stopped && E.step(m)
                            },
                            g = it.requestAnimationFrame || function(m) {
                                setTimeout(m, 13)
                            },
                            f = function() {
                                for (let m = 0; m < K.timers.length; m++) K.timers[m]() || K.timers.splice(m--, 1);
                                K.timers.length && g(f)
                            };
                        U !== S || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date, this.start = U, this.end = S, this.unit = R, this.now = this.start, this.pos = 0, k.elem = this.elem, k.prop = this.prop, k() && K.timers.push(k) === 1 && g(f)) : (delete M.curAnim[this.prop], M.complete && Object.keys(M.curAnim).length === 0 && M.complete.call(this.elem))
                    }
                    step(U) {
                        let S, R, E = +new Date,
                            M = this.options,
                            k = this.elem,
                            g = M.complete,
                            f = M.duration,
                            m = M.curAnim;
                        return k.attr && !k.element ? S = !1 : U || E >= f + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), m[this.prop] = !0, R = !0, ot(m, function(C) {
                            C !== !0 && (R = !1)
                        }), R && g && g.call(k), S = !1) : (this.pos = M.easing((E - this.startTime) / f), this.now = this.start + (this.end - this.start) * this.pos, this.update(), S = !0), S
                    }
                    initPath(U, S, R) {
                        let E = U.startX,
                            M = U.endX,
                            k = R.slice(),
                            g = U.isArea,
                            f = g ? 2 : 1,
                            m, C, T, P, o = S && S.slice();
                        if (!o) return [k, k];

                        function l(h, u) {
                            for (; h.length < C;) {
                                let e = h[0],
                                    t = u[C - h.length];
                                if (t && e[0] === "M" && (t[0] === "C" ? h[0] = ["C", e[1], e[2], e[1], e[2], e[1], e[2]] : h[0] = ["L", e[1], e[2]]), h.unshift(e), g) {
                                    let i = h.pop();
                                    h.push(h[h.length - 1], i)
                                }
                            }
                        }

                        function n(h, u) {
                            for (; h.length < C;) {
                                let e = h[Math.floor(h.length / f) - 1].slice();
                                if (e[0] === "C" && (e[1] = e[5], e[2] = e[6]), g) {
                                    let t = h[Math.floor(h.length / f)].slice();
                                    h.splice(h.length / 2, 0, e, t)
                                } else h.push(e)
                            }
                        }
                        if (E && M && M.length) {
                            for (T = 0; T < E.length; T++) {
                                if (E[T] === M[0]) {
                                    m = T;
                                    break
                                }
                                if (E[0] === M[M.length - E.length + T]) {
                                    m = T, P = !0;
                                    break
                                }
                                if (E[E.length - 1] === M[M.length - E.length + T]) {
                                    m = E.length - T;
                                    break
                                }
                            }
                            m === void 0 && (o = [])
                        }
                        return o.length && nt(m) && (C = k.length + m * f, P ? (l(o, k), n(k)) : (l(k, o), n(o))), [o, k]
                    }
                    fillSetter() {
                        K.prototype.strokeSetter.apply(this, arguments)
                    }
                    strokeSetter() {
                        this.elem.attr(this.prop, rt(this.start).tweenTo(rt(this.end), this.pos), void 0, !0)
                    }
                }
                return K.timers = [], K
            }), ft(Y, "Core/Animation/AnimationUtilities.js", [Y["Core/Animation/Fx.js"], Y["Core/Utilities.js"]], function(et, Q) {
                let {
                    defined: ht,
                    getStyle: rt,
                    isArray: it,
                    isNumber: nt,
                    isObject: ot,
                    merge: K,
                    objectEach: Z,
                    pick: U
                } = Q;

                function S(E) {
                    return ot(E) ? K({
                        duration: 500,
                        defer: 0
                    }, E) : {
                        duration: E ? 500 : 0,
                        defer: 0
                    }
                }

                function R(E, M) {
                    let k = et.timers.length;
                    for (; k--;) et.timers[k].elem !== E || M && M !== et.timers[k].prop || (et.timers[k].stopped = !0)
                }
                return {
                    animate: function(E, M, k) {
                        let g, f = "",
                            m, C, T;
                        ot(k) || (T = arguments, k = {
                            duration: T[2],
                            easing: T[3],
                            complete: T[4]
                        }), nt(k.duration) || (k.duration = 400), k.easing = typeof k.easing == "function" ? k.easing : Math[k.easing] || Math.easeInOutSine, k.curAnim = K(M), Z(M, function(P, o) {
                            R(E, o), C = new et(E, k, o), m = void 0, o === "d" && it(M.d) ? (C.paths = C.initPath(E, E.pathArray, M.d), C.toD = M.d, g = 0, m = 1) : E.attr ? g = E.attr(o) : (g = parseFloat(rt(E, o)) || 0, o !== "opacity" && (f = "px")), m || (m = P), typeof m == "string" && m.match("px") && (m = m.replace(/px/g, "")), C.run(g, m, f)
                        })
                    },
                    animObject: S,
                    getDeferredAnimation: function(E, M, k) {
                        let g = S(M),
                            f = k ? [k] : E.series,
                            m = 0,
                            C = 0;
                        return f.forEach(P => {
                            let o = S(P.options.animation);
                            m = M && ht(M.defer) ? g.defer : Math.max(m, o.duration + o.defer), C = Math.min(g.duration, o.duration)
                        }), E.renderer.forExport && (m = 0), {
                            defer: Math.max(0, m - C),
                            duration: Math.min(m, C)
                        }
                    },
                    setAnimation: function(E, M) {
                        M.renderer.globalAnimation = U(E, M.options.chart.animation, !0)
                    },
                    stop: R
                }
            }), ft(Y, "Core/Renderer/HTML/AST.js", [Y["Core/Globals.js"], Y["Core/Utilities.js"]], function(et, Q) {
                let {
                    SVG_NS: ht,
                    win: rt
                } = et, {
                    attr: it,
                    createElement: nt,
                    css: ot,
                    error: K,
                    isFunction: Z,
                    isString: U,
                    objectEach: S,
                    splat: R
                } = Q, {
                    trustedTypes: E
                } = rt, M = E && Z(E.createPolicy) && E.createPolicy("highcharts", {
                    createHTML: m => m
                }), k = M ? M.createHTML("") : "", g = function() {
                    try {
                        return !!new DOMParser().parseFromString(k, "text/html")
                    } catch {
                        return !1
                    }
                }();
                class f {
                    static filterUserAttributes(C) {
                        return S(C, (T, P) => {
                            let o = !0;
                            f.allowedAttributes.indexOf(P) === -1 && (o = !1), ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(P) !== -1 && (o = U(T) && f.allowedReferences.some(l => T.indexOf(l) === 0)), o || (K(33, !1, void 0, {
                                "Invalid attribute in config": `${P}`
                            }), delete C[P]), U(T) && C[P] && (C[P] = T.replace(/</g, "&lt;"))
                        }), C
                    }
                    static parseStyle(C) {
                        return C.split(";").reduce((T, P) => {
                            let o = P.split(":").map(n => n.trim()),
                                l = o.shift();
                            return l && o.length && (T[l.replace(/-([a-z])/g, n => n[1].toUpperCase())] = o.join(":")), T
                        }, {})
                    }
                    static setElementHTML(C, T) {
                        C.innerHTML = f.emptyHTML, T && new f(T).addToDOM(C)
                    }
                    constructor(C) {
                        this.nodes = typeof C == "string" ? this.parseMarkup(C) : C
                    }
                    addToDOM(C) {
                        return function T(P, o) {
                            let l;
                            return R(P).forEach(function(n) {
                                let h, u = n.tagName,
                                    e = n.textContent ? et.doc.createTextNode(n.textContent) : void 0,
                                    t = f.bypassHTMLFiltering;
                                if (u)
                                    if (u === "#text") h = e;
                                    else if (f.allowedTags.indexOf(u) !== -1 || t) {
                                        let i = u === "svg" ? ht : o.namespaceURI || ht,
                                            s = et.doc.createElementNS(i, u),
                                            p = n.attributes || {};
                                        S(n, function(x, O) {
                                            O !== "tagName" && O !== "attributes" && O !== "children" && O !== "style" && O !== "textContent" && (p[O] = x)
                                        }), it(s, t ? p : f.filterUserAttributes(p)), n.style && ot(s, n.style), e && s.appendChild(e), T(n.children || [], s), h = s
                                    } else K(33, !1, void 0, {
                                        "Invalid tagName in config": u
                                    });
                                h && o.appendChild(h), l = h
                            }), l
                        }(this.nodes, C)
                    }
                    parseMarkup(C) {
                        let T, P = [];
                        if (C = C.trim().replace(/ style=(["'])/g, " data-style=$1"), g) T = new DOMParser().parseFromString(M ? M.createHTML(C) : C, "text/html");
                        else {
                            let l = nt("div");
                            l.innerHTML = C, T = {
                                body: l
                            }
                        }
                        let o = (l, n) => {
                            let h = l.nodeName.toLowerCase(),
                                u = {
                                    tagName: h
                                };
                            h === "#text" && (u.textContent = l.textContent || "");
                            let e = l.attributes;
                            if (e) {
                                let t = {};
                                [].forEach.call(e, i => {
                                    i.name === "data-style" ? u.style = f.parseStyle(i.value) : t[i.name] = i.value
                                }), u.attributes = t
                            }
                            if (l.childNodes.length) {
                                let t = [];
                                [].forEach.call(l.childNodes, i => {
                                    o(i, t)
                                }), t.length && (u.children = t)
                            }
                            n.push(u)
                        };
                        return [].forEach.call(T.body.childNodes, l => o(l, P)), P
                    }
                }
                return f.allowedAttributes = ["alt", "aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup", "aria-hidden", "aria-label", "aria-labelledby", "aria-live", "aria-pressed", "aria-readonly", "aria-roledescription", "aria-selected", "class", "clip-path", "color", "colspan", "cx", "cy", "d", "dx", "dy", "disabled", "fill", "filterUnits", "flood-color", "flood-opacity", "height", "href", "id", "in", "markerHeight", "markerWidth", "offset", "opacity", "orient", "padding", "paddingLeft", "paddingRight", "patternUnits", "r", "refX", "refY", "role", "scope", "slope", "src", "startOffset", "stdDeviation", "stroke", "stroke-linecap", "stroke-width", "style", "tableValues", "result", "rowspan", "summary", "target", "tabindex", "text-align", "text-anchor", "textAnchor", "textLength", "title", "type", "valign", "width", "x", "x1", "x2", "xlink:href", "y", "y1", "y2", "zIndex"], f.allowedReferences = ["https://", "http://", "mailto:", "/", "../", "./", "#"], f.allowedTags = ["a", "abbr", "b", "br", "button", "caption", "circle", "clipPath", "code", "dd", "defs", "div", "dl", "dt", "em", "feComponentTransfer", "feDropShadow", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feOffset", "feMerge", "feMergeNode", "filter", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "li", "linearGradient", "marker", "ol", "p", "path", "pattern", "pre", "rect", "small", "span", "stop", "strong", "style", "sub", "sup", "svg", "table", "text", "textPath", "thead", "title", "tbody", "tspan", "td", "th", "tr", "u", "ul", "#text"], f.emptyHTML = k, f.bypassHTMLFiltering = !1, f
            }), ft(Y, "Core/Templating.js", [Y["Core/Defaults.js"], Y["Core/Utilities.js"]], function(et, Q) {
                let {
                    defaultOptions: ht,
                    defaultTime: rt
                } = et, {
                    extend: it,
                    getNestedProperty: nt,
                    isArray: ot,
                    isNumber: K,
                    isObject: Z,
                    isString: U,
                    pick: S,
                    pInt: R
                } = Q, E = {
                    add: (g, f) => g + f,
                    divide: (g, f) => f !== 0 ? g / f : "",
                    eq: (g, f) => g == f,
                    each: function(g) {
                        let f = arguments[arguments.length - 1];
                        return !!ot(g) && g.map((m, C) => M(f.body, it(Z(m) ? m : {
                            "@this": m
                        }, {
                            "@index": C,
                            "@first": C === 0,
                            "@last": C === g.length - 1
                        }))).join("")
                    },
                    ge: (g, f) => g >= f,
                    gt: (g, f) => g > f,
                    if: g => !!g,
                    le: (g, f) => g <= f,
                    lt: (g, f) => g < f,
                    multiply: (g, f) => g * f,
                    ne: (g, f) => g != f,
                    subtract: (g, f) => g - f,
                    unless: g => !g
                };

                function M(g = "", f, m) {
                    let C = /\{([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= #\(\)]+)\}/g,
                        T = /\(([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= ]+)\)/g,
                        P = [],
                        o = /f$/,
                        l = /\.([0-9])/,
                        n = ht.lang,
                        h = m && m.time || rt,
                        u = m && m.numberFormatter || k,
                        e = (x = "") => {
                            let O;
                            return x === "true" || x !== "false" && ((O = Number(x)).toString() === x ? O : nt(x, f))
                        },
                        t, i, s = 0,
                        p;
                    for (;
                        (t = C.exec(g)) !== null;) {
                        let x = T.exec(t[1]);
                        x && (t = x, p = !0), i && i.isBlock || (i = {
                            ctx: f,
                            expression: t[1],
                            find: t[0],
                            isBlock: t[1].charAt(0) === "#",
                            start: t.index,
                            startInner: t.index + t[0].length,
                            length: t[0].length
                        });
                        let O = t[1].split(" ")[0].replace("#", "");
                        E[O] && (i.isBlock && O === i.fn && s++, i.fn || (i.fn = O));
                        let d = t[1] === "else";
                        if (i.isBlock && i.fn && (t[1] === `/${i.fn}` || d))
                            if (s) !d && s--;
                            else {
                                let A = i.startInner,
                                    L = g.substr(A, t.index - A);
                                i.body === void 0 ? (i.body = L, i.startInner = t.index + t[0].length) : i.elseBody = L, i.find += L + t[0], d || (P.push(i), i = void 0)
                            }
                        else i.isBlock || P.push(i);
                        if (x && !(i != null && i.isBlock)) break
                    }
                    return P.forEach(x => {
                        let O, d, {
                            body: A,
                            elseBody: L,
                            expression: V,
                            fn: B
                        } = x;
                        if (B) {
                            let r = [x],
                                c = V.split(" ");
                            for (d = E[B].length; d--;) r.unshift(e(c[d + 1]));
                            O = E[B].apply(f, r), x.isBlock && typeof O == "boolean" && (O = M(O ? A : L, f))
                        } else {
                            let r = V.split(":");
                            if (O = e(r.shift() || ""), r.length && typeof O == "number") {
                                let c = r.join(":");
                                if (o.test(c)) {
                                    let b = parseInt((c.match(l) || ["", "-1"])[1], 10);
                                    O !== null && (O = u(O, b, n.decimalPoint, c.indexOf(",") > -1 ? n.thousandsSep : ""))
                                } else O = h.dateFormat(c, O)
                            }
                        }
                        g = g.replace(x.find, S(O, ""))
                    }), p ? M(g, f, m) : g
                }

                function k(g, f, m, C) {
                    let T, P;
                    g = +g || 0, f = +f;
                    let o = ht.lang,
                        l = (g.toString().split(".")[1] || "").split("e")[0].length,
                        n = g.toString().split("e"),
                        h = f;
                    f === -1 ? f = Math.min(l, 20) : K(f) ? f && n[1] && n[1] < 0 && ((P = f + +n[1]) >= 0 ? (n[0] = (+n[0]).toExponential(P).split("e")[0], f = P) : (n[0] = n[0].split(".")[0] || 0, g = f < 20 ? (n[0] * Math.pow(10, n[1])).toFixed(f) : 0, n[1] = 0)) : f = 2;
                    let u = (Math.abs(n[1] ? n[0] : g) + Math.pow(10, -Math.max(f, l) - 1)).toFixed(f),
                        e = String(R(u)),
                        t = e.length > 3 ? e.length % 3 : 0;
                    return m = S(m, o.decimalPoint), C = S(C, o.thousandsSep), T = (g < 0 ? "-" : "") + (t ? e.substr(0, t) + C : ""), 0 > +n[1] && !h ? T = "0" : T += e.substr(t).replace(/(\d{3})(?=\d)/g, "$1" + C), f && (T += m + u.slice(-f)), n[1] && +T != 0 && (T += "e" + n[1]), T
                }
                return {
                    dateFormat: function(g, f, m) {
                        return rt.dateFormat(g, f, m)
                    },
                    format: M,
                    helpers: E,
                    numberFormat: k
                }
            }), ft(Y, "Core/Renderer/RendererUtilities.js", [Y["Core/Utilities.js"]], function(et) {
                var Q;
                let {
                    clamp: ht,
                    pick: rt,
                    pushUnique: it,
                    stableSort: nt
                } = et;
                return (Q || (Q = {})).distribute = function ot(K, Z, U) {
                    let S = K,
                        R = S.reducedLen || Z,
                        E = (u, e) => u.target - e.target,
                        M = [],
                        k = K.length,
                        g = [],
                        f = M.push,
                        m, C, T, P = !0,
                        o, l, n = 0,
                        h;
                    for (m = k; m--;) n += K[m].size;
                    if (n > R) {
                        for (nt(K, (u, e) => (e.rank || 0) - (u.rank || 0)), T = (h = K[0].rank === K[K.length - 1].rank) ? k / 2 : -1, C = h ? T : k - 1; T && n > R;) o = K[m = Math.floor(C)], it(g, m) && (n -= o.size), C += T, h && C >= K.length && (T /= 2, C = T);
                        g.sort((u, e) => e - u).forEach(u => f.apply(M, K.splice(u, 1)))
                    }
                    for (nt(K, E), K = K.map(u => ({
                        size: u.size,
                        targets: [u.target],
                        align: rt(u.align, .5)
                    })); P;) {
                        for (m = K.length; m--;) o = K[m], l = (Math.min.apply(0, o.targets) + Math.max.apply(0, o.targets)) / 2, o.pos = ht(l - o.size * o.align, 0, Z - o.size);
                        for (m = K.length, P = !1; m--;) m > 0 && K[m - 1].pos + K[m - 1].size > K[m].pos && (K[m - 1].size += K[m].size, K[m - 1].targets = K[m - 1].targets.concat(K[m].targets), K[m - 1].align = .5, K[m - 1].pos + K[m - 1].size > Z && (K[m - 1].pos = Z - K[m - 1].size), K.splice(m, 1), P = !0)
                    }
                    return f.apply(S, M), m = 0, K.some(u => {
                        let e = 0;
                        return (u.targets || []).some(() => (S[m].pos = u.pos + e, U !== void 0 && Math.abs(S[m].pos - S[m].target) > U ? (S.slice(0, m + 1).forEach(t => delete t.pos), S.reducedLen = (S.reducedLen || Z) - .1 * Z, S.reducedLen > .1 * Z && ot(S, Z, U), !0) : (e += S[m].size, m++, !1)))
                    }), nt(S, E), S
                }, Q
            }), ft(Y, "Core/Renderer/SVG/SVGElement.js", [Y["Core/Animation/AnimationUtilities.js"], Y["Core/Color/Color.js"], Y["Core/Globals.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt) {
                let {
                    animate: it,
                    animObject: nt,
                    stop: ot
                } = et, {
                    deg2rad: K,
                    doc: Z,
                    noop: U,
                    svg: S,
                    SVG_NS: R,
                    win: E
                } = ht, {
                    addEvent: M,
                    attr: k,
                    createElement: g,
                    css: f,
                    defined: m,
                    erase: C,
                    extend: T,
                    fireEvent: P,
                    isArray: o,
                    isFunction: l,
                    isObject: n,
                    isString: h,
                    merge: u,
                    objectEach: e,
                    pick: t,
                    pInt: i,
                    syncTimeout: s,
                    uniqueKey: p
                } = rt;
                class x {
                    constructor() {
                        this.element = void 0, this.onEvents = {}, this.opacity = 1, this.renderer = void 0, this.SVG_NS = R
                    }
                    _defaultGetter(d) {
                        let A = t(this[d + "Value"], this[d], this.element ? this.element.getAttribute(d) : null, 0);
                        return /^[\-0-9\.]+$/.test(A) && (A = parseFloat(A)), A
                    }
                    _defaultSetter(d, A, L) {
                        L.setAttribute(A, d)
                    }
                    add(d) {
                        let A, L = this.renderer,
                            V = this.element;
                        return d && (this.parentGroup = d), this.textStr !== void 0 && this.element.nodeName === "text" && L.buildText(this), this.added = !0, (!d || d.handleZ || this.zIndex) && (A = this.zIndexSetter()), A || (d ? d.element : L.box).appendChild(V), this.onAdd && this.onAdd(), this
                    }
                    addClass(d, A) {
                        let L = A ? "" : this.attr("class") || "";
                        return (d = (d || "").split(/ /g).reduce(function(V, B) {
                            return L.indexOf(B) === -1 && V.push(B), V
                        }, L ? [L] : []).join(" ")) !== L && this.attr("class", d), this
                    }
                    afterSetters() {
                        this.doTransform && (this.updateTransform(), this.doTransform = !1)
                    }
                    align(d, A, L) {
                        let V, B, r, c, b, N = {},
                            z = this.renderer,
                            W = z.alignedObjects;
                        d ? (this.alignOptions = d, this.alignByTranslate = A, (!L || h(L)) && (this.alignTo = r = L || "renderer", C(W, this), W.push(this), L = void 0)) : (d = this.alignOptions, A = this.alignByTranslate, r = this.alignTo), L = t(L, z[r], r === "scrollablePlotBox" ? z.plotBox : void 0, z);
                        let a = d.align,
                            v = d.verticalAlign;
                        return V = (L.x || 0) + (d.x || 0), B = (L.y || 0) + (d.y || 0), a === "right" ? c = 1 : a === "center" && (c = 2), c && (V += (L.width - (d.width || 0)) / c), N[A ? "translateX" : "x"] = Math.round(V), v === "bottom" ? b = 1 : v === "middle" && (b = 2), b && (B += (L.height - (d.height || 0)) / b), N[A ? "translateY" : "y"] = Math.round(B), this[this.placed ? "animate" : "attr"](N), this.placed = !0, this.alignAttr = N, this
                    }
                    alignSetter(d) {
                        let A = {
                            left: "start",
                            center: "middle",
                            right: "end"
                        };
                        A[d] && (this.alignValue = d, this.element.setAttribute("text-anchor", A[d]))
                    }
                    animate(d, A, L) {
                        let V = nt(t(A, this.renderer.globalAnimation, !0)),
                            B = V.defer;
                        return Z.hidden && (V.duration = 0), V.duration !== 0 ? (L && (V.complete = L), s(() => {
                            this.element && it(this, d, V)
                        }, B)) : (this.attr(d, void 0, L || V.complete), e(d, function(r, c) {
                            V.step && V.step.call(this, r, {
                                prop: c,
                                pos: 1,
                                elem: this
                            })
                        }, this)), this
                    }
                    applyTextOutline(d) {
                        let A = this.element;
                        d.indexOf("contrast") !== -1 && (d = d.replace(/contrast/g, this.renderer.getContrast(A.style.fill)));
                        let V = d.split(" "),
                            B = V[V.length - 1],
                            r = V[0];
                        if (r && r !== "none" && ht.svg) {
                            this.fakeTS = !0, r = r.replace(/(^[\d\.]+)(.*?)$/g, function(W, a, v) {
                                return 2 * Number(a) + v
                            }), this.removeTextOutline();
                            let c = Z.createElementNS(R, "tspan");
                            k(c, {
                                class: "highcharts-text-outline",
                                fill: B,
                                stroke: B,
                                "stroke-width": r,
                                "stroke-linejoin": "round"
                            });
                            let b = A.querySelector("textPath") || A;
                            [].forEach.call(b.childNodes, W => {
                                let a = W.cloneNode(!0);
                                a.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(v => a.removeAttribute(v)), c.appendChild(a)
                            });
                            let N = 0;
                            [].forEach.call(b.querySelectorAll("text tspan"), W => {
                                N += Number(W.getAttribute("dy"))
                            });
                            let z = Z.createElementNS(R, "tspan");
                            z.textContent = "​", k(z, {
                                x: Number(A.getAttribute("x")),
                                dy: -N
                            }), c.appendChild(z), b.insertBefore(c, b.firstChild)
                        }
                    }
                    attr(d, A, L, V) {
                        let B = this.element,
                            r = x.symbolCustomAttribs,
                            c, b, N = this,
                            z;
                        return typeof d == "string" && A !== void 0 && (c = d, (d = {})[c] = A), typeof d == "string" ? N = (this[d + "Getter"] || this._defaultGetter).call(this, d, B) : (e(d, function(W, a) {
                            z = !1, V || ot(this, a), this.symbolName && r.indexOf(a) !== -1 && (b || (this.symbolAttr(d), b = !0), z = !0), this.rotation && (a === "x" || a === "y") && (this.doTransform = !0), z || (this[a + "Setter"] || this._defaultSetter).call(this, W, a, B)
                        }, this), this.afterSetters()), L && L.call(this), N
                    }
                    clip(d) {
                        return this.attr("clip-path", d ? "url(" + this.renderer.url + "#" + d.id + ")" : "none")
                    }
                    crisp(d, A) {
                        A = A || d.strokeWidth || 0;
                        let L = Math.round(A) % 2 / 2;
                        return d.x = Math.floor(d.x || this.x || 0) + L, d.y = Math.floor(d.y || this.y || 0) + L, d.width = Math.floor((d.width || this.width || 0) - 2 * L), d.height = Math.floor((d.height || this.height || 0) - 2 * L), m(d.strokeWidth) && (d.strokeWidth = A), d
                    }
                    complexColor(d, A, L) {
                        let V = this.renderer,
                            B, r, c, b, N, z, W, a, v, y, I = [],
                            w;
                        P(this.renderer, "complexColor", {
                            args: arguments
                        }, function() {
                            if (d.radialGradient ? r = "radialGradient" : d.linearGradient && (r = "linearGradient"), r) {
                                if (c = d[r], N = V.gradients, z = d.stops, v = L.radialReference, o(c) && (d[r] = c = {
                                    x1: c[0],
                                    y1: c[1],
                                    x2: c[2],
                                    y2: c[3],
                                    gradientUnits: "userSpaceOnUse"
                                }), r === "radialGradient" && v && !m(c.gradientUnits) && (b = c, c = u(c, V.getRadialAttr(v, b), {
                                    gradientUnits: "userSpaceOnUse"
                                })), e(c, function(G, X) {
                                    X !== "id" && I.push(X, G)
                                }), e(z, function(G) {
                                    I.push(G)
                                }), N[I = I.join(",")]) y = N[I].attr("id");
                                else {
                                    c.id = y = p();
                                    let G = N[I] = V.createElement(r).attr(c).add(V.defs);
                                    G.radAttr = b, G.stops = [], z.forEach(function(X) {
                                        X[1].indexOf("rgba") === 0 ? (W = (B = Q.parse(X[1])).get("rgb"), a = B.get("a")) : (W = X[1], a = 1);
                                        let _ = V.createElement("stop").attr({
                                            offset: X[0],
                                            "stop-color": W,
                                            "stop-opacity": a
                                        }).add(G);
                                        G.stops.push(_)
                                    })
                                }
                                w = "url(" + V.url + "#" + y + ")", L.setAttribute(A, w), L.gradient = I, d.toString = function() {
                                    return w
                                }
                            }
                        })
                    }
                    css(d) {
                        let A = this.styles,
                            L = {},
                            V = this.element,
                            B, r = !A;
                        if (A && e(d, function(c, b) {
                            A && A[b] !== c && (L[b] = c, r = !0)
                        }), r) {
                            A && (d = T(A, L)), d.width === null || d.width === "auto" ? delete this.textWidth : V.nodeName.toLowerCase() === "text" && d.width && (B = this.textWidth = i(d.width)), this.styles = d, B && !S && this.renderer.forExport && delete d.width;
                            let c = u(d);
                            V.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "width"].forEach(b => c && delete c[b]), c.color && (c.fill = c.color)), f(V, c)
                        }
                        return this.added && (this.element.nodeName === "text" && this.renderer.buildText(this), d.textOutline && this.applyTextOutline(d.textOutline)), this
                    }
                    dashstyleSetter(d) {
                        let A, L = this["stroke-width"];
                        if (L === "inherit" && (L = 1), d = d && d.toLowerCase()) {
                            let V = d.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
                            for (A = V.length; A--;) V[A] = "" + i(V[A]) * t(L, NaN);
                            d = V.join(",").replace(/NaN/g, "none"), this.element.setAttribute("stroke-dasharray", d)
                        }
                    }
                    destroy() {
                        var b;
                        let d = this,
                            A = d.element || {},
                            L = d.renderer,
                            V = A.ownerSVGElement,
                            B = A.nodeName === "SPAN" && d.parentGroup || void 0,
                            r, c;
                        if (A.onclick = A.onmouseout = A.onmouseover = A.onmousemove = A.point = null, ot(d), d.clipPath && V) {
                            let N = d.clipPath;
                            [].forEach.call(V.querySelectorAll("[clip-path],[CLIP-PATH]"), function(z) {
                                z.getAttribute("clip-path").indexOf(N.element.id) > -1 && z.removeAttribute("clip-path")
                            }), d.clipPath = N.destroy()
                        }
                        if (d.connector = (b = d.connector) == null ? void 0 : b.destroy(), d.stops) {
                            for (c = 0; c < d.stops.length; c++) d.stops[c].destroy();
                            d.stops.length = 0, d.stops = void 0
                        }
                        for (d.safeRemoveChild(A); B && B.div && B.div.childNodes.length === 0;) r = B.parentGroup, d.safeRemoveChild(B.div), delete B.div, B = r;
                        d.alignTo && C(L.alignedObjects, d), e(d, function(N, z) {
                            d[z] && d[z].parentGroup === d && d[z].destroy && d[z].destroy(), delete d[z]
                        })
                    }
                    dSetter(d, A, L) {
                        o(d) && (typeof d[0] == "string" && (d = this.renderer.pathToSegments(d)), this.pathArray = d, d = d.reduce((V, B, r) => B && B.join ? (r ? V + " " : "") + B.join(" ") : (B || "").toString(), "")), /(NaN| {2}|^$)/.test(d) && (d = "M 0 0"), this[A] !== d && (L.setAttribute(A, d), this[A] = d)
                    }
                    fillSetter(d, A, L) {
                        typeof d == "string" ? L.setAttribute(A, d) : d && this.complexColor(d, A, L)
                    }
                    hrefSetter(d, A, L) {
                        L.setAttributeNS("http://www.w3.org/1999/xlink", A, d)
                    }
                    getBBox(d, A) {
                        let L, V, B, r, c, {
                                alignValue: b,
                                element: N,
                                renderer: z,
                                styles: W,
                                textStr: a
                            } = this,
                            {
                                cache: v,
                                cacheKeys: y
                            } = z,
                            I = N.namespaceURI === this.SVG_NS,
                            w = t(A, this.rotation, 0),
                            G = z.styledMode ? N && x.prototype.getStyle.call(N, "font-size") : W && W.fontSize;
                        if (m(a) && ((c = a.toString()).indexOf("<") === -1 && (c = c.replace(/[0-9]/g, "0")), c += ["", z.rootFontSize, G, w, this.textWidth, b, W && W.textOverflow, W && W.fontWeight].join(",")), c && !d && (L = v[c]), !L) {
                            if (I || z.forExport) {
                                try {
                                    r = this.fakeTS && function(X) {
                                        let _ = N.querySelector(".highcharts-text-outline");
                                        _ && f(_, {
                                            display: X
                                        })
                                    }, l(r) && r("none"), L = N.getBBox ? T({}, N.getBBox()) : {
                                        width: N.offsetWidth,
                                        height: N.offsetHeight,
                                        x: 0,
                                        y: 0
                                    }, l(r) && r("")
                                } catch {}(!L || L.width < 0) && (L = {
                                    x: 0,
                                    y: 0,
                                    width: 0,
                                    height: 0
                                })
                            } else L = this.htmlGetBBox();
                            if (V = L.width, B = L.height, I && (L.height = B = {
                                "11px,17": 14,
                                "13px,20": 16
                            } [`${G||""},${Math.round(B)}`] || B), w) {
                                let X = Number(N.getAttribute("y") || 0) - L.y,
                                    _ = {
                                        right: 1,
                                        center: .5
                                    } [b || 0] || 0,
                                    $ = w * K,
                                    st = (w - 90) * K,
                                    D = V * Math.cos($),
                                    j = V * Math.sin($),
                                    F = Math.cos(st),
                                    H = Math.sin(st),
                                    q = L.x + _ * (V - D),
                                    J = L.y + X - _ * j,
                                    at = q + X * F,
                                    tt = at + D,
                                    dt = tt - B * F,
                                    pt = dt - D,
                                    lt = J + X * H,
                                    ut = lt + j,
                                    mt = ut - B * H,
                                    xt = mt - j;
                                L.x = Math.min(at, tt, dt, pt), L.y = Math.min(lt, ut, mt, xt), L.width = Math.max(at, tt, dt, pt) - L.x, L.height = Math.max(lt, ut, mt, xt) - L.y
                            }
                        }
                        if (c && (a === "" || L.height > 0)) {
                            for (; y.length > 250;) delete v[y.shift()];
                            v[c] || y.push(c), v[c] = L
                        }
                        return L
                    }
                    getStyle(d) {
                        return E.getComputedStyle(this.element || this, "").getPropertyValue(d)
                    }
                    hasClass(d) {
                        return ("" + this.attr("class")).split(" ").indexOf(d) !== -1
                    }
                    hide() {
                        return this.attr({
                            visibility: "hidden"
                        })
                    }
                    htmlGetBBox() {
                        return {
                            height: 0,
                            width: 0,
                            x: 0,
                            y: 0
                        }
                    }
                    init(d, A) {
                        this.element = A === "span" ? g(A) : Z.createElementNS(this.SVG_NS, A), this.renderer = d, P(this, "afterInit")
                    }
                    on(d, A) {
                        let {
                            onEvents: L
                        } = this;
                        return L[d] && L[d](), L[d] = M(this.element, d, A), this
                    }
                    opacitySetter(d, A, L) {
                        let V = Number(Number(d).toFixed(3));
                        this.opacity = V, L.setAttribute(A, V)
                    }
                    removeClass(d) {
                        return this.attr("class", ("" + this.attr("class")).replace(h(d) ? RegExp(`(^| )${d}( |$)`) : d, " ").replace(/ +/g, " ").trim())
                    }
                    removeTextOutline() {
                        let d = this.element.querySelector("tspan.highcharts-text-outline");
                        d && this.safeRemoveChild(d)
                    }
                    safeRemoveChild(d) {
                        let A = d.parentNode;
                        A && A.removeChild(d)
                    }
                    setRadialReference(d) {
                        let A = this.element.gradient && this.renderer.gradients[this.element.gradient];
                        return this.element.radialReference = d, A && A.radAttr && A.animate(this.renderer.getRadialAttr(d, A.radAttr)), this
                    }
                    setTextPath(d, A) {
                        A = u(!0, {
                            enabled: !0,
                            attributes: {
                                dy: -5,
                                startOffset: "50%",
                                textAnchor: "middle"
                            }
                        }, A);
                        let L = this.renderer.url,
                            V = this.text || this,
                            B = V.textPath,
                            {
                                attributes: r,
                                enabled: c
                            } = A;
                        if (d = d || B && B.path, B && B.undo(), d && c) {
                            let b = M(V, "afterModifyTree", N => {
                                if (d && c) {
                                    let z = d.attr("id");
                                    z || d.attr("id", z = p());
                                    let W = {
                                        x: 0,
                                        y: 0
                                    };
                                    m(r.dx) && (W.dx = r.dx, delete r.dx), m(r.dy) && (W.dy = r.dy, delete r.dy), V.attr(W), this.attr({
                                        transform: ""
                                    }), this.box && (this.box = this.box.destroy());
                                    let a = N.nodes.slice(0);
                                    N.nodes.length = 0, N.nodes[0] = {
                                        tagName: "textPath",
                                        attributes: T(r, {
                                            "text-anchor": r.textAnchor,
                                            href: `${L}#${z}`
                                        }),
                                        children: a
                                    }
                                }
                            });
                            V.textPath = {
                                path: d,
                                undo: b
                            }
                        } else V.attr({
                            dx: 0,
                            dy: 0
                        }), delete V.textPath;
                        return this.added && (V.textCache = "", this.renderer.buildText(V)), this
                    }
                    shadow(d) {
                        var B;
                        let {
                            renderer: A
                        } = this, L = u(((B = this.parentGroup) == null ? void 0 : B.rotation) === 90 ? {
                            offsetX: -1,
                            offsetY: -1
                        } : {}, n(d) ? d : {}), V = A.shadowDefinition(L);
                        return this.attr({
                            filter: d ? `url(${A.url}#${V})` : "none"
                        })
                    }
                    show(d = !0) {
                        return this.attr({
                            visibility: d ? "inherit" : "visible"
                        })
                    }
                    "stroke-widthSetter"(d, A, L) {
                        this[A] = d, L.setAttribute(A, d)
                    }
                    strokeWidth() {
                        if (!this.renderer.styledMode) return this["stroke-width"] || 0;
                        let d = this.getStyle("stroke-width"),
                            A = 0,
                            L;
                        return d.indexOf("px") === d.length - 2 ? A = i(d) : d !== "" && (k(L = Z.createElementNS(R, "rect"), {
                            width: d,
                            "stroke-width": 0
                        }), this.element.parentNode.appendChild(L), A = L.getBBox().width, L.parentNode.removeChild(L)), A
                    }
                    symbolAttr(d) {
                        let A = this;
                        x.symbolCustomAttribs.forEach(function(L) {
                            A[L] = t(d[L], A[L])
                        }), A.attr({
                            d: A.renderer.symbols[A.symbolName](A.x, A.y, A.width, A.height, A)
                        })
                    }
                    textSetter(d) {
                        d !== this.textStr && (delete this.textPxLength, this.textStr = d, this.added && this.renderer.buildText(this))
                    }
                    titleSetter(d) {
                        let A = this.element,
                            L = A.getElementsByTagName("title")[0] || Z.createElementNS(this.SVG_NS, "title");
                        A.insertBefore ? A.insertBefore(L, A.firstChild) : A.appendChild(L), L.textContent = String(t(d, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">")
                    }
                    toFront() {
                        let d = this.element;
                        return d.parentNode.appendChild(d), this
                    }
                    translate(d, A) {
                        return this.attr({
                            translateX: d,
                            translateY: A
                        })
                    }
                    updateTransform() {
                        let {
                            element: d,
                            matrix: A,
                            rotation: L = 0,
                            scaleX: V,
                            scaleY: B,
                            translateX: r = 0,
                            translateY: c = 0
                        } = this, b = ["translate(" + r + "," + c + ")"];
                        m(A) && b.push("matrix(" + A.join(",") + ")"), L && b.push("rotate(" + L + " " + t(this.rotationOriginX, d.getAttribute("x"), 0) + " " + t(this.rotationOriginY, d.getAttribute("y") || 0) + ")"), (m(V) || m(B)) && b.push("scale(" + t(V, 1) + " " + t(B, 1) + ")"), b.length && !(this.text || this).textPath && d.setAttribute("transform", b.join(" "))
                    }
                    visibilitySetter(d, A, L) {
                        d === "inherit" ? L.removeAttribute(A) : this[A] !== d && L.setAttribute(A, d), this[A] = d
                    }
                    xGetter(d) {
                        return this.element.nodeName === "circle" && (d === "x" ? d = "cx" : d === "y" && (d = "cy")), this._defaultGetter(d)
                    }
                    zIndexSetter(d, A) {
                        let L = this.renderer,
                            V = this.parentGroup,
                            B = V || L,
                            r = B.element || L.box,
                            c = this.element,
                            b = r === L.box,
                            N, z, W, a = !1,
                            v, y = this.added,
                            I;
                        if (m(d) ? (c.setAttribute("data-z-index", d), d = +d, this[A] === d && (y = !1)) : m(this[A]) && c.removeAttribute("data-z-index"), this[A] = d, y) {
                            for ((d = this.zIndex) && V && (V.handleZ = !0), I = (N = r.childNodes).length - 1; I >= 0 && !a; I--) v = !m(W = (z = N[I]).getAttribute("data-z-index")), z !== c && (d < 0 && v && !b && !I ? (r.insertBefore(c, N[I]), a = !0) : (i(W) <= d || v && (!m(d) || d >= 0)) && (r.insertBefore(c, N[I + 1]), a = !0));
                            a || (r.insertBefore(c, N[b ? 3 : 0]), a = !0)
                        }
                        return a
                    }
                }
                return x.symbolCustomAttribs = ["anchorX", "anchorY", "clockwise", "end", "height", "innerR", "r", "start", "width", "x", "y"], x.prototype.strokeSetter = x.prototype.fillSetter, x.prototype.yGetter = x.prototype.xGetter, x.prototype.matrixSetter = x.prototype.rotationOriginXSetter = x.prototype.rotationOriginYSetter = x.prototype.rotationSetter = x.prototype.scaleXSetter = x.prototype.scaleYSetter = x.prototype.translateXSetter = x.prototype.translateYSetter = x.prototype.verticalAlignSetter = function(O, d) {
                    this[d] = O, this.doTransform = !0
                }, x
            }), ft(Y, "Core/Renderer/RendererRegistry.js", [Y["Core/Globals.js"]], function(et) {
                var Q, ht;
                let rt;
                return (ht = Q || (Q = {})).rendererTypes = {}, ht.getRendererType = function(it = rt) {
                    return ht.rendererTypes[it] || ht.rendererTypes[rt]
                }, ht.registerRendererType = function(it, nt, ot) {
                    ht.rendererTypes[it] = nt, (!rt || ot) && (rt = it, et.Renderer = nt)
                }, Q
            }), ft(Y, "Core/Renderer/SVG/SVGLabel.js", [Y["Core/Renderer/SVG/SVGElement.js"], Y["Core/Utilities.js"]], function(et, Q) {
                let {
                    defined: ht,
                    extend: rt,
                    isNumber: it,
                    merge: nt,
                    pick: ot,
                    removeEvent: K
                } = Q;
                class Z extends et {
                    constructor(S, R, E, M, k, g, f, m, C, T) {
                        let P;
                        super(), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.init(S, "g"), this.textStr = R, this.x = E, this.y = M, this.anchorX = g, this.anchorY = f, this.baseline = C, this.className = T, this.addClass(T === "button" ? "highcharts-no-tooltip" : "highcharts-label"), T && this.addClass("highcharts-" + T), this.text = S.text(void 0, 0, 0, m).attr({
                            zIndex: 1
                        }), typeof k == "string" && ((P = /^url\((.*?)\)$/.test(k)) || this.renderer.symbols[k]) && (this.symbolKey = k), this.bBox = Z.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = S.styledMode || P, this.deferredAttr = {}, this.alignFactor = 0
                    }
                    alignSetter(S) {
                        let R = {
                            left: 0,
                            center: .5,
                            right: 1
                        } [S];
                        R !== this.alignFactor && (this.alignFactor = R, this.bBox && it(this.xSetting) && this.attr({
                            x: this.xSetting
                        }))
                    }
                    anchorXSetter(S, R) {
                        this.anchorX = S, this.boxAttr(R, Math.round(S) - this.getCrispAdjust() - this.xSetting)
                    }
                    anchorYSetter(S, R) {
                        this.anchorY = S, this.boxAttr(R, S - this.ySetting)
                    }
                    boxAttr(S, R) {
                        this.box ? this.box.attr(S, R) : this.deferredAttr[S] = R
                    }
                    css(S) {
                        if (S) {
                            let R = {};
                            S = nt(S), Z.textProps.forEach(E => {
                                S[E] !== void 0 && (R[E] = S[E], delete S[E])
                            }), this.text.css(R), "fontSize" in R || "fontWeight" in R ? this.updateTextPadding() : ("width" in R || "textOverflow" in R) && this.updateBoxSize()
                        }
                        return et.prototype.css.call(this, S)
                    }
                    destroy() {
                        K(this.element, "mouseenter"), K(this.element, "mouseleave"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), et.prototype.destroy.call(this)
                    }
                    fillSetter(S, R) {
                        S && (this.needsBox = !0), this.fill = S, this.boxAttr(R, S)
                    }
                    getBBox() {
                        this.textStr && this.bBox.width === 0 && this.bBox.height === 0 && this.updateBoxSize();
                        let S = this.padding,
                            R = ot(this.paddingLeft, S);
                        return {
                            width: this.width || 0,
                            height: this.height || 0,
                            x: this.bBox.x - R,
                            y: this.bBox.y - S
                        }
                    }
                    getCrispAdjust() {
                        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2
                    }
                    heightSetter(S) {
                        this.heightSetting = S
                    }
                    onAdd() {
                        this.text.add(this), this.attr({
                            text: ot(this.textStr, ""),
                            x: this.x || 0,
                            y: this.y || 0
                        }), this.box && ht(this.anchorX) && this.attr({
                            anchorX: this.anchorX,
                            anchorY: this.anchorY
                        })
                    }
                    paddingSetter(S, R) {
                        it(S) ? S !== this[R] && (this[R] = S, this.updateTextPadding()) : this[R] = void 0
                    }
                    rSetter(S, R) {
                        this.boxAttr(R, S)
                    }
                    strokeSetter(S, R) {
                        this.stroke = S, this.boxAttr(R, S)
                    }
                    "stroke-widthSetter"(S, R) {
                        S && (this.needsBox = !0), this["stroke-width"] = S, this.boxAttr(R, S)
                    }
                    "text-alignSetter"(S) {
                        this.textAlign = S
                    }
                    textSetter(S) {
                        S !== void 0 && this.text.attr({
                            text: S
                        }), this.updateTextPadding()
                    }
                    updateBoxSize() {
                        let S, R = this.text,
                            E = {},
                            M = this.padding,
                            k = this.bBox = (!it(this.widthSetting) || !it(this.heightSetting) || this.textAlign) && ht(R.textStr) ? R.getBBox() : Z.emptyBBox;
                        this.width = this.getPaddedWidth(), this.height = (this.heightSetting || k.height || 0) + 2 * M;
                        let g = this.renderer.fontMetrics(R);
                        if (this.baselineOffset = M + Math.min((this.text.firstLineMetrics || g).b, k.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - g.h) / 2), this.needsBox && !R.textPath) {
                            if (!this.box) {
                                let f = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
                                f.addClass((this.className === "button" ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), f.add(this)
                            }
                            S = this.getCrispAdjust(), E.x = S, E.y = (this.baseline ? -this.baselineOffset : 0) + S, E.width = Math.round(this.width), E.height = Math.round(this.height), this.box.attr(rt(E, this.deferredAttr)), this.deferredAttr = {}
                        }
                    }
                    updateTextPadding() {
                        let S = this.text;
                        if (!S.textPath) {
                            this.updateBoxSize();
                            let R = this.baseline ? 0 : this.baselineOffset,
                                E = ot(this.paddingLeft, this.padding);
                            ht(this.widthSetting) && this.bBox && (this.textAlign === "center" || this.textAlign === "right") && (E += {
                                center: .5,
                                right: 1
                            } [this.textAlign] * (this.widthSetting - this.bBox.width)), (E !== S.x || R !== S.y) && (S.attr("x", E), S.hasBoxWidthChanged && (this.bBox = S.getBBox(!0)), R !== void 0 && S.attr("y", R)), S.x = E, S.y = R
                        }
                    }
                    widthSetter(S) {
                        this.widthSetting = it(S) ? S : void 0
                    }
                    getPaddedWidth() {
                        let S = this.padding,
                            R = ot(this.paddingLeft, S),
                            E = ot(this.paddingRight, S);
                        return (this.widthSetting || this.bBox.width || 0) + R + E
                    }
                    xSetter(S) {
                        this.x = S, this.alignFactor && (S -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0), this.xSetting = Math.round(S), this.attr("translateX", this.xSetting)
                    }
                    ySetter(S) {
                        this.ySetting = this.y = Math.round(S), this.attr("translateY", this.ySetting)
                    }
                }
                return Z.emptyBBox = {
                    width: 0,
                    height: 0,
                    x: 0,
                    y: 0
                }, Z.textProps = ["color", "direction", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "textAlign", "textDecoration", "textOutline", "textOverflow", "whiteSpace", "width"], Z
            }), ft(Y, "Core/Renderer/SVG/Symbols.js", [Y["Core/Utilities.js"]], function(et) {
                let {
                    defined: Q,
                    isNumber: ht,
                    pick: rt
                } = et;

                function it(K, Z, U, S, R) {
                    let E = [];
                    if (R) {
                        let M = R.start || 0,
                            k = rt(R.r, U),
                            g = rt(R.r, S || U),
                            f = .001 > Math.abs((R.end || 0) - M - 2 * Math.PI),
                            m = (R.end || 0) - .001,
                            C = R.innerR,
                            T = rt(R.open, f),
                            P = Math.cos(M),
                            o = Math.sin(M),
                            l = Math.cos(m),
                            n = Math.sin(m),
                            h = rt(R.longArc, m - M - Math.PI < .001 ? 0 : 1),
                            u = ["A", k, g, 0, h, rt(R.clockwise, 1), K + k * l, Z + g * n];
                        u.params = {
                            start: M,
                            end: m,
                            cx: K,
                            cy: Z
                        }, E.push(["M", K + k * P, Z + g * o], u), Q(C) && ((u = ["A", C, C, 0, h, Q(R.clockwise) ? 1 - R.clockwise : 0, K + C * P, Z + C * o]).params = {
                            start: m,
                            end: M,
                            cx: K,
                            cy: Z
                        }, E.push(T ? ["M", K + C * l, Z + C * n] : ["L", K + C * l, Z + C * n], u)), T || E.push(["Z"])
                    }
                    return E
                }

                function nt(K, Z, U, S, R) {
                    return R && R.r ? ot(K, Z, U, S, R) : [
                        ["M", K, Z],
                        ["L", K + U, Z],
                        ["L", K + U, Z + S],
                        ["L", K, Z + S],
                        ["Z"]
                    ]
                }

                function ot(K, Z, U, S, R) {
                    let E = (R == null ? void 0 : R.r) || 0;
                    return [
                        ["M", K + E, Z],
                        ["L", K + U - E, Z],
                        ["A", E, E, 0, 0, 1, K + U, Z + E],
                        ["L", K + U, Z + S - E],
                        ["A", E, E, 0, 0, 1, K + U - E, Z + S],
                        ["L", K + E, Z + S],
                        ["A", E, E, 0, 0, 1, K, Z + S - E],
                        ["L", K, Z + E],
                        ["A", E, E, 0, 0, 1, K + E, Z],
                        ["Z"]
                    ]
                }
                return {
                    arc: it,
                    callout: function(K, Z, U, S, R) {
                        let E = Math.min(R && R.r || 0, U, S),
                            M = E + 6,
                            k = R && R.anchorX,
                            g = R && R.anchorY || 0,
                            f = ot(K, Z, U, S, {
                                r: E
                            });
                        if (!ht(k) || k < U && k > 0 && g < S && g > 0) return f;
                        if (K + k > U - M)
                            if (g > Z + M && g < Z + S - M) f.splice(3, 1, ["L", K + U, g - 6], ["L", K + U + 6, g], ["L", K + U, g + 6], ["L", K + U, Z + S - E]);
                            else if (k < U) {
                                let m = g < Z + M,
                                    C = m ? Z : Z + S;
                                f.splice(m ? 2 : 5, 0, ["L", k, g], ["L", K + U - E, C])
                            } else f.splice(3, 1, ["L", K + U, S / 2], ["L", k, g], ["L", K + U, S / 2], ["L", K + U, Z + S - E]);
                        else if (K + k < M)
                            if (g > Z + M && g < Z + S - M) f.splice(7, 1, ["L", K, g + 6], ["L", K - 6, g], ["L", K, g - 6], ["L", K, Z + E]);
                            else if (k > 0) {
                                let m = g < Z + M,
                                    C = m ? Z : Z + S;
                                f.splice(m ? 1 : 6, 0, ["L", k, g], ["L", K + E, C])
                            } else f.splice(7, 1, ["L", K, S / 2], ["L", k, g], ["L", K, S / 2], ["L", K, Z + E]);
                        else g > S && k < U - M ? f.splice(5, 1, ["L", k + 6, Z + S], ["L", k, Z + S + 6], ["L", k - 6, Z + S], ["L", K + E, Z + S]) : g < 0 && k > M && f.splice(1, 1, ["L", k - 6, Z], ["L", k, Z - 6], ["L", k + 6, Z], ["L", U - E, Z]);
                        return f
                    },
                    circle: function(K, Z, U, S) {
                        return it(K + U / 2, Z + S / 2, U / 2, S / 2, {
                            start: .5 * Math.PI,
                            end: 2.5 * Math.PI,
                            open: !1
                        })
                    },
                    diamond: function(K, Z, U, S) {
                        return [
                            ["M", K + U / 2, Z],
                            ["L", K + U, Z + S / 2],
                            ["L", K + U / 2, Z + S],
                            ["L", K, Z + S / 2],
                            ["Z"]
                        ]
                    },
                    rect: nt,
                    roundedRect: ot,
                    square: nt,
                    triangle: function(K, Z, U, S) {
                        return [
                            ["M", K + U / 2, Z],
                            ["L", K + U, Z + S],
                            ["L", K, Z + S],
                            ["Z"]
                        ]
                    },
                    "triangle-down": function(K, Z, U, S) {
                        return [
                            ["M", K, Z],
                            ["L", K + U, Z],
                            ["L", K + U / 2, Z + S],
                            ["Z"]
                        ]
                    }
                }
            }), ft(Y, "Core/Renderer/SVG/TextBuilder.js", [Y["Core/Renderer/HTML/AST.js"], Y["Core/Globals.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                let {
                    doc: rt,
                    SVG_NS: it,
                    win: nt
                } = Q, {
                    attr: ot,
                    extend: K,
                    fireEvent: Z,
                    isString: U,
                    objectEach: S,
                    pick: R
                } = ht;
                return class {
                    constructor(E) {
                        let M = E.styles;
                        this.renderer = E.renderer, this.svgElement = E, this.width = E.textWidth, this.textLineHeight = M && M.lineHeight, this.textOutline = M && M.textOutline, this.ellipsis = !!(M && M.textOverflow === "ellipsis"), this.noWrap = !!(M && M.whiteSpace === "nowrap")
                    }
                    buildSVG() {
                        let E = this.svgElement,
                            M = E.element,
                            k = E.renderer,
                            g = R(E.textStr, "").toString(),
                            f = g.indexOf("<") !== -1,
                            m = M.childNodes,
                            C = !E.added && k.box,
                            T = [g, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, E.getStyle("font-size"), this.width].join(",");
                        if (T !== E.textCache) {
                            E.textCache = T, delete E.actualWidth;
                            for (let P = m.length; P--;) M.removeChild(m[P]);
                            if (f || this.ellipsis || this.width || E.textPath || g.indexOf(" ") !== -1 && (!this.noWrap || /<br.*?>/g.test(g))) {
                                if (g !== "") {
                                    C && C.appendChild(M);
                                    let P = new et(g);
                                    this.modifyTree(P.nodes), P.addToDOM(M), this.modifyDOM(), this.ellipsis && (M.textContent || "").indexOf("…") !== -1 && E.attr("title", this.unescapeEntities(E.textStr || "", ["&lt;", "&gt;"])), C && C.removeChild(M)
                                }
                            } else M.appendChild(rt.createTextNode(this.unescapeEntities(g)));
                            U(this.textOutline) && E.applyTextOutline && E.applyTextOutline(this.textOutline)
                        }
                    }
                    modifyDOM() {
                        let E, M = this.svgElement,
                            k = ot(M.element, "x");
                        for (M.firstLineMetrics = void 0;
                             (E = M.element.firstChild) && /^[\s\u200B]*$/.test(E.textContent || " ");) M.element.removeChild(E);
                        [].forEach.call(M.element.querySelectorAll("tspan.highcharts-br"), (C, T) => {
                            C.nextSibling && C.previousSibling && (T === 0 && C.previousSibling.nodeType === 1 && (M.firstLineMetrics = M.renderer.fontMetrics(C.previousSibling)), ot(C, {
                                dy: this.getLineHeight(C.nextSibling),
                                x: k
                            }))
                        });
                        let g = this.width || 0;
                        if (!g) return;
                        let f = (C, T) => {
                                let P = C.textContent || "",
                                    o = P.replace(/([^\^])-/g, "$1- ").split(" "),
                                    l = !this.noWrap && (o.length > 1 || M.element.childNodes.length > 1),
                                    n = this.getLineHeight(T),
                                    h = 0,
                                    u = M.actualWidth;
                                if (this.ellipsis) P && this.truncate(C, P, void 0, 0, Math.max(0, g - .8 * n), (e, t) => e.substring(0, t) + "…");
                                else if (l) {
                                    let e = [],
                                        t = [];
                                    for (; T.firstChild && T.firstChild !== C;) t.push(T.firstChild), T.removeChild(T.firstChild);
                                    for (; o.length;) o.length && !this.noWrap && h > 0 && (e.push(C.textContent || ""), C.textContent = o.join(" ").replace(/- /g, "-")), this.truncate(C, void 0, o, h === 0 && u || 0, g, (i, s) => o.slice(0, s).join(" ").replace(/- /g, "-")), u = M.actualWidth, h++;
                                    t.forEach(i => {
                                        T.insertBefore(i, C)
                                    }), e.forEach(i => {
                                        T.insertBefore(rt.createTextNode(i), C);
                                        let s = rt.createElementNS(it, "tspan");
                                        s.textContent = "​", ot(s, {
                                            dy: n,
                                            x: k
                                        }), T.insertBefore(s, C)
                                    })
                                }
                            },
                            m = C => {
                                [].slice.call(C.childNodes).forEach(P => {
                                    P.nodeType === nt.Node.TEXT_NODE ? f(P, C) : (P.className.baseVal.indexOf("highcharts-br") !== -1 && (M.actualWidth = 0), m(P))
                                })
                            };
                        m(M.element)
                    }
                    getLineHeight(E) {
                        let M = E.nodeType === nt.Node.TEXT_NODE ? E.parentElement : E;
                        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(M || this.svgElement.element).h
                    }
                    modifyTree(E) {
                        let M = (k, g) => {
                            let {
                                attributes: f = {},
                                children: m,
                                style: C = {},
                                tagName: T
                            } = k, P = this.renderer.styledMode;
                            if (T === "b" || T === "strong" ? P ? f.class = "highcharts-strong" : C.fontWeight = "bold" : (T === "i" || T === "em") && (P ? f.class = "highcharts-emphasized" : C.fontStyle = "italic"), C && C.color && (C.fill = C.color), T === "br") {
                                f.class = "highcharts-br", k.textContent = "​";
                                let o = E[g + 1];
                                o && o.textContent && (o.textContent = o.textContent.replace(/^ +/gm, ""))
                            } else T === "a" && m && m.some(o => o.tagName === "#text") && (k.children = [{
                                children: m,
                                tagName: "tspan"
                            }]);
                            T !== "#text" && T !== "a" && (k.tagName = "tspan"), K(k, {
                                attributes: f,
                                style: C
                            }), m && m.filter(o => o.tagName !== "#text").forEach(M)
                        };
                        E.forEach(M), Z(this.svgElement, "afterModifyTree", {
                            nodes: E
                        })
                    }
                    truncate(E, M, k, g, f, m) {
                        let C, T, P = this.svgElement,
                            {
                                renderer: o,
                                rotation: l
                            } = P,
                            n = [],
                            h = k ? 1 : 0,
                            u = (M || k || "").length,
                            e = u,
                            t = function(i, s) {
                                let p = s || i,
                                    x = E.parentNode;
                                if (x && n[p] === void 0 && x.getSubStringLength) try {
                                    n[p] = g + x.getSubStringLength(0, k ? p + 1 : p)
                                } catch {}
                                return n[p]
                            };
                        if (P.rotation = 0, g + (T = t(E.textContent.length)) > f) {
                            for (; h <= u;) e = Math.ceil((h + u) / 2), k && (C = m(k, e)), T = t(e, C && C.length - 1), h === u ? h = u + 1 : T > f ? u = e - 1 : h = e;
                            u === 0 ? E.textContent = "" : M && u === M.length - 1 || (E.textContent = C || m(M || k, e))
                        }
                        k && k.splice(0, e), P.actualWidth = T, P.rotation = l
                    }
                    unescapeEntities(E, M) {
                        return S(this.renderer.escapes, function(k, g) {
                            M && M.indexOf(k) !== -1 || (E = E.toString().replace(RegExp(k, "g"), g))
                        }), E
                    }
                }
            }), ft(Y, "Core/Renderer/SVG/SVGRenderer.js", [Y["Core/Renderer/HTML/AST.js"], Y["Core/Color/Color.js"], Y["Core/Globals.js"], Y["Core/Renderer/RendererRegistry.js"], Y["Core/Renderer/SVG/SVGElement.js"], Y["Core/Renderer/SVG/SVGLabel.js"], Y["Core/Renderer/SVG/Symbols.js"], Y["Core/Renderer/SVG/TextBuilder.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt, it, nt, ot, K, Z) {
                let U, {
                        charts: S,
                        deg2rad: R,
                        doc: E,
                        isFirefox: M,
                        isMS: k,
                        isWebKit: g,
                        noop: f,
                        SVG_NS: m,
                        symbolSizes: C,
                        win: T
                    } = ht,
                    {
                        addEvent: P,
                        attr: o,
                        createElement: l,
                        css: n,
                        defined: h,
                        destroyObjectProperties: u,
                        extend: e,
                        isArray: t,
                        isNumber: i,
                        isObject: s,
                        isString: p,
                        merge: x,
                        pick: O,
                        pInt: d,
                        uniqueKey: A
                    } = Z;
                class L {
                    constructor(B, r, c, b, N, z, W) {
                        this.alignedObjects = void 0, this.box = void 0, this.boxWrapper = void 0, this.cache = void 0, this.cacheKeys = void 0, this.chartIndex = void 0, this.defs = void 0, this.globalAnimation = void 0, this.gradients = void 0, this.height = void 0, this.imgCount = void 0, this.style = void 0, this.url = void 0, this.width = void 0, this.init(B, r, c, b, N, z, W)
                    }
                    init(B, r, c, b, N, z, W) {
                        let a, v, y = this.createElement("svg").attr({
                                version: "1.1",
                                class: "highcharts-root"
                            }),
                            I = y.element;
                        W || y.css(this.getStyle(b)), B.appendChild(I), o(B, "dir", "ltr"), B.innerHTML.indexOf("xmlns") === -1 && o(I, "xmlns", this.SVG_NS), this.box = I, this.boxWrapper = y, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement("desc").add().element.appendChild(E.createTextNode("Created with Highcharts 11.2.0")), this.defs = this.createElement("defs").add(), this.allowHTML = z, this.forExport = N, this.styledMode = W, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = y.getStyle("font-size"), this.setSize(r, c, !1), M && B.getBoundingClientRect && ((a = function() {
                            n(B, {
                                left: 0,
                                top: 0
                            }), v = B.getBoundingClientRect(), n(B, {
                                left: Math.ceil(v.left) - v.left + "px",
                                top: Math.ceil(v.top) - v.top + "px"
                            })
                        })(), this.unSubPixelFix = P(T, "resize", a))
                    }
                    definition(B) {
                        return new et([B]).addToDOM(this.defs.element)
                    }
                    getReferenceURL() {
                        if ((M || g) && E.getElementsByTagName("base").length) {
                            if (!h(U)) {
                                let B = A(),
                                    r = new et([{
                                        tagName: "svg",
                                        attributes: {
                                            width: 8,
                                            height: 8
                                        },
                                        children: [{
                                            tagName: "defs",
                                            children: [{
                                                tagName: "clipPath",
                                                attributes: {
                                                    id: B
                                                },
                                                children: [{
                                                    tagName: "rect",
                                                    attributes: {
                                                        width: 4,
                                                        height: 4
                                                    }
                                                }]
                                            }]
                                        }, {
                                            tagName: "rect",
                                            attributes: {
                                                id: "hitme",
                                                width: 8,
                                                height: 8,
                                                "clip-path": `url(#${B})`,
                                                fill: "rgba(0,0,0,0.001)"
                                            }
                                        }]
                                    }]),
                                    c = r.addToDOM(E.body);
                                n(c, {
                                    position: "fixed",
                                    top: 0,
                                    left: 0,
                                    zIndex: 9e5
                                });
                                let b = E.elementFromPoint(6, 6);
                                U = (b && b.id) === "hitme", E.body.removeChild(c)
                            }
                            if (U) return T.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20")
                        }
                        return ""
                    }
                    getStyle(B) {
                        return this.style = e({
                            fontFamily: "Helvetica, Arial, sans-serif",
                            fontSize: "1rem"
                        }, B), this.style
                    }
                    setStyle(B) {
                        this.boxWrapper.css(this.getStyle(B))
                    }
                    isHidden() {
                        return !this.boxWrapper.getBBox().width
                    }
                    destroy() {
                        let B = this.defs;
                        return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), u(this.gradients || {}), this.gradients = null, this.defs = B.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null
                    }
                    createElement(B) {
                        let r = new this.Element;
                        return r.init(this, B), r
                    }
                    getRadialAttr(B, r) {
                        return {
                            cx: B[0] - B[2] / 2 + (r.cx || 0) * B[2],
                            cy: B[1] - B[2] / 2 + (r.cy || 0) * B[2],
                            r: (r.r || 0) * B[2]
                        }
                    }
                    shadowDefinition(B) {
                        let r = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(B).map(b => `${b}-${B[b]}`)].join("-").toLowerCase().replace(/[^a-z0-9\-]/g, ""),
                            c = x({
                                color: "#000000",
                                offsetX: 1,
                                offsetY: 1,
                                opacity: .15,
                                width: 5
                            }, B);
                        return this.defs.element.querySelector(`#${r}`) || this.definition({
                            tagName: "filter",
                            attributes: {
                                id: r,
                                filterUnits: c.filterUnits
                            },
                            children: [{
                                tagName: "feDropShadow",
                                attributes: {
                                    dx: c.offsetX,
                                    dy: c.offsetY,
                                    "flood-color": c.color,
                                    "flood-opacity": Math.min(5 * c.opacity, 1),
                                    stdDeviation: c.width / 2
                                }
                            }]
                        }), r
                    }
                    buildText(B) {
                        new K(B).buildSVG()
                    }
                    getContrast(B) {
                        let r = Q.parse(B).rgba.map(b => {
                                let N = b / 255;
                                return N <= .03928 ? N / 12.92 : Math.pow((N + .055) / 1.055, 2.4)
                            }),
                            c = .2126 * r[0] + .7152 * r[1] + .0722 * r[2];
                        return 1.05 / (c + .05) > (c + .05) / .05 ? "#FFFFFF" : "#000000"
                    }
                    button(B, r, c, b, N = {}, z, W, a, v, y) {
                        let I, w, G, X = this.label(B, r, c, v, void 0, void 0, y, void 0, "button"),
                            _ = this.styledMode,
                            $ = N.states || {},
                            st = 0;
                        N = x(N), delete N.states;
                        let D = x({
                            color: "#333333",
                            cursor: "pointer",
                            fontSize: "0.8em",
                            fontWeight: "normal"
                        }, N.style);
                        delete N.style;
                        let j = et.filterUserAttributes(N);
                        return X.attr(x({
                            padding: 8,
                            r: 2
                        }, j)), _ || (j = x({
                            fill: "#f7f7f7",
                            stroke: "#cccccc",
                            "stroke-width": 1
                        }, j), I = (z = x(j, {
                            fill: "#e6e6e6"
                        }, et.filterUserAttributes(z || $.hover || {}))).style, delete z.style, w = (W = x(j, {
                            fill: "#e6e9ff",
                            style: {
                                color: "#000000",
                                fontWeight: "bold"
                            }
                        }, et.filterUserAttributes(W || $.select || {}))).style, delete W.style, G = (a = x(j, {
                            style: {
                                color: "#cccccc"
                            }
                        }, et.filterUserAttributes(a || $.disabled || {}))).style, delete a.style), P(X.element, k ? "mouseover" : "mouseenter", function() {
                            st !== 3 && X.setState(1)
                        }), P(X.element, k ? "mouseout" : "mouseleave", function() {
                            st !== 3 && X.setState(st)
                        }), X.setState = function(F) {
                            if (F !== 1 && (X.state = st = F), X.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][F || 0]), !_) {
                                X.attr([j, z, W, a][F || 0]);
                                let H = [D, I, w, G][F || 0];
                                s(H) && X.css(H)
                            }
                        }, !_ && (X.attr(j).css(e({
                            cursor: "default"
                        }, D)), y && X.text.css({
                            pointerEvents: "none"
                        })), X.on("touchstart", F => F.stopPropagation()).on("click", function(F) {
                            st !== 3 && b.call(X, F)
                        })
                    }
                    crispLine(B, r, c = "round") {
                        let b = B[0],
                            N = B[1];
                        return h(b[1]) && b[1] === N[1] && (b[1] = N[1] = Math[c](b[1]) - r % 2 / 2), h(b[2]) && b[2] === N[2] && (b[2] = N[2] = Math[c](b[2]) + r % 2 / 2), B
                    }
                    path(B) {
                        let r = this.styledMode ? {} : {
                            fill: "none"
                        };
                        return t(B) ? r.d = B : s(B) && e(r, B), this.createElement("path").attr(r)
                    }
                    circle(B, r, c) {
                        let b = s(B) ? B : B === void 0 ? {} : {
                                x: B,
                                y: r,
                                r: c
                            },
                            N = this.createElement("circle");
                        return N.xSetter = N.ySetter = function(z, W, a) {
                            a.setAttribute("c" + W, z)
                        }, N.attr(b)
                    }
                    arc(B, r, c, b, N, z) {
                        let W;
                        s(B) ? (r = (W = B).y, c = W.r, b = W.innerR, N = W.start, z = W.end, B = W.x) : W = {
                            innerR: b,
                            start: N,
                            end: z
                        };
                        let a = this.symbol("arc", B, r, c, c, W);
                        return a.r = c, a
                    }
                    rect(B, r, c, b, N, z) {
                        let W = s(B) ? B : B === void 0 ? {} : {
                                x: B,
                                y: r,
                                r: N,
                                width: Math.max(c || 0, 0),
                                height: Math.max(b || 0, 0)
                            },
                            a = this.createElement("rect");
                        return this.styledMode || (z !== void 0 && (W["stroke-width"] = z, e(W, a.crisp(W))), W.fill = "none"), a.rSetter = function(v, y, I) {
                            a.r = v, o(I, {
                                rx: v,
                                ry: v
                            })
                        }, a.rGetter = function() {
                            return a.r || 0
                        }, a.attr(W)
                    }
                    roundedRect(B) {
                        return this.symbol("roundedRect").attr(B)
                    }
                    setSize(B, r, c) {
                        this.width = B, this.height = r, this.boxWrapper.animate({
                            width: B,
                            height: r
                        }, {
                            step: function() {
                                this.attr({
                                    viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                                })
                            },
                            duration: O(c, !0) ? void 0 : 0
                        }), this.alignElements()
                    }
                    g(B) {
                        let r = this.createElement("g");
                        return B ? r.attr({
                            class: "highcharts-" + B
                        }) : r
                    }
                    image(B, r, c, b, N, z) {
                        let W = {
                            preserveAspectRatio: "none"
                        };
                        i(r) && (W.x = r), i(c) && (W.y = c), i(b) && (W.width = b), i(N) && (W.height = N);
                        let a = this.createElement("image").attr(W),
                            v = function(y) {
                                a.attr({
                                    href: B
                                }), z.call(a, y)
                            };
                        if (z) {
                            a.attr({
                                href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
                            });
                            let y = new T.Image;
                            P(y, "load", v), y.src = B, y.complete && v({})
                        } else a.attr({
                            href: B
                        });
                        return a
                    }
                    symbol(B, r, c, b, N, z) {
                        let W, a, v, y, I = this,
                            w = /^url\((.*?)\)$/,
                            G = w.test(B),
                            X = !G && (this.symbols[B] ? B : "circle"),
                            _ = X && this.symbols[X];
                        if (_) typeof r == "number" && (a = _.call(this.symbols, Math.round(r || 0), Math.round(c || 0), b || 0, N || 0, z)), W = this.path(a), I.styledMode || W.attr("fill", "none"), e(W, {
                            symbolName: X || void 0,
                            x: r,
                            y: c,
                            width: b,
                            height: N
                        }), z && e(W, z);
                        else if (G) {
                            v = B.match(w)[1];
                            let $ = W = this.image(v);
                            $.imgwidth = O(z && z.width, C[v] && C[v].width), $.imgheight = O(z && z.height, C[v] && C[v].height), y = st => st.attr({
                                width: st.width,
                                height: st.height
                            }), ["width", "height"].forEach(st => {
                                $[`${st}Setter`] = function(D, j) {
                                    this[j] = D;
                                    let {
                                        alignByTranslate: F,
                                        element: H,
                                        width: q,
                                        height: J,
                                        imgwidth: at,
                                        imgheight: tt
                                    } = this, dt = j === "width" ? at : tt, pt = 1;
                                    z && z.backgroundSize === "within" && q && J && at && tt ? (pt = Math.min(q / at, J / tt), o(H, {
                                        width: Math.round(at * pt),
                                        height: Math.round(tt * pt)
                                    })) : H && dt && H.setAttribute(j, dt), !F && at && tt && this.translate(((q || 0) - at * pt) / 2, ((J || 0) - tt * pt) / 2)
                                }
                            }), h(r) && $.attr({
                                x: r,
                                y: c
                            }), $.isImg = !0, h($.imgwidth) && h($.imgheight) ? y($) : ($.attr({
                                width: 0,
                                height: 0
                            }), l("img", {
                                onload: function() {
                                    let st = S[I.chartIndex];
                                    this.width === 0 && (n(this, {
                                        position: "absolute",
                                        top: "-999em"
                                    }), E.body.appendChild(this)), C[v] = {
                                        width: this.width,
                                        height: this.height
                                    }, $.imgwidth = this.width, $.imgheight = this.height, $.element && y($), this.parentNode && this.parentNode.removeChild(this), I.imgCount--, I.imgCount || !st || st.hasLoaded || st.onload()
                                },
                                src: v
                            }), this.imgCount++)
                        }
                        return W
                    }
                    clipRect(B, r, c, b) {
                        let N = A() + "-",
                            z = this.createElement("clipPath").attr({
                                id: N
                            }).add(this.defs),
                            W = this.rect(B, r, c, b, 0).add(z);
                        return W.id = N, W.clipPath = z, W.count = 0, W
                    }
                    text(B, r, c, b) {
                        let N = {};
                        if (b && (this.allowHTML || !this.forExport)) return this.html(B, r, c);
                        N.x = Math.round(r || 0), c && (N.y = Math.round(c)), h(B) && (N.text = B);
                        let z = this.createElement("text").attr(N);
                        return b && (!this.forExport || this.allowHTML) || (z.xSetter = function(W, a, v) {
                            let y = v.getElementsByTagName("tspan"),
                                I = v.getAttribute(a);
                            for (let w = 0, G; w < y.length; w++)(G = y[w]).getAttribute(a) === I && G.setAttribute(a, W);
                            v.setAttribute(a, W)
                        }), z
                    }
                    fontMetrics(B) {
                        let r = d(it.prototype.getStyle.call(B, "font-size") || 0),
                            c = r < 24 ? r + 3 : Math.round(1.2 * r),
                            b = Math.round(.8 * c);
                        return {
                            h: c,
                            b,
                            f: r
                        }
                    }
                    rotCorr(B, r, c) {
                        let b = B;
                        return r && c && (b = Math.max(b * Math.cos(r * R), 4)), {
                            x: -B / 3 * Math.sin(r * R),
                            y: b
                        }
                    }
                    pathToSegments(B) {
                        let r = [],
                            c = [],
                            b = {
                                A: 8,
                                C: 7,
                                H: 2,
                                L: 3,
                                M: 3,
                                Q: 5,
                                S: 5,
                                T: 3,
                                V: 2
                            };
                        for (let N = 0; N < B.length; N++) p(c[0]) && i(B[N]) && c.length === b[c[0].toUpperCase()] && B.splice(N, 0, c[0].replace("M", "L").replace("m", "l")), typeof B[N] == "string" && (c.length && r.push(c.slice(0)), c.length = 0), c.push(B[N]);
                        return r.push(c.slice(0)), r
                    }
                    label(B, r, c, b, N, z, W, a, v) {
                        return new nt(this, B, r, c, b, N, z, W, a, v)
                    }
                    alignElements() {
                        this.alignedObjects.forEach(B => B.align())
                    }
                }
                return e(L.prototype, {
                    Element: it,
                    SVG_NS: m,
                    escapes: {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        "'": "&#39;",
                        '"': "&quot;"
                    },
                    symbols: ot,
                    draw: f
                }), rt.registerRendererType("svg", L, !0), L
            }), ft(Y, "Core/Renderer/HTML/HTMLElement.js", [Y["Core/Globals.js"], Y["Core/Renderer/SVG/SVGElement.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                let {
                    isFirefox: rt,
                    isMS: it,
                    isWebKit: nt,
                    win: ot
                } = et, {
                    css: K,
                    defined: Z,
                    extend: U,
                    pick: S,
                    pInt: R
                } = ht, E = [];
                class M extends Q {
                    static compose(g) {
                        if (ht.pushUnique(E, g)) {
                            let f = M.prototype,
                                m = g.prototype;
                            m.getSpanCorrection = f.getSpanCorrection, m.htmlCss = f.htmlCss, m.htmlGetBBox = f.htmlGetBBox, m.htmlUpdateTransform = f.htmlUpdateTransform, m.setSpanRotation = f.setSpanRotation
                        }
                        return g
                    }
                    getSpanCorrection(g, f, m) {
                        this.xCorr = -g * m, this.yCorr = -f
                    }
                    htmlCss(g) {
                        let f, m = this.element,
                            C = m.tagName === "SPAN" && g && "width" in g,
                            T = S(C && g.width, void 0);
                        return C && (delete g.width, this.textWidth = T, f = !0), g && g.textOverflow === "ellipsis" && (g.whiteSpace = "nowrap", g.overflow = "hidden"), this.styles = U(this.styles, g), K(this.element, g), f && this.htmlUpdateTransform(), this
                    }
                    htmlGetBBox() {
                        let g = this.element;
                        return {
                            x: g.offsetLeft,
                            y: g.offsetTop,
                            width: g.offsetWidth,
                            height: g.offsetHeight
                        }
                    }
                    htmlUpdateTransform() {
                        if (!this.added) {
                            this.alignOnAdd = !0;
                            return
                        }
                        let g = this.renderer,
                            f = this.element,
                            m = this.translateX || 0,
                            C = this.translateY || 0,
                            T = this.x || 0,
                            P = this.y || 0,
                            o = this.textAlign || "left",
                            l = {
                                left: 0,
                                center: .5,
                                right: 1
                            } [o],
                            n = this.styles,
                            h = n && n.whiteSpace;
                        if (K(f, {
                            marginLeft: m,
                            marginTop: C
                        }), f.tagName === "SPAN") {
                            let u = this.rotation,
                                e = this.textWidth && R(this.textWidth),
                                t = [u, o, f.innerHTML, this.textWidth, this.textAlign].join(","),
                                i, s = !1;
                            if (e !== this.oldTextWidth) {
                                let p = this.textPxLength ? this.textPxLength : (K(f, {
                                    width: "",
                                    whiteSpace: h || "nowrap"
                                }), f.offsetWidth);
                                (e > this.oldTextWidth || p > e) && (/[ \-]/.test(f.textContent || f.innerText) || f.style.textOverflow === "ellipsis") && (K(f, {
                                    width: p > e || u ? e + "px" : "auto",
                                    display: "block",
                                    whiteSpace: h || "normal"
                                }), this.oldTextWidth = e, s = !0)
                            }
                            this.hasBoxWidthChanged = s, t !== this.cTT && (i = g.fontMetrics(f).b, Z(u) && (u !== (this.oldRotation || 0) || o !== this.oldAlign) && this.setSpanRotation(u, l, i), this.getSpanCorrection(!Z(u) && this.textPxLength || f.offsetWidth, i, l, u, o)), K(f, {
                                left: T + (this.xCorr || 0) + "px",
                                top: P + (this.yCorr || 0) + "px"
                            }), this.cTT = t, this.oldRotation = u, this.oldAlign = o
                        }
                    }
                    setSpanRotation(g, f, m) {
                        let C = {},
                            T = it && !/Edge/.test(ot.navigator.userAgent) ? "-ms-transform" : nt ? "-webkit-transform" : rt ? "MozTransform" : ot.opera ? "-o-transform" : void 0;
                        T && (C[T] = C.transform = "rotate(" + g + "deg)", C[T + (rt ? "Origin" : "-origin")] = C.transformOrigin = 100 * f + "% " + m + "px", K(this.element, C))
                    }
                }
                return M
            }), ft(Y, "Core/Renderer/HTML/HTMLRenderer.js", [Y["Core/Renderer/HTML/AST.js"], Y["Core/Renderer/SVG/SVGElement.js"], Y["Core/Renderer/SVG/SVGRenderer.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt) {
                let {
                    attr: it,
                    createElement: nt,
                    extend: ot,
                    pick: K
                } = rt, Z = [];
                class U extends ht {
                    static compose(R) {
                        if (rt.pushUnique(Z, R)) {
                            let E = U.prototype,
                                M = R.prototype;
                            M.html = E.html
                        }
                        return R
                    }
                    html(R, E, M) {
                        let k = this.createElement("span"),
                            g = k.element,
                            f = k.renderer,
                            m = function(C, T) {
                                ["opacity", "visibility"].forEach(function(P) {
                                    C[P + "Setter"] = function(o, l, n) {
                                        let h = C.div ? C.div.style : T;
                                        Q.prototype[P + "Setter"].call(this, o, l, n), h && (h[l] = o)
                                    }
                                }), C.addedSetters = !0
                            };
                        return k.textSetter = function(C) {
                            C !== this.textStr && (delete this.bBox, delete this.oldTextWidth, et.setElementHTML(this.element, K(C, "")), this.textStr = C, k.doTransform = !0)
                        }, m(k, k.element.style), k.xSetter = k.ySetter = k.alignSetter = k.rotationSetter = function(C, T) {
                            T === "align" ? k.alignValue = k.textAlign = C : k[T] = C, k.doTransform = !0
                        }, k.afterSetters = function() {
                            this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1)
                        }, k.attr({
                            text: R,
                            x: Math.round(E),
                            y: Math.round(M)
                        }).css({
                            position: "absolute"
                        }), f.styledMode || k.css({
                            fontFamily: this.style.fontFamily,
                            fontSize: this.style.fontSize
                        }), g.style.whiteSpace = "nowrap", k.css = k.htmlCss, k.add = function(C) {
                            let T, P, o = f.box.parentNode,
                                l = [];
                            if (this.parentGroup = C, C) {
                                if (!(T = C.div)) {
                                    for (P = C; P;) l.push(P), P = P.parentGroup;
                                    l.reverse().forEach(function(n) {
                                        var h;
                                        let u = it(n.element, "class"),
                                            e = n.css;

                                        function t(p, x) {
                                            n[x] = p, x === "translateX" ? s.left = p + "px" : s.top = p + "px", n.doTransform = !0
                                        }
                                        let i = n.styles || {};
                                        T = n.div = n.div || nt("div", u ? {
                                            className: u
                                        } : void 0, {
                                            position: "absolute",
                                            left: (n.translateX || 0) + "px",
                                            top: (n.translateY || 0) + "px",
                                            display: n.display,
                                            opacity: n.opacity,
                                            visibility: n.visibility
                                        }, T || o);
                                        let s = T.style;
                                        ot(n, {
                                            classSetter: (h = T, function(p) {
                                                this.element.setAttribute("class", p), h.className = p
                                            }),
                                            css: function(p) {
                                                return e.call(n, p), ["cursor", "pointerEvents"].forEach(x => {
                                                    p[x] && (s[x] = p[x])
                                                }), n
                                            },
                                            on: function() {
                                                return l[0].div && k.on.apply({
                                                    element: l[0].div,
                                                    onEvents: n.onEvents
                                                }, arguments), n
                                            },
                                            translateXSetter: t,
                                            translateYSetter: t
                                        }), n.addedSetters || m(n), n.css(i)
                                    })
                                }
                            } else T = o;
                            return T.appendChild(g), k.added = !0, k.alignOnAdd && k.htmlUpdateTransform(), k
                        }, k
                    }
                }
                return U
            }), ft(Y, "Core/Axis/AxisDefaults.js", [], function() {
                var et, Q;
                return (Q = et || (et = {})).defaultXAxisOptions = {
                    alignTicks: !0,
                    allowDecimals: void 0,
                    panningEnabled: !0,
                    zIndex: 2,
                    zoomEnabled: !0,
                    dateTimeLabelFormats: {
                        millisecond: {
                            main: "%H:%M:%S.%L",
                            range: !1
                        },
                        second: {
                            main: "%H:%M:%S",
                            range: !1
                        },
                        minute: {
                            main: "%H:%M",
                            range: !1
                        },
                        hour: {
                            main: "%H:%M",
                            range: !1
                        },
                        day: {
                            main: "%e %b"
                        },
                        week: {
                            main: "%e %b"
                        },
                        month: {
                            main: "%b '%y"
                        },
                        year: {
                            main: "%Y"
                        }
                    },
                    endOnTick: !1,
                    gridLineDashStyle: "Solid",
                    gridZIndex: 1,
                    labels: {
                        autoRotation: void 0,
                        autoRotationLimit: 80,
                        distance: 15,
                        enabled: !0,
                        indentation: 10,
                        overflow: "justify",
                        padding: 5,
                        reserveSpace: void 0,
                        rotation: void 0,
                        staggerLines: 0,
                        step: 0,
                        useHTML: !1,
                        zIndex: 7,
                        style: {
                            color: "#333333",
                            cursor: "default",
                            fontSize: "0.8em"
                        }
                    },
                    maxPadding: .01,
                    minorGridLineDashStyle: "Solid",
                    minorTickLength: 2,
                    minorTickPosition: "outside",
                    minorTicksPerMajor: 5,
                    minPadding: .01,
                    offset: void 0,
                    opposite: !1,
                    reversed: void 0,
                    reversedStacks: !1,
                    showEmpty: !0,
                    showFirstLabel: !0,
                    showLastLabel: !0,
                    startOfWeek: 1,
                    startOnTick: !1,
                    tickLength: 10,
                    tickPixelInterval: 100,
                    tickmarkPlacement: "between",
                    tickPosition: "outside",
                    title: {
                        align: "middle",
                        rotation: 0,
                        useHTML: !1,
                        x: 0,
                        y: 0,
                        style: {
                            color: "#666666",
                            fontSize: "0.8em"
                        }
                    },
                    type: "linear",
                    uniqueNames: !0,
                    visible: !0,
                    minorGridLineColor: "#f2f2f2",
                    minorGridLineWidth: 1,
                    minorTickColor: "#999999",
                    lineColor: "#333333",
                    lineWidth: 1,
                    gridLineColor: "#e6e6e6",
                    gridLineWidth: void 0,
                    tickColor: "#333333"
                }, Q.defaultYAxisOptions = {
                    reversedStacks: !0,
                    endOnTick: !0,
                    maxPadding: .05,
                    minPadding: .05,
                    tickPixelInterval: 72,
                    showLastLabel: !0,
                    labels: {
                        x: void 0
                    },
                    startOnTick: !0,
                    title: {
                        rotation: 270,
                        text: "Values"
                    },
                    stackLabels: {
                        animation: {},
                        allowOverlap: !1,
                        enabled: !1,
                        crop: !0,
                        overflow: "justify",
                        formatter: function() {
                            let {
                                numberFormatter: ht
                            } = this.axis.chart;
                            return ht(this.total || 0, -1)
                        },
                        style: {
                            color: "#000000",
                            fontSize: "0.7em",
                            fontWeight: "bold",
                            textOutline: "1px contrast"
                        }
                    },
                    gridLineWidth: 1,
                    lineWidth: 0
                }, Q.defaultLeftAxisOptions = {
                    title: {
                        rotation: 270
                    }
                }, Q.defaultRightAxisOptions = {
                    title: {
                        rotation: 90
                    }
                }, Q.defaultBottomAxisOptions = {
                    labels: {
                        autoRotation: [-45]
                    },
                    margin: 15,
                    title: {
                        rotation: 0
                    }
                }, Q.defaultTopAxisOptions = {
                    labels: {
                        autoRotation: [-45]
                    },
                    margin: 15,
                    title: {
                        rotation: 0
                    }
                }, et
            }), ft(Y, "Core/Foundation.js", [Y["Core/Utilities.js"]], function(et) {
                var Q;
                let {
                    addEvent: ht,
                    isFunction: rt,
                    objectEach: it,
                    removeEvent: nt
                } = et;
                return (Q || (Q = {})).registerEventOptions = function(ot, K) {
                    ot.eventOptions = ot.eventOptions || {}, it(K.events, function(Z, U) {
                        ot.eventOptions[U] !== Z && (ot.eventOptions[U] && (nt(ot, U, ot.eventOptions[U]), delete ot.eventOptions[U]), rt(Z) && (ot.eventOptions[U] = Z, ht(ot, U, Z, {
                            order: 0
                        })))
                    })
                }, Q
            }), ft(Y, "Core/Axis/Tick.js", [Y["Core/Templating.js"], Y["Core/Globals.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                let {
                    deg2rad: rt
                } = Q, {
                    clamp: it,
                    correctFloat: nt,
                    defined: ot,
                    destroyObjectProperties: K,
                    extend: Z,
                    fireEvent: U,
                    isNumber: S,
                    merge: R,
                    objectEach: E,
                    pick: M
                } = ht;
                return class {
                    constructor(k, g, f, m, C) {
                        this.isNew = !0, this.isNewLabel = !0, this.axis = k, this.pos = g, this.type = f || "", this.parameters = C || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, U(this, "init"), f || m || this.addLabel()
                    }
                    addLabel() {
                        let k = this,
                            g = k.axis,
                            f = g.options,
                            m = g.chart,
                            C = g.categories,
                            T = g.logarithmic,
                            P = g.names,
                            o = k.pos,
                            l = M(k.options && k.options.labels, f.labels),
                            n = g.tickPositions,
                            h = o === n[0],
                            u = o === n[n.length - 1],
                            e = (!l.step || l.step === 1) && g.tickInterval === 1,
                            t = n.info,
                            i = k.label,
                            s, p, x, O = this.parameters.category || (C ? M(C[o], P[o], o) : o);
                        T && S(O) && (O = nt(T.lin2log(O))), g.dateTime && (t ? s = (p = m.time.resolveDTLFormat(f.dateTimeLabelFormats[!f.grid && t.higherRanks[o] || t.unitName])).main : S(O) && (s = g.dateTime.getXDateFormat(O, f.dateTimeLabelFormats || {}))), k.isFirst = h, k.isLast = u;
                        let d = {
                            axis: g,
                            chart: m,
                            dateTimeLabelFormat: s,
                            isFirst: h,
                            isLast: u,
                            pos: o,
                            tick: k,
                            tickPositionInfo: t,
                            value: O
                        };
                        U(this, "labelFormat", d);
                        let A = B => l.formatter ? l.formatter.call(B, B) : l.format ? (B.text = g.defaultLabelFormatter.call(B, B), et.format(l.format, B, m)) : g.defaultLabelFormatter.call(B, B),
                            L = A.call(d, d),
                            V = p && p.list;
                        V ? k.shortenLabel = function() {
                            for (x = 0; x < V.length; x++)
                                if (Z(d, {
                                    dateTimeLabelFormat: V[x]
                                }), i.attr({
                                    text: A.call(d, d)
                                }), i.getBBox().width < g.getSlotWidth(k) - 2 * l.padding) return;
                            i.attr({
                                text: ""
                            })
                        } : k.shortenLabel = void 0, e && g._addedPlotLB && k.moveLabel(L, l), ot(i) || k.movedLabel ? i && i.textStr !== L && !e && (!i.textWidth || l.style.width || i.styles.width || i.css({
                            width: null
                        }), i.attr({
                            text: L
                        }), i.textPxLength = i.getBBox().width) : (k.label = i = k.createLabel({
                            x: 0,
                            y: 0
                        }, L, l), k.rotation = 0)
                    }
                    createLabel(k, g, f) {
                        let m = this.axis,
                            C = m.chart,
                            T = ot(g) && f.enabled ? C.renderer.text(g, k.x, k.y, f.useHTML).add(m.labelGroup) : null;
                        return T && (C.styledMode || T.css(R(f.style)), T.textPxLength = T.getBBox().width), T
                    }
                    destroy() {
                        K(this, this.axis)
                    }
                    getPosition(k, g, f, m) {
                        let C = this.axis,
                            T = C.chart,
                            P = m && T.oldChartHeight || T.chartHeight,
                            o = {
                                x: k ? nt(C.translate(g + f, void 0, void 0, m) + C.transB) : C.left + C.offset + (C.opposite ? (m && T.oldChartWidth || T.chartWidth) - C.right - C.left : 0),
                                y: k ? P - C.bottom + C.offset - (C.opposite ? C.height : 0) : nt(P - C.translate(g + f, void 0, void 0, m) - C.transB)
                            };
                        return o.y = it(o.y, -1e5, 1e5), U(this, "afterGetPosition", {
                            pos: o
                        }), o
                    }
                    getLabelPosition(k, g, f, m, C, T, P, o) {
                        let l, n, h = this.axis,
                            u = h.transA,
                            e = h.isLinked && h.linkedParent ? h.linkedParent.reversed : h.reversed,
                            t = h.staggerLines,
                            i = h.tickRotCorr || {
                                x: 0,
                                y: 0
                            },
                            s = m || h.reserveSpaceDefault ? 0 : -h.labelOffset * (h.labelAlign === "center" ? .5 : 1),
                            p = C.distance,
                            x = {};
                        return l = h.side === 0 ? f.rotation ? -p : -f.getBBox().height : h.side === 2 ? i.y + p : Math.cos(f.rotation * rt) * (i.y - f.getBBox(!1, 0).height / 2), ot(C.y) && (l = h.side === 0 && h.horiz ? C.y + l : C.y), k = k + M(C.x, [0, 1, 0, -1][h.side] * p) + s + i.x - (T && m ? T * u * (e ? -1 : 1) : 0), g = g + l - (T && !m ? T * u * (e ? 1 : -1) : 0), t && (n = P / (o || 1) % t, h.opposite && (n = t - n - 1), g += n * (h.labelOffset / t)), x.x = k, x.y = Math.round(g), U(this, "afterGetLabelPosition", {
                            pos: x,
                            tickmarkOffset: T,
                            index: P
                        }), x
                    }
                    getLabelSize() {
                        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0
                    }
                    getMarkPath(k, g, f, m, C, T) {
                        return T.crispLine([
                            ["M", k, g],
                            ["L", k + (C ? 0 : -f), g + (C ? f : 0)]
                        ], m)
                    }
                    handleOverflow(k) {
                        let g = this.axis,
                            f = g.options.labels,
                            m = k.x,
                            C = g.chart.chartWidth,
                            T = g.chart.spacing,
                            P = M(g.labelLeft, Math.min(g.pos, T[3])),
                            o = M(g.labelRight, Math.max(g.isRadial ? 0 : g.pos + g.len, C - T[1])),
                            l = this.label,
                            n = this.rotation,
                            h = {
                                left: 0,
                                center: .5,
                                right: 1
                            } [g.labelAlign || l.attr("align")],
                            u = l.getBBox().width,
                            e = g.getSlotWidth(this),
                            t = {},
                            i = e,
                            s = 1,
                            p;
                        n || f.overflow !== "justify" ? n < 0 && m - h * u < P ? p = Math.round(m / Math.cos(n * rt) - P) : n > 0 && m + h * u > o && (p = Math.round((C - m) / Math.cos(n * rt))) : (m - h * u < P ? i = k.x + i * (1 - h) - P : m + (1 - h) * u > o && (i = o - k.x + i * h, s = -1), (i = Math.min(e, i)) < e && g.labelAlign === "center" && (k.x += s * (e - i - h * (e - Math.min(u, i)))), (u > i || g.autoRotation && (l.styles || {}).width) && (p = i)), p && (this.shortenLabel ? this.shortenLabel() : (t.width = Math.floor(p) + "px", (f.style || {}).textOverflow || (t.textOverflow = "ellipsis"), l.css(t)))
                    }
                    moveLabel(k, g) {
                        let f = this,
                            m = f.label,
                            C = f.axis,
                            T = !1,
                            P;
                        m && m.textStr === k ? (f.movedLabel = m, T = !0, delete f.label) : E(C.ticks, function(o) {
                            T || o.isNew || o === f || !o.label || o.label.textStr !== k || (f.movedLabel = o.label, T = !0, o.labelPos = f.movedLabel.xy, delete o.label)
                        }), !T && (f.labelPos || m) && (P = f.labelPos || m.xy, f.movedLabel = f.createLabel(P, k, g), f.movedLabel && f.movedLabel.attr({
                            opacity: 0
                        }))
                    }
                    render(k, g, f) {
                        let m = this.axis,
                            C = m.horiz,
                            T = this.pos,
                            P = M(this.tickmarkOffset, m.tickmarkOffset),
                            o = this.getPosition(C, T, P, g),
                            l = o.x,
                            n = o.y,
                            h = C && l === m.pos + m.len || !C && n === m.pos ? -1 : 1,
                            u = M(f, this.label && this.label.newOpacity, 1);
                        f = M(f, 1), this.isActive = !0, this.renderGridLine(g, f, h), this.renderMark(o, f, h), this.renderLabel(o, g, u, k), this.isNew = !1, U(this, "afterRender")
                    }
                    renderGridLine(k, g, f) {
                        let m = this.axis,
                            C = m.options,
                            T = {},
                            P = this.pos,
                            o = this.type,
                            l = M(this.tickmarkOffset, m.tickmarkOffset),
                            n = m.chart.renderer,
                            h = this.gridLine,
                            u, e = C.gridLineWidth,
                            t = C.gridLineColor,
                            i = C.gridLineDashStyle;
                        this.type === "minor" && (e = C.minorGridLineWidth, t = C.minorGridLineColor, i = C.minorGridLineDashStyle), h || (m.chart.styledMode || (T.stroke = t, T["stroke-width"] = e || 0, T.dashstyle = i), o || (T.zIndex = 1), k && (g = 0), this.gridLine = h = n.path().attr(T).addClass("highcharts-" + (o ? o + "-" : "") + "grid-line").add(m.gridGroup)), h && (u = m.getPlotLinePath({
                            value: P + l,
                            lineWidth: h.strokeWidth() * f,
                            force: "pass",
                            old: k,
                            acrossPanes: !1
                        })) && h[k || this.isNew ? "attr" : "animate"]({
                            d: u,
                            opacity: g
                        })
                    }
                    renderMark(k, g, f) {
                        let m = this.axis,
                            C = m.options,
                            T = m.chart.renderer,
                            P = this.type,
                            o = m.tickSize(P ? P + "Tick" : "tick"),
                            l = k.x,
                            n = k.y,
                            h = M(C[P !== "minor" ? "tickWidth" : "minorTickWidth"], !P && m.isXAxis ? 1 : 0),
                            u = C[P !== "minor" ? "tickColor" : "minorTickColor"],
                            e = this.mark,
                            t = !e;
                        o && (m.opposite && (o[0] = -o[0]), e || (this.mark = e = T.path().addClass("highcharts-" + (P ? P + "-" : "") + "tick").add(m.axisGroup), m.chart.styledMode || e.attr({
                            stroke: u,
                            "stroke-width": h
                        })), e[t ? "attr" : "animate"]({
                            d: this.getMarkPath(l, n, o[0], e.strokeWidth() * f, m.horiz, T),
                            opacity: g
                        }))
                    }
                    renderLabel(k, g, f, m) {
                        let C = this.axis,
                            T = C.horiz,
                            P = C.options,
                            o = this.label,
                            l = P.labels,
                            n = l.step,
                            h = M(this.tickmarkOffset, C.tickmarkOffset),
                            u = k.x,
                            e = k.y,
                            t = !0;
                        o && S(u) && (o.xy = k = this.getLabelPosition(u, e, o, T, l, h, m, n), (!this.isFirst || this.isLast || P.showFirstLabel) && (!this.isLast || this.isFirst || P.showLastLabel) ? !T || l.step || l.rotation || g || f === 0 || this.handleOverflow(k) : t = !1, n && m % n && (t = !1), t && S(k.y) ? (k.opacity = f, o[this.isNewLabel ? "attr" : "animate"](k).show(!0), this.isNewLabel = !1) : (o.hide(), this.isNewLabel = !0))
                    }
                    replaceMovedLabel() {
                        let k = this.label,
                            g = this.axis;
                        k && !this.isNew && (k.animate({
                            opacity: 0
                        }, void 0, k.destroy), delete this.label), g.isDirty = !0, this.label = this.movedLabel, delete this.movedLabel
                    }
                }
            }), ft(Y, "Core/Axis/Axis.js", [Y["Core/Animation/AnimationUtilities.js"], Y["Core/Axis/AxisDefaults.js"], Y["Core/Color/Color.js"], Y["Core/Defaults.js"], Y["Core/Foundation.js"], Y["Core/Globals.js"], Y["Core/Axis/Tick.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt, it, nt, ot, K) {
                let {
                    animObject: Z
                } = et, {
                    defaultOptions: U
                } = rt, {
                    registerEventOptions: S
                } = it, {
                    deg2rad: R
                } = nt, {
                    arrayMax: E,
                    arrayMin: M,
                    clamp: k,
                    correctFloat: g,
                    defined: f,
                    destroyObjectProperties: m,
                    erase: C,
                    error: T,
                    extend: P,
                    fireEvent: o,
                    getClosestDistance: l,
                    insertItem: n,
                    isArray: h,
                    isNumber: u,
                    isString: e,
                    merge: t,
                    normalizeTickInterval: i,
                    objectEach: s,
                    pick: p,
                    relativeLength: x,
                    removeEvent: O,
                    splat: d,
                    syncTimeout: A
                } = K, L = (B, r) => i(r, void 0, void 0, p(B.options.allowDecimals, r < .5 || B.tickAmount !== void 0), !!B.tickAmount);
                class V {
                    constructor(r, c, b) {
                        this.alternateBands = void 0, this.bottom = void 0, this.chart = void 0, this.closestPointRange = void 0, this.coll = void 0, this.eventOptions = void 0, this.hasNames = void 0, this.hasVisibleSeries = void 0, this.height = void 0, this.index = void 0, this.isLinked = void 0, this.labelEdge = void 0, this.labelFormatter = void 0, this.left = void 0, this.len = void 0, this.max = void 0, this.maxLabelLength = void 0, this.min = void 0, this.minorTickInterval = void 0, this.minorTicks = void 0, this.minPixelPadding = void 0, this.names = void 0, this.offset = void 0, this.options = void 0, this.overlap = void 0, this.paddedTicks = void 0, this.plotLinesAndBands = void 0, this.plotLinesAndBandsGroups = void 0, this.pointRange = void 0, this.pointRangePadding = void 0, this.pos = void 0, this.positiveValuesOnly = void 0, this.right = void 0, this.series = void 0, this.side = void 0, this.tickAmount = void 0, this.tickInterval = void 0, this.tickmarkOffset = void 0, this.tickPositions = void 0, this.tickRotCorr = void 0, this.ticks = void 0, this.top = void 0, this.transA = void 0, this.transB = void 0, this.translationSlope = void 0, this.userOptions = void 0, this.visible = void 0, this.width = void 0, this.zoomEnabled = void 0, this.init(r, c, b)
                    }
                    init(r, c, b = this.coll) {
                        let N = b === "xAxis";
                        this.chart = r, this.horiz = this.isZAxis || (r.inverted ? !N : N), this.isXAxis = N, this.coll = b, o(this, "init", {
                            userOptions: c
                        }), this.opposite = p(c.opposite, this.opposite), this.side = p(c.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(c);
                        let z = this.options,
                            W = z.labels,
                            a = z.type;
                        this.userOptions = c, this.minPixelPadding = 0, this.reversed = p(z.reversed, this.reversed), this.visible = z.visible, this.zoomEnabled = z.zoomEnabled, this.hasNames = a === "category" || z.categories === !0, this.categories = z.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = f(z.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len = 0, this.minRange = this.userMinRange = z.minRange || z.maxZoom, this.range = z.range, this.offset = z.offset || 0, this.max = null, this.min = null;
                        let v = p(z.crosshair, d(r.options.tooltip.crosshairs)[N ? 0 : 1]);
                        this.crosshair = v === !0 ? {} : v, r.axes.indexOf(this) === -1 && (N ? r.axes.splice(r.xAxis.length, 0, this) : r.axes.push(this), n(this, r[this.coll])), r.orderItems(this.coll), this.series = this.series || [], r.inverted && !this.isZAxis && N && this.reversed === void 0 && (this.reversed = !0), this.labelRotation = u(W.rotation) ? W.rotation : void 0, S(this, z), o(this, "afterInit")
                    }
                    setOptions(r) {
                        this.options = t(Q.defaultXAxisOptions, this.coll === "yAxis" && Q.defaultYAxisOptions, [Q.defaultTopAxisOptions, Q.defaultRightAxisOptions, Q.defaultBottomAxisOptions, Q.defaultLeftAxisOptions][this.side], t(U[this.coll], r)), o(this, "afterSetOptions", {
                            userOptions: r
                        })
                    }
                    defaultLabelFormatter(r) {
                        let c = this.axis,
                            b = this.chart,
                            {
                                numberFormatter: N
                            } = b,
                            z = u(this.value) ? this.value : NaN,
                            W = c.chart.time,
                            a = c.categories,
                            v = this.dateTimeLabelFormat,
                            y = U.lang,
                            I = y.numericSymbols,
                            w = y.numericSymbolMagnitude || 1e3,
                            G = c.logarithmic ? Math.abs(z) : c.tickInterval,
                            X = I && I.length,
                            _, $;
                        if (a) $ = `${this.value}`;
                        else if (v) $ = W.dateFormat(v, z);
                        else if (X && G >= 1e3)
                            for (; X-- && $ === void 0;) G >= (_ = Math.pow(w, X + 1)) && 10 * z % _ == 0 && I[X] !== null && z !== 0 && ($ = N(z / _, -1) + I[X]);
                        return $ === void 0 && ($ = Math.abs(z) >= 1e4 ? N(z, -1) : N(z, -1, void 0, "")), $
                    }
                    getSeriesExtremes() {
                        let r, c = this;
                        c.chart, o(this, "getSeriesExtremes", null, function() {
                            c.hasVisibleSeries = !1, c.dataMin = c.dataMax = c.threshold = null, c.softThreshold = !c.isXAxis, c.series.forEach(function(b) {
                                if (b.reserveSpace()) {
                                    let N = b.options,
                                        z, W = N.threshold,
                                        a, v;
                                    if (c.hasVisibleSeries = !0, c.positiveValuesOnly && W <= 0 && (W = null), c.isXAxis)(z = b.xData) && z.length && (z = c.logarithmic ? z.filter(y => y > 0) : z, a = (r = b.getXExtremes(z)).min, v = r.max, u(a) || a instanceof Date || (z = z.filter(u), a = (r = b.getXExtremes(z)).min, v = r.max), z.length && (c.dataMin = Math.min(p(c.dataMin, a), a), c.dataMax = Math.max(p(c.dataMax, v), v)));
                                    else {
                                        let y = b.applyExtremes();
                                        u(y.dataMin) && (a = y.dataMin, c.dataMin = Math.min(p(c.dataMin, a), a)), u(y.dataMax) && (v = y.dataMax, c.dataMax = Math.max(p(c.dataMax, v), v)), f(W) && (c.threshold = W), (!N.softThreshold || c.positiveValuesOnly) && (c.softThreshold = !1)
                                    }
                                }
                            })
                        }), o(this, "afterGetSeriesExtremes")
                    }
                    translate(r, c, b, N, z, W) {
                        let a = this.linkedParent || this,
                            v = N && a.old ? a.old.min : a.min;
                        if (!u(v)) return NaN;
                        let y = a.minPixelPadding,
                            I = (a.isOrdinal || a.brokenAxis && a.brokenAxis.hasBreaks || a.logarithmic && z) && a.lin2val,
                            w = 1,
                            G = 0,
                            X = N && a.old ? a.old.transA : a.transA,
                            _ = 0;
                        if (X || (X = a.transA), b && (w *= -1, G = a.len), a.reversed && (w *= -1, G -= w * (a.sector || a.len)), c) _ = (r = r * w + G - y) / X + v, I && (_ = a.lin2val(_));
                        else {
                            I && (r = a.val2lin(r));
                            let $ = w * (r - v) * X;
                            _ = (a.isRadial ? $ : g($)) + G + w * y + (u(W) ? X * W : 0)
                        }
                        return _
                    }
                    toPixels(r, c) {
                        return this.translate(r, !1, !this.horiz, void 0, !0) + (c ? 0 : this.pos)
                    }
                    toValue(r, c) {
                        return this.translate(r - (c ? 0 : this.pos), !0, !this.horiz, void 0, !0)
                    }
                    getPlotLinePath(r) {
                        let c = this,
                            b = c.chart,
                            N = c.left,
                            z = c.top,
                            W = r.old,
                            a = r.value,
                            v = r.lineWidth,
                            y = W && b.oldChartHeight || b.chartHeight,
                            I = W && b.oldChartWidth || b.chartWidth,
                            w = c.transB,
                            G = r.translatedValue,
                            X = r.force,
                            _, $, st, D, j;

                        function F(q, J, at) {
                            return X !== "pass" && (q < J || q > at) && (X ? q = k(q, J, at) : j = !0), q
                        }
                        let H = {
                            value: a,
                            lineWidth: v,
                            old: W,
                            force: X,
                            acrossPanes: r.acrossPanes,
                            translatedValue: G
                        };
                        return o(this, "getPlotLinePath", H, function(q) {
                            _ = st = Math.round((G = k(G = p(G, c.translate(a, void 0, void 0, W)), -1e5, 1e5)) + w), $ = D = Math.round(y - G - w), u(G) ? c.horiz ? ($ = z, D = y - c.bottom, _ = st = F(_, N, N + c.width)) : (_ = N, st = I - c.right, $ = D = F($, z, z + c.height)) : (j = !0, X = !1), q.path = j && !X ? void 0 : b.renderer.crispLine([
                                ["M", _, $],
                                ["L", st, D]
                            ], v || 1)
                        }), H.path || null
                    }
                    getLinearTickPositions(r, c, b) {
                        let N, z, W, a = g(Math.floor(c / r) * r),
                            v = g(Math.ceil(b / r) * r),
                            y = [];
                        if (g(a + r) === a && (W = 20), this.single) return [c];
                        for (N = a; N <= v && (y.push(N), (N = g(N + r, W)) !== z);) z = N;
                        return y
                    }
                    getMinorTickInterval() {
                        let r = this.options;
                        return r.minorTicks === !0 ? p(r.minorTickInterval, "auto") : r.minorTicks === !1 ? null : r.minorTickInterval
                    }
                    getMinorTickPositions() {
                        let r = this.options,
                            c = this.tickPositions,
                            b = this.minorTickInterval,
                            N = this.pointRangePadding || 0,
                            z = this.min - N,
                            W = this.max + N,
                            a = W - z,
                            v = [],
                            y;
                        if (a && a / b < this.len / 3) {
                            let I = this.logarithmic;
                            if (I) this.paddedTicks.forEach(function(w, G, X) {
                                G && v.push.apply(v, I.getLogTickPositions(b, X[G - 1], X[G], !0))
                            });
                            else if (this.dateTime && this.getMinorTickInterval() === "auto") v = v.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(b), z, W, r.startOfWeek));
                            else
                                for (y = z + (c[0] - z) % b; y <= W && y !== v[0]; y += b) v.push(y)
                        }
                        return v.length !== 0 && this.trimTicks(v), v
                    }
                    adjustForMinRange() {
                        let r = this.options,
                            c = this.logarithmic,
                            b = this.min,
                            N = this.max,
                            z, W, a, v, y, I;
                        this.isXAxis && this.minRange === void 0 && !c && (f(r.min) || f(r.max) || f(r.floor) || f(r.ceiling) ? this.minRange = null : (a = l(this.series.map(w => {
                            var G;
                            return (w.xIncrement ? (G = w.xData) == null ? void 0 : G.slice(0, 2) : w.xData) || []
                        })) || 0, this.minRange = Math.min(5 * a, this.dataMax - this.dataMin))), N - b < this.minRange && (W = this.dataMax - this.dataMin >= this.minRange, z = ((I = this.minRange) - N + b) / 2, v = [b - z, p(r.min, b - z)], W && (v[2] = c ? c.log2lin(this.dataMin) : this.dataMin), y = [(b = E(v)) + I, p(r.max, b + I)], W && (y[2] = c ? c.log2lin(this.dataMax) : this.dataMax), (N = M(y)) - b < I && (v[0] = N - I, v[1] = p(r.min, N - I), b = E(v))), this.min = b, this.max = N
                    }
                    getClosest() {
                        let r, c;
                        if (this.categories) c = 1;
                        else {
                            let b = [];
                            this.series.forEach(function(N) {
                                var W;
                                let z = N.closestPointRange;
                                ((W = N.xData) == null ? void 0 : W.length) === 1 ? b.push(N.xData[0]) : !N.noSharedTooltip && f(z) && N.reserveSpace() && (c = f(c) ? Math.min(c, z) : z)
                            }), b.length && (b.sort((N, z) => N - z), r = l([b]))
                        }
                        return r && c ? Math.min(r, c) : r || c
                    }
                    nameToX(r) {
                        let c = h(this.options.categories),
                            b = c ? this.categories : this.names,
                            N = r.options.x,
                            z;
                        return r.series.requireSorting = !1, f(N) || (N = this.options.uniqueNames && b ? c ? b.indexOf(r.name) : p(b.keys[r.name], -1) : r.series.autoIncrement()), N === -1 ? !c && b && (z = b.length) : z = N, z !== void 0 ? (this.names[z] = r.name, this.names.keys[r.name] = z) : r.x && (z = r.x), z
                    }
                    updateNames() {
                        let r = this,
                            c = this.names;
                        c.length > 0 && (Object.keys(c.keys).forEach(function(N) {
                            delete c.keys[N]
                        }), c.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function(N) {
                            N.xIncrement = null, (!N.points || N.isDirtyData) && (r.max = Math.max(r.max, N.xData.length - 1), N.processData(), N.generatePoints()), N.data.forEach(function(z, W) {
                                let a;
                                z && z.options && z.name !== void 0 && (a = r.nameToX(z)) !== void 0 && a !== z.x && (z.x = a, N.xData[W] = a)
                            })
                        }))
                    }
                    setAxisTranslation() {
                        let r = this,
                            c = r.max - r.min,
                            b = r.linkedParent,
                            N = !!r.categories,
                            z = r.isXAxis,
                            W = r.axisPointRange || 0,
                            a, v = 0,
                            y = 0,
                            I, w = r.transA;
                        (z || N || W) && (a = r.getClosest(), b ? (v = b.minPointOffset, y = b.pointRangePadding) : r.series.forEach(function(G) {
                            let X = N ? 1 : z ? p(G.options.pointRange, a, 0) : r.axisPointRange || 0,
                                _ = G.options.pointPlacement;
                            if (W = Math.max(W, X), !r.single || N) {
                                let $ = G.is("xrange") ? !z : z;
                                v = Math.max(v, $ && e(_) ? 0 : X / 2), y = Math.max(y, $ && _ === "on" ? 0 : X)
                            }
                        }), I = r.ordinal && r.ordinal.slope && a ? r.ordinal.slope / a : 1, r.minPointOffset = v *= I, r.pointRangePadding = y *= I, r.pointRange = Math.min(W, r.single && N ? 1 : c), z && a && (r.closestPointRange = a)), r.translationSlope = r.transA = w = r.staticScale || r.len / (c + y || 1), r.transB = r.horiz ? r.left : r.bottom, r.minPixelPadding = w * v, o(this, "afterSetAxisTranslation")
                    }
                    minFromRange() {
                        return this.max - this.range
                    }
                    setTickInterval(r) {
                        let c = this.chart,
                            b = this.logarithmic,
                            N = this.options,
                            z = this.isXAxis,
                            W = this.isLinked,
                            a = N.tickPixelInterval,
                            v = this.categories,
                            y = this.softThreshold,
                            I = N.maxPadding,
                            w = N.minPadding,
                            G, X, _ = u(N.tickInterval) && N.tickInterval >= 0 ? N.tickInterval : void 0,
                            $ = u(this.threshold) ? this.threshold : null,
                            st, D, j, F;
                        if (this.dateTime || v || W || this.getTickAmount(), j = p(this.userMin, N.min), F = p(this.userMax, N.max), W ? (this.linkedParent = c[this.coll][N.linkedTo], X = this.linkedParent.getExtremes(), this.min = p(X.min, X.dataMin), this.max = p(X.max, X.dataMax), N.type !== this.linkedParent.options.type && T(11, 1, c)) : (y && f($) && (this.dataMin >= $ ? (st = $, w = 0) : this.dataMax <= $ && (D = $, I = 0)), this.min = p(j, st, this.dataMin), this.max = p(F, D, this.dataMax)), b && (this.positiveValuesOnly && !r && 0 >= Math.min(this.min, p(this.dataMin, this.min)) && T(10, 1, c), this.min = g(b.log2lin(this.min), 16), this.max = g(b.log2lin(this.max), 16)), this.range && f(this.max) && (this.userMin = this.min = j = Math.max(this.dataMin, this.minFromRange()), this.userMax = F = this.max, this.range = null), o(this, "foundExtremes"), this.beforePadding && this.beforePadding(), this.adjustForMinRange(), !u(this.userMin) && u(N.softMin) && N.softMin < this.min && (this.min = j = N.softMin), !u(this.userMax) && u(N.softMax) && N.softMax > this.max && (this.max = F = N.softMax), !v && !this.axisPointRange && !(this.stacking && this.stacking.usePercentage) && !W && f(this.min) && f(this.max) && (G = this.max - this.min) && (!f(j) && w && (this.min -= G * w), !f(F) && I && (this.max += G * I)), !u(this.userMin) && u(N.floor) && (this.min = Math.max(this.min, N.floor)), !u(this.userMax) && u(N.ceiling) && (this.max = Math.min(this.max, N.ceiling)), y && f(this.dataMin) && ($ = $ || 0, !f(j) && this.min < $ && this.dataMin >= $ ? this.min = this.options.minRange ? Math.min($, this.max - this.minRange) : $ : !f(F) && this.max > $ && this.dataMax <= $ && (this.max = this.options.minRange ? Math.max($, this.min + this.minRange) : $)), u(this.min) && u(this.max) && !this.chart.polar && this.min > this.max && (f(this.options.min) ? this.max = this.min : f(this.options.max) && (this.min = this.max)), this.min === this.max || this.min === void 0 || this.max === void 0 ? this.tickInterval = 1 : W && this.linkedParent && !_ && a === this.linkedParent.options.tickPixelInterval ? this.tickInterval = _ = this.linkedParent.tickInterval : this.tickInterval = p(_, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, v ? 1 : (this.max - this.min) * a / Math.max(this.len, a)), z && !r) {
                            let q = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
                            this.series.forEach(function(J) {
                                J.forceCrop = J.forceCropping && J.forceCropping(), J.processData(q)
                            }), o(this, "postProcessData", {
                                hasExtremesChanged: q
                            })
                        }
                        this.setAxisTranslation(), o(this, "initialAxisTranslation"), this.pointRange && !_ && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
                        let H = p(N.minTickInterval, this.dateTime && !this.series.some(q => q.noSharedTooltip) ? this.closestPointRange : 0);
                        !_ && this.tickInterval < H && (this.tickInterval = H), this.dateTime || this.logarithmic || _ || (this.tickInterval = L(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions()
                    }
                    setTickPositions() {
                        let r = this.options,
                            c = r.tickPositions,
                            b = r.tickPositioner,
                            N = this.getMinorTickInterval(),
                            z = this.hasVerticalPanning(),
                            W = this.coll === "colorAxis",
                            a = (W || !z) && r.startOnTick,
                            v = (W || !z) && r.endOnTick,
                            y = [],
                            I;
                        if (this.tickmarkOffset = this.categories && r.tickmarkPlacement === "between" && this.tickInterval === 1 ? .5 : 0, this.minorTickInterval = N === "auto" && this.tickInterval ? this.tickInterval / r.minorTicksPerMajor : N, this.single = this.min === this.max && f(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || r.allowDecimals !== !1), c) y = c.slice();
                        else if (u(this.min) && u(this.max)) {
                            if ((!this.ordinal || !this.ordinal.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) y = [this.min, this.max], T(19, !1, this.chart);
                            else if (this.dateTime) y = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, r.units), this.min, this.max, r.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);
                            else if (this.logarithmic) y = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
                            else {
                                let w = this.tickInterval,
                                    G = w;
                                for (; G <= 2 * w && (y = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && y.length > this.tickAmount);) this.tickInterval = L(this, G *= 1.1)
                            }
                            y.length > this.len && (y = [y[0], y[y.length - 1]])[0] === y[1] && (y.length = 1), b && (this.tickPositions = y, (I = b.apply(this, [this.min, this.max])) && (y = I))
                        }
                        this.tickPositions = y, this.paddedTicks = y.slice(0), this.trimTicks(y, a, v), !this.isLinked && u(this.min) && u(this.max) && (this.single && y.length < 2 && !this.categories && !this.series.some(w => w.is("heatmap") && w.options.pointPlacement === "between") && (this.min -= .5, this.max += .5), c || I || this.adjustTickAmount()), o(this, "afterSetTickPositions")
                    }
                    trimTicks(r, c, b) {
                        let N = r[0],
                            z = r[r.length - 1],
                            W = !this.isOrdinal && this.minPointOffset || 0;
                        if (o(this, "trimTicks"), !this.isLinked) {
                            if (c && N !== -1 / 0) this.min = N;
                            else
                                for (; this.min - W > r[0];) r.shift();
                            if (b) this.max = z;
                            else
                                for (; this.max + W < r[r.length - 1];) r.pop();
                            r.length === 0 && f(N) && !this.options.tickPositions && r.push((z + N) / 2)
                        }
                    }
                    alignToOthers() {
                        let r, c = this,
                            b = [this],
                            N = c.options,
                            z = this.coll === "yAxis" && this.chart.options.chart.alignThresholds,
                            W = [];
                        if (c.thresholdAlignment = void 0, (this.chart.options.chart.alignTicks !== !1 && N.alignTicks || z) && N.startOnTick !== !1 && N.endOnTick !== !1 && !c.logarithmic) {
                            let a = y => {
                                    let {
                                        horiz: I,
                                        options: w
                                    } = y;
                                    return [I ? w.left : w.top, w.width, w.height, w.pane].join(",")
                                },
                                v = a(this);
                            this.chart[this.coll].forEach(function(y) {
                                let {
                                    series: I
                                } = y;
                                I.length && I.some(w => w.visible) && y !== c && a(y) === v && (r = !0, b.push(y))
                            })
                        }
                        if (r && z) {
                            b.forEach(v => {
                                let y = v.getThresholdAlignment(c);
                                u(y) && W.push(y)
                            });
                            let a = W.length > 1 ? W.reduce((v, y) => v += y, 0) / W.length : void 0;
                            b.forEach(v => {
                                v.thresholdAlignment = a
                            })
                        }
                        return r
                    }
                    getThresholdAlignment(r) {
                        if ((!u(this.dataMin) || this !== r && this.series.some(c => c.isDirty || c.isDirtyData)) && this.getSeriesExtremes(), u(this.threshold)) {
                            let c = k((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);
                            return this.options.reversed && (c = 1 - c), c
                        }
                    }
                    getTickAmount() {
                        let r = this.options,
                            c = r.tickPixelInterval,
                            b = r.tickAmount;
                        f(r.tickInterval) || b || !(this.len < c) || this.isRadial || this.logarithmic || !r.startOnTick || !r.endOnTick || (b = 2), !b && this.alignToOthers() && (b = Math.ceil(this.len / c) + 1), b < 4 && (this.finalTickAmt = b, b = 5), this.tickAmount = b
                    }
                    adjustTickAmount() {
                        let r = this,
                            {
                                finalTickAmt: c,
                                max: b,
                                min: N,
                                options: z,
                                tickPositions: W,
                                tickAmount: a,
                                thresholdAlignment: v
                            } = r,
                            y = W && W.length,
                            I = p(r.threshold, r.softThreshold ? 0 : null),
                            w, G, X = r.tickInterval,
                            _, $ = () => W.push(g(W[W.length - 1] + X)),
                            st = () => W.unshift(g(W[0] - X));
                        if (u(v) && (_ = v < .5 ? Math.ceil(v * (a - 1)) : Math.floor(v * (a - 1)), z.reversed && (_ = a - 1 - _)), r.hasData() && u(N) && u(b)) {
                            let D = () => {
                                r.transA *= (y - 1) / (a - 1), r.min = z.startOnTick ? W[0] : Math.min(N, W[0]), r.max = z.endOnTick ? W[W.length - 1] : Math.max(b, W[W.length - 1])
                            };
                            if (u(_) && u(r.threshold)) {
                                for (; W[_] !== I || W.length !== a || W[0] > N || W[W.length - 1] < b;) {
                                    for (W.length = 0, W.push(r.threshold); W.length < a;) W[_] === void 0 || W[_] > r.threshold ? st() : $();
                                    if (X > 8 * r.tickInterval) break;
                                    X *= 2
                                }
                                D()
                            } else if (y < a) {
                                for (; W.length < a;) W.length % 2 || N === I ? $() : st();
                                D()
                            }
                            if (f(c)) {
                                for (G = w = W.length; G--;)(c === 3 && G % 2 == 1 || c <= 2 && G > 0 && G < w - 1) && W.splice(G, 1);
                                r.finalTickAmt = void 0
                            }
                        }
                    }
                    setScale() {
                        let {
                            coll: r,
                            stacking: c
                        } = this, b = !1, N = !1;
                        this.series.forEach(W => {
                            b = b || W.isDirtyData || W.isDirty, N = N || W.xAxis && W.xAxis.isDirty || !1
                        }), this.setAxisSize();
                        let z = this.len !== (this.old && this.old.len);
                        z || b || N || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (c && r === "yAxis" && c.buildStacks(), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), c && r === "xAxis" && c.buildStacks(), this.isDirty || (this.isDirty = z || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : c && c.cleanStacks(), b && this.panningState && (this.panningState.isDirty = !0), o(this, "afterSetScale")
                    }
                    setExtremes(r, c, b, N, z) {
                        let W = this,
                            a = W.chart;
                        b = p(b, !0), W.series.forEach(function(v) {
                            delete v.kdTree
                        }), o(W, "setExtremes", z = P(z, {
                            min: r,
                            max: c
                        }), function() {
                            W.userMin = r, W.userMax = c, W.eventArgs = z, b && a.redraw(N)
                        })
                    }
                    zoom(r, c) {
                        let b = this,
                            N = this.dataMin,
                            z = this.dataMax,
                            W = this.options,
                            a = Math.min(N, p(W.min, N)),
                            v = Math.max(z, p(W.max, z)),
                            y = {
                                newMin: r,
                                newMax: c
                            };
                        return o(this, "zoom", y, function(I) {
                            let w = I.newMin,
                                G = I.newMax;
                            (w !== b.min || G !== b.max) && (!b.allowZoomOutside && (f(N) && (w < a && (w = a), w > v && (w = v)), f(z) && (G < a && (G = a), G > v && (G = v))), b.displayBtn = w !== void 0 || G !== void 0, b.setExtremes(w, G, !1, void 0, {
                                trigger: "zoom"
                            })), I.zoomed = !0
                        }), y.zoomed
                    }
                    setAxisSize() {
                        let r = this.chart,
                            c = this.options,
                            b = c.offsets || [0, 0, 0, 0],
                            N = this.horiz,
                            z = this.width = Math.round(x(p(c.width, r.plotWidth - b[3] + b[1]), r.plotWidth)),
                            W = this.height = Math.round(x(p(c.height, r.plotHeight - b[0] + b[2]), r.plotHeight)),
                            a = this.top = Math.round(x(p(c.top, r.plotTop + b[0]), r.plotHeight, r.plotTop)),
                            v = this.left = Math.round(x(p(c.left, r.plotLeft + b[3]), r.plotWidth, r.plotLeft));
                        this.bottom = r.chartHeight - W - a, this.right = r.chartWidth - z - v, this.len = Math.max(N ? z : W, 0), this.pos = N ? v : a
                    }
                    getExtremes() {
                        let r = this.logarithmic;
                        return {
                            min: r ? g(r.lin2log(this.min)) : this.min,
                            max: r ? g(r.lin2log(this.max)) : this.max,
                            dataMin: this.dataMin,
                            dataMax: this.dataMax,
                            userMin: this.userMin,
                            userMax: this.userMax
                        }
                    }
                    getThreshold(r) {
                        let c = this.logarithmic,
                            b = c ? c.lin2log(this.min) : this.min,
                            N = c ? c.lin2log(this.max) : this.max;
                        return r === null || r === -1 / 0 ? r = b : r === 1 / 0 ? r = N : b > r ? r = b : N < r && (r = N), this.translate(r, 0, 1, 0, 1)
                    }
                    autoLabelAlign(r) {
                        let c = (p(r, 0) - 90 * this.side + 720) % 360,
                            b = {
                                align: "center"
                            };
                        return o(this, "autoLabelAlign", b, function(N) {
                            c > 15 && c < 165 ? N.align = "right" : c > 195 && c < 345 && (N.align = "left")
                        }), b.align
                    }
                    tickSize(r) {
                        let c = this.options,
                            b = p(c[r === "tick" ? "tickWidth" : "minorTickWidth"], r === "tick" && this.isXAxis && !this.categories ? 1 : 0),
                            N = c[r === "tick" ? "tickLength" : "minorTickLength"],
                            z;
                        b && N && (c[r + "Position"] === "inside" && (N = -N), z = [N, b]);
                        let W = {
                            tickSize: z
                        };
                        return o(this, "afterTickSize", W), W.tickSize
                    }
                    labelMetrics() {
                        let r = this.chart.renderer,
                            c = this.ticks,
                            b = c[Object.keys(c)[0]] || {};
                        return this.chart.renderer.fontMetrics(b.label || b.movedLabel || r.box)
                    }
                    unsquish() {
                        let r = this.options.labels,
                            c = this.horiz,
                            b = this.tickInterval,
                            N = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / b),
                            z = r.rotation,
                            W = .75 * this.labelMetrics().h,
                            a = Math.max(this.max - this.min, 0),
                            v = function(X) {
                                let _ = X / (N || 1);
                                return (_ = _ > 1 ? Math.ceil(_) : 1) * b > a && X !== 1 / 0 && N !== 1 / 0 && a && (_ = Math.ceil(a / b)), g(_ * b)
                            },
                            y = b,
                            I, w = Number.MAX_VALUE,
                            G;
                        if (c) {
                            if (!r.staggerLines && (u(z) ? G = [z] : N < r.autoRotationLimit && (G = r.autoRotation)), G) {
                                let X, _;
                                for (let $ of G)($ === z || $ && $ >= -90 && $ <= 90) && (_ = (X = v(Math.abs(W / Math.sin(R * $)))) + Math.abs($ / 360)) < w && (w = _, I = $, y = X)
                            }
                        } else y = v(W);
                        return this.autoRotation = G, this.labelRotation = p(I, u(z) ? z : 0), r.step ? b : y
                    }
                    getSlotWidth(r) {
                        let c = this.chart,
                            b = this.horiz,
                            N = this.options.labels,
                            z = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
                            W = c.margin[3];
                        if (r && u(r.slotWidth)) return r.slotWidth;
                        if (b && N.step < 2) return N.rotation ? 0 : (this.staggerLines || 1) * this.len / z;
                        if (!b) {
                            let a = N.style.width;
                            if (a !== void 0) return parseInt(String(a), 10);
                            if (W) return W - c.spacing[3]
                        }
                        return .33 * c.chartWidth
                    }
                    renderUnsquish() {
                        let r = this.chart,
                            c = r.renderer,
                            b = this.tickPositions,
                            N = this.ticks,
                            z = this.options.labels,
                            W = z.style,
                            a = this.horiz,
                            v = this.getSlotWidth(),
                            y = Math.max(1, Math.round(v - 2 * z.padding)),
                            I = {},
                            w = this.labelMetrics(),
                            G = W.textOverflow,
                            X, _, $ = 0,
                            st, D;
                        if (e(z.rotation) || (I.rotation = z.rotation || 0), b.forEach(function(j) {
                            let F = N[j];
                            F.movedLabel && F.replaceMovedLabel(), F && F.label && F.label.textPxLength > $ && ($ = F.label.textPxLength)
                        }), this.maxLabelLength = $, this.autoRotation) $ > y && $ > w.h ? I.rotation = this.labelRotation : this.labelRotation = 0;
                        else if (v && (X = y, !G))
                            for (_ = "clip", D = b.length; !a && D--;)(st = N[b[D]].label) && (st.styles && st.styles.textOverflow === "ellipsis" ? st.css({
                                textOverflow: "clip"
                            }) : st.textPxLength > v && st.css({
                                width: v + "px"
                            }), st.getBBox().height > this.len / b.length - (w.h - w.f) && (st.specificTextOverflow = "ellipsis"));
                        I.rotation && (X = $ > .5 * r.chartHeight ? .33 * r.chartHeight : $, G || (_ = "ellipsis")), this.labelAlign = z.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (I.align = this.labelAlign), b.forEach(function(j) {
                            let F = N[j],
                                H = F && F.label,
                                q = W.width,
                                J = {};
                            H && (H.attr(I), F.shortenLabel ? F.shortenLabel() : X && !q && W.whiteSpace !== "nowrap" && (X < H.textPxLength || H.element.tagName === "SPAN") ? (J.width = X + "px", G || (J.textOverflow = H.specificTextOverflow || _), H.css(J)) : H.styles && H.styles.width && !J.width && !q && H.css({
                                width: null
                            }), delete H.specificTextOverflow, F.rotation = I.rotation)
                        }, this), this.tickRotCorr = c.rotCorr(w.b, this.labelRotation || 0, this.side !== 0)
                    }
                    hasData() {
                        return this.series.some(function(r) {
                            return r.hasData()
                        }) || this.options.showEmpty && f(this.min) && f(this.max)
                    }
                    addTitle(r) {
                        let c, b = this.chart.renderer,
                            N = this.horiz,
                            z = this.opposite,
                            W = this.options,
                            a = W.title,
                            v = this.chart.styledMode;
                        this.axisTitle || ((c = a.textAlign) || (c = (N ? {
                            low: "left",
                            middle: "center",
                            high: "right"
                        } : {
                            low: z ? "right" : "left",
                            middle: "center",
                            high: z ? "left" : "right"
                        })[a.align]), this.axisTitle = b.text(a.text || "", 0, 0, a.useHTML).attr({
                            zIndex: 7,
                            rotation: a.rotation,
                            align: c
                        }).addClass("highcharts-axis-title"), v || this.axisTitle.css(t(a.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0), v || a.style.width || this.isRadial || this.axisTitle.css({
                            width: this.len + "px"
                        }), this.axisTitle[r ? "show" : "hide"](r)
                    }
                    generateTick(r) {
                        let c = this.ticks;
                        c[r] ? c[r].addLabel() : c[r] = new ot(this, r)
                    }
                    getOffset() {
                        let r = this,
                            {
                                chart: c,
                                horiz: b,
                                options: N,
                                side: z,
                                ticks: W,
                                tickPositions: a,
                                coll: v,
                                axisParent: y
                            } = r,
                            I = c.renderer,
                            w = c.inverted && !r.isZAxis ? [1, 0, 3, 2][z] : z,
                            G = r.hasData(),
                            X = N.title,
                            _ = N.labels,
                            $ = u(N.crossing),
                            st = c.axisOffset,
                            D = c.clipOffset,
                            j = [-1, 1, 1, -1][z],
                            F = N.className,
                            H, q = 0,
                            J, at = 0,
                            tt = 0,
                            dt, pt;
                        if (r.showAxis = H = G || N.showEmpty, r.staggerLines = r.horiz && _.staggerLines || void 0, !r.axisGroup) {
                            let lt = (ut, mt, xt) => I.g(ut).attr({
                                zIndex: xt
                            }).addClass(`highcharts-${v.toLowerCase()}${mt} ` + (this.isRadial ? `highcharts-radial-axis${mt} ` : "") + (F || "")).add(y);
                            r.gridGroup = lt("grid", "-grid", N.gridZIndex), r.axisGroup = lt("axis", "", N.zIndex), r.labelGroup = lt("axis-labels", "-labels", _.zIndex)
                        }
                        if (G || r.isLinked ? (a.forEach(function(lt) {
                            r.generateTick(lt)
                        }), r.renderUnsquish(), r.reserveSpaceDefault = z === 0 || z === 2 || {
                            1: "left",
                            3: "right"
                        } [z] === r.labelAlign, p(_.reserveSpace, !$ && null, r.labelAlign === "center" || null, r.reserveSpaceDefault) && a.forEach(function(lt) {
                            tt = Math.max(W[lt].getLabelSize(), tt)
                        }), r.staggerLines && (tt *= r.staggerLines), r.labelOffset = tt * (r.opposite ? -1 : 1)) : s(W, function(lt, ut) {
                            lt.destroy(), delete W[ut]
                        }), X && X.text && X.enabled !== !1 && (r.addTitle(H), H && !$ && X.reserveSpace !== !1 && (r.titleOffset = q = r.axisTitle.getBBox()[b ? "height" : "width"], at = f(J = X.offset) ? 0 : p(X.margin, b ? 5 : 10))), r.renderLine(), r.offset = j * p(N.offset, st[z] ? st[z] + (N.margin || 0) : 0), r.tickRotCorr = r.tickRotCorr || {
                            x: 0,
                            y: 0
                        }, pt = z === 0 ? -r.labelMetrics().h : z === 2 ? r.tickRotCorr.y : 0, dt = Math.abs(tt) + at, tt && (dt -= pt, dt += j * (b ? p(_.y, r.tickRotCorr.y + j * _.distance) : p(_.x, j * _.distance))), r.axisTitleMargin = p(J, dt), r.getMaxLabelDimensions && (r.maxLabelDimensions = r.getMaxLabelDimensions(W, a)), v !== "colorAxis") {
                            let lt = this.tickSize("tick");
                            st[z] = Math.max(st[z], (r.axisTitleMargin || 0) + q + j * r.offset, dt, a && a.length && lt ? lt[0] + j * r.offset : 0);
                            let ut = !r.axisLine || N.offset ? 0 : 2 * Math.floor(r.axisLine.strokeWidth() / 2);
                            D[w] = Math.max(D[w], ut)
                        }
                        o(this, "afterGetOffset")
                    }
                    getLinePath(r) {
                        let c = this.chart,
                            b = this.opposite,
                            N = this.offset,
                            z = this.horiz,
                            W = this.left + (b ? this.width : 0) + N,
                            a = c.chartHeight - this.bottom - (b ? this.height : 0) + N;
                        return b && (r *= -1), c.renderer.crispLine([
                            ["M", z ? this.left : W, z ? a : this.top],
                            ["L", z ? c.chartWidth - this.right : W, z ? a : c.chartHeight - this.bottom]
                        ], r)
                    }
                    renderLine() {
                        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
                            stroke: this.options.lineColor,
                            "stroke-width": this.options.lineWidth,
                            zIndex: 7
                        }))
                    }
                    getTitlePosition(r) {
                        let c = this.horiz,
                            b = this.left,
                            N = this.top,
                            z = this.len,
                            W = this.options.title,
                            a = c ? b : N,
                            v = this.opposite,
                            y = this.offset,
                            I = W.x,
                            w = W.y,
                            G = this.chart.renderer.fontMetrics(r),
                            X = r ? Math.max(r.getBBox(!1, 0).height - G.h - 1, 0) : 0,
                            _ = {
                                low: a + (c ? 0 : z),
                                middle: a + z / 2,
                                high: a + (c ? z : 0)
                            } [W.align],
                            $ = (c ? N + this.height : b) + (c ? 1 : -1) * (v ? -1 : 1) * (this.axisTitleMargin || 0) + [-X, X, G.f, -X][this.side],
                            st = {
                                x: c ? _ + I : $ + (v ? this.width : 0) + y + I,
                                y: c ? $ + w - (v ? this.height : 0) + y : _ + w
                            };
                        return o(this, "afterGetTitlePosition", {
                            titlePosition: st
                        }), st
                    }
                    renderMinorTick(r, c) {
                        let b = this.minorTicks;
                        b[r] || (b[r] = new ot(this, r, "minor")), c && b[r].isNew && b[r].render(null, !0), b[r].render(null, !1, 1)
                    }
                    renderTick(r, c, b) {
                        let N = this.isLinked,
                            z = this.ticks;
                        (!N || r >= this.min && r <= this.max || this.grid && this.grid.isColumn) && (z[r] || (z[r] = new ot(this, r)), b && z[r].isNew && z[r].render(c, !0, -1), z[r].render(c))
                    }
                    render() {
                        let r, c, b = this,
                            N = b.chart,
                            z = b.logarithmic,
                            W = N.renderer,
                            a = b.options,
                            v = b.isLinked,
                            y = b.tickPositions,
                            I = b.axisTitle,
                            w = b.ticks,
                            G = b.minorTicks,
                            X = b.alternateBands,
                            _ = a.stackLabels,
                            $ = a.alternateGridColor,
                            st = a.crossing,
                            D = b.tickmarkOffset,
                            j = b.axisLine,
                            F = b.showAxis,
                            H = Z(W.globalAnimation);
                        if (b.labelEdge.length = 0, b.overlap = !1, [w, G, X].forEach(function(q) {
                            s(q, function(J) {
                                J.isActive = !1
                            })
                        }), u(st)) {
                            let q = this.isXAxis ? N.yAxis[0] : N.xAxis[0],
                                J = [1, -1, -1, 1][this.side];
                            if (q) {
                                let at = q.toPixels(st, !0);
                                b.horiz && (at = q.len - at), b.offset = J * at
                            }
                        }
                        if (b.hasData() || v) {
                            let q = b.chart.hasRendered && b.old && u(b.old.min);
                            b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function(J) {
                                b.renderMinorTick(J, q)
                            }), y.length && (y.forEach(function(J, at) {
                                b.renderTick(J, at, q)
                            }), D && (b.min === 0 || b.single) && (w[-1] || (w[-1] = new ot(b, -1, null, !0)), w[-1].render(-1))), $ && y.forEach(function(J, at) {
                                c = y[at + 1] !== void 0 ? y[at + 1] + D : b.max - D, at % 2 == 0 && J < b.max && c <= b.max + (N.polar ? -D : D) && (X[J] || (X[J] = new nt.PlotLineOrBand(b)), r = J + D, X[J].options = {
                                    from: z ? z.lin2log(r) : r,
                                    to: z ? z.lin2log(c) : c,
                                    color: $,
                                    className: "highcharts-alternate-grid"
                                }, X[J].render(), X[J].isActive = !0)
                            }), b._addedPlotLB || (b._addedPlotLB = !0, (a.plotLines || []).concat(a.plotBands || []).forEach(function(J) {
                                b.addPlotBandOrLine(J)
                            }))
                        } [w, G, X].forEach(function(q) {
                            let J = [],
                                at = H.duration;
                            s(q, function(tt, dt) {
                                tt.isActive || (tt.render(dt, !1, 0), tt.isActive = !1, J.push(dt))
                            }), A(function() {
                                let tt = J.length;
                                for (; tt--;) q[J[tt]] && !q[J[tt]].isActive && (q[J[tt]].destroy(), delete q[J[tt]])
                            }, q !== X && N.hasRendered && at ? at : 0)
                        }), j && (j[j.isPlaced ? "animate" : "attr"]({
                            d: this.getLinePath(j.strokeWidth())
                        }), j.isPlaced = !0, j[F ? "show" : "hide"](F)), I && F && (I[I.isNew ? "attr" : "animate"](b.getTitlePosition(I)), I.isNew = !1), _ && _.enabled && b.stacking && b.stacking.renderStackTotals(), b.old = {
                            len: b.len,
                            max: b.max,
                            min: b.min,
                            transA: b.transA,
                            userMax: b.userMax,
                            userMin: b.userMin
                        }, b.isDirty = !1, o(this, "afterRender")
                    }
                    redraw() {
                        this.visible && (this.render(), this.plotLinesAndBands.forEach(function(r) {
                            r.render()
                        })), this.series.forEach(function(r) {
                            r.isDirty = !0
                        })
                    }
                    getKeepProps() {
                        return this.keepProps || V.keepProps
                    }
                    destroy(r) {
                        let c = this,
                            b = c.plotLinesAndBands,
                            N = this.eventOptions;
                        if (o(this, "destroy", {
                            keepEvents: r
                        }), r || O(c), [c.ticks, c.minorTicks, c.alternateBands].forEach(function(z) {
                            m(z)
                        }), b) {
                            let z = b.length;
                            for (; z--;) b[z].destroy()
                        }
                        for (let z in ["axisLine", "axisTitle", "axisGroup", "gridGroup", "labelGroup", "cross", "scrollbar"].forEach(function(W) {
                            c[W] && (c[W] = c[W].destroy())
                        }), c.plotLinesAndBandsGroups) c.plotLinesAndBandsGroups[z] = c.plotLinesAndBandsGroups[z].destroy();
                        s(c, function(z, W) {
                            c.getKeepProps().indexOf(W) === -1 && delete c[W]
                        }), this.eventOptions = N
                    }
                    drawCrosshair(r, c) {
                        let b = this.crosshair,
                            N = p(b && b.snap, !0),
                            z = this.chart,
                            W, a, v, y = this.cross,
                            I;
                        if (o(this, "drawCrosshair", {
                            e: r,
                            point: c
                        }), r || (r = this.cross && this.cross.e), b && (f(c) || !N) !== !1) {
                            if (N ? f(c) && (a = p(this.coll !== "colorAxis" ? c.crosshairPos : null, this.isXAxis ? c.plotX : this.len - c.plotY)) : a = r && (this.horiz ? r.chartX - this.pos : this.len - r.chartY + this.pos), f(a) && (I = {
                                value: c && (this.isXAxis ? c.x : p(c.stackY, c.y)),
                                translatedValue: a
                            }, z.polar && P(I, {
                                isCrosshair: !0,
                                chartX: r && r.chartX,
                                chartY: r && r.chartY,
                                point: c
                            }), W = this.getPlotLinePath(I) || null), !f(W)) {
                                this.hideCrosshair();
                                return
                            }
                            v = this.categories && !this.isRadial, y || (this.cross = y = z.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (v ? "category " : "thin ") + (b.className || "")).attr({
                                zIndex: p(b.zIndex, 2)
                            }).add(), !z.styledMode && (y.attr({
                                stroke: b.color || (v ? ht.parse("#ccd3ff").setOpacity(.25).get() : "#cccccc"),
                                "stroke-width": p(b.width, 1)
                            }).css({
                                "pointer-events": "none"
                            }), b.dashStyle && y.attr({
                                dashstyle: b.dashStyle
                            }))), y.show().attr({
                                d: W
                            }), v && !b.width && y.attr({
                                "stroke-width": this.transA
                            }), this.cross.e = r
                        } else this.hideCrosshair();
                        o(this, "afterDrawCrosshair", {
                            e: r,
                            point: c
                        })
                    }
                    hideCrosshair() {
                        this.cross && this.cross.hide(), o(this, "afterHideCrosshair")
                    }
                    hasVerticalPanning() {
                        let r = this.chart.options.chart.panning;
                        return !!(r && r.enabled && /y/.test(r.type))
                    }
                    update(r, c) {
                        let b = this.chart;
                        r = t(this.userOptions, r), this.destroy(!0), this.init(b, r), b.isDirtyBox = !0, p(c, !0) && b.redraw()
                    }
                    remove(r) {
                        let c = this.chart,
                            b = this.coll,
                            N = this.series,
                            z = N.length;
                        for (; z--;) N[z] && N[z].remove(!1);
                        C(c.axes, this), C(c[b] || [], this), c.orderItems(b), this.destroy(), c.isDirtyBox = !0, p(r, !0) && c.redraw()
                    }
                    setTitle(r, c) {
                        this.update({
                            title: r
                        }, c)
                    }
                    setCategories(r, c) {
                        this.update({
                            categories: r
                        }, c)
                    }
                }
                return V.defaultOptions = Q.defaultXAxisOptions, V.keepProps = ["coll", "extKey", "hcEvents", "names", "series", "userMax", "userMin"], V
            }), ft(Y, "Core/Axis/DateTimeAxis.js", [Y["Core/Utilities.js"]], function(et) {
                var Q;
                let {
                    addEvent: ht,
                    getMagnitude: rt,
                    normalizeTickInterval: it,
                    timeUnits: nt
                } = et;
                return function(ot) {
                    let K = [];

                    function Z() {
                        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments)
                    }

                    function U(R) {
                        if (R.userOptions.type !== "datetime") {
                            this.dateTime = void 0;
                            return
                        }
                        this.dateTime || (this.dateTime = new S(this))
                    }
                    ot.compose = function(R) {
                        if (et.pushUnique(K, R)) {
                            R.keepProps.push("dateTime");
                            let E = R.prototype;
                            E.getTimeTicks = Z, ht(R, "init", U)
                        }
                        return R
                    };
                    class S {
                        constructor(E) {
                            this.axis = E
                        }
                        normalizeTimeTickInterval(E, M) {
                            let k = M || [
                                    ["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],
                                    ["second", [1, 2, 5, 10, 15, 30]],
                                    ["minute", [1, 2, 5, 10, 15, 30]],
                                    ["hour", [1, 2, 3, 4, 6, 8, 12]],
                                    ["day", [1, 2]],
                                    ["week", [1, 2]],
                                    ["month", [1, 2, 3, 4, 6]],
                                    ["year", null]
                                ],
                                g = k[k.length - 1],
                                f = nt[g[0]],
                                m = g[1],
                                C;
                            for (C = 0; C < k.length; C++)
                                if (f = nt[(g = k[C])[0]], m = g[1], k[C + 1]) {
                                    let P = (f * m[m.length - 1] + nt[k[C + 1][0]]) / 2;
                                    if (E <= P) break
                                } f === nt.year && E < 5 * f && (m = [1, 2, 5]);
                            let T = it(E / f, m, g[0] === "year" ? Math.max(rt(E / f), 1) : 1);
                            return {
                                unitRange: f,
                                count: T,
                                unitName: g[0]
                            }
                        }
                        getXDateFormat(E, M) {
                            let {
                                axis: k
                            } = this, g = k.chart.time;
                            return k.closestPointRange ? g.getDateFormat(k.closestPointRange, E, k.options.startOfWeek, M) || g.resolveDTLFormat(M.year).main : g.resolveDTLFormat(M.day).main
                        }
                    }
                    ot.Additions = S
                }(Q || (Q = {})), Q
            }), ft(Y, "Core/Axis/LogarithmicAxis.js", [Y["Core/Utilities.js"]], function(et) {
                var Q;
                let {
                    addEvent: ht,
                    normalizeTickInterval: rt,
                    pick: it
                } = et;
                return function(nt) {
                    let ot = [];

                    function K(S) {
                        let R = S.userOptions,
                            E = this.logarithmic;
                        R.type !== "logarithmic" ? this.logarithmic = void 0 : E || (E = this.logarithmic = new U(this))
                    }

                    function Z() {
                        let S = this.logarithmic;
                        S && (this.lin2val = function(R) {
                            return S.lin2log(R)
                        }, this.val2lin = function(R) {
                            return S.log2lin(R)
                        })
                    }
                    nt.compose = function(S) {
                        return et.pushUnique(ot, S) && (S.keepProps.push("logarithmic"), ht(S, "init", K), ht(S, "afterInit", Z)), S
                    };
                    class U {
                        constructor(R) {
                            this.axis = R
                        }
                        getLogTickPositions(R, E, M, k) {
                            let g = this.axis,
                                f = g.len,
                                m = g.options,
                                C = [];
                            if (k || (this.minorAutoInterval = void 0), R >= .5) R = Math.round(R), C = g.getLinearTickPositions(R, E, M);
                            else if (R >= .08) {
                                let T, P, o, l, n, h, u, e = Math.floor(E);
                                for (T = R > .3 ? [1, 2, 4] : R > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], P = e; P < M + 1 && !u; P++)
                                    for (o = 0, l = T.length; o < l && !u; o++)(n = this.log2lin(this.lin2log(P) * T[o])) > E && (!k || h <= M) && h !== void 0 && C.push(h), h > M && (u = !0), h = n
                            } else {
                                let T = this.lin2log(E),
                                    P = this.lin2log(M),
                                    o = k ? g.getMinorTickInterval() : m.tickInterval,
                                    l = o === "auto" ? null : o,
                                    n = m.tickPixelInterval / (k ? 5 : 1),
                                    h = k ? f / g.tickPositions.length : f;
                                R = rt(R = it(l, this.minorAutoInterval, (P - T) * n / (h || 1))), C = g.getLinearTickPositions(R, T, P).map(this.log2lin), k || (this.minorAutoInterval = R / 5)
                            }
                            return k || (g.tickInterval = R), C
                        }
                        lin2log(R) {
                            return Math.pow(10, R)
                        }
                        log2lin(R) {
                            return Math.log(R) / Math.LN10
                        }
                    }
                    nt.Additions = U
                }(Q || (Q = {})), Q
            }), ft(Y, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [Y["Core/Utilities.js"]], function(et) {
                var Q;
                let {
                    erase: ht,
                    extend: rt,
                    isNumber: it
                } = et;
                return function(nt) {
                    let ot, K = [];

                    function Z(g) {
                        return this.addPlotBandOrLine(g, "plotBands")
                    }

                    function U(g, f) {
                        let m = this.userOptions,
                            C = new ot(this, g);
                        if (this.visible && (C = C.render()), C) {
                            if (this._addedPlotLB || (this._addedPlotLB = !0, (m.plotLines || []).concat(m.plotBands || []).forEach(T => {
                                this.addPlotBandOrLine(T)
                            })), f) {
                                let T = m[f] || [];
                                T.push(g), m[f] = T
                            }
                            this.plotLinesAndBands.push(C)
                        }
                        return C
                    }

                    function S(g) {
                        return this.addPlotBandOrLine(g, "plotLines")
                    }

                    function R(g, f, m) {
                        m = m || this.options;
                        let C = this.getPlotLinePath({
                                value: f,
                                force: !0,
                                acrossPanes: m.acrossPanes
                            }),
                            T = [],
                            P = this.horiz,
                            o = !it(this.min) || !it(this.max) || g < this.min && f < this.min || g > this.max && f > this.max,
                            l = this.getPlotLinePath({
                                value: g,
                                force: !0,
                                acrossPanes: m.acrossPanes
                            }),
                            n, h = 1,
                            u;
                        if (l && C)
                            for (o && (u = l.toString() === C.toString(), h = 0), n = 0; n < l.length; n += 2) {
                                let e = l[n],
                                    t = l[n + 1],
                                    i = C[n],
                                    s = C[n + 1];
                                (e[0] === "M" || e[0] === "L") && (t[0] === "M" || t[0] === "L") && (i[0] === "M" || i[0] === "L") && (s[0] === "M" || s[0] === "L") && (P && i[1] === e[1] ? (i[1] += h, s[1] += h) : P || i[2] !== e[2] || (i[2] += h, s[2] += h), T.push(["M", e[1], e[2]], ["L", t[1], t[2]], ["L", s[1], s[2]], ["L", i[1], i[2]], ["Z"])), T.isFlat = u
                            } else l = null;
                        return T
                    }

                    function E(g) {
                        this.removePlotBandOrLine(g)
                    }

                    function M(g) {
                        let f = this.plotLinesAndBands,
                            m = this.options,
                            C = this.userOptions;
                        if (f) {
                            let T = f.length;
                            for (; T--;) f[T].id === g && f[T].destroy();
                            [m.plotLines || [], C.plotLines || [], m.plotBands || [], C.plotBands || []].forEach(function(P) {
                                for (T = P.length; T--;)(P[T] || {}).id === g && ht(P, P[T])
                            })
                        }
                    }

                    function k(g) {
                        this.removePlotBandOrLine(g)
                    }
                    nt.compose = function(g, f) {
                        return ot || (ot = g), et.pushUnique(K, f) && rt(f.prototype, {
                            addPlotBand: Z,
                            addPlotLine: S,
                            addPlotBandOrLine: U,
                            getPlotBandPath: R,
                            removePlotBand: E,
                            removePlotLine: k,
                            removePlotBandOrLine: M
                        }), f
                    }
                }(Q || (Q = {})), Q
            }), ft(Y, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [Y["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], Y["Core/Utilities.js"]], function(et, Q) {
                let {
                    arrayMax: ht,
                    arrayMin: rt,
                    defined: it,
                    destroyObjectProperties: nt,
                    erase: ot,
                    fireEvent: K,
                    merge: Z,
                    objectEach: U,
                    pick: S
                } = Q;
                class R {
                    static compose(M) {
                        return et.compose(R, M)
                    }
                    constructor(M, k) {
                        this.id = void 0, this.axis = M, k && (this.options = k, this.id = k.id)
                    }
                    render() {
                        K(this, "render");
                        let M = this,
                            k = M.axis,
                            g = k.horiz,
                            f = k.logarithmic,
                            m = M.options,
                            C = m.color,
                            T = S(m.zIndex, 0),
                            P = m.events,
                            o = {},
                            l = k.chart.renderer,
                            n = m.label,
                            h = M.label,
                            u = m.to,
                            e = m.from,
                            t = m.value,
                            i = M.svgElem,
                            s = [],
                            p, x = it(e) && it(u),
                            O = it(t),
                            d = !i,
                            A = {
                                class: "highcharts-plot-" + (x ? "band " : "line ") + (m.className || "")
                            },
                            L = x ? "bands" : "lines";
                        if (f && (e = f.log2lin(e), u = f.log2lin(u), t = f.log2lin(t)), !k.chart.styledMode && (O ? (A.stroke = C || "#999999", A["stroke-width"] = S(m.width, 1), m.dashStyle && (A.dashstyle = m.dashStyle)) : x && (A.fill = C || "#e6e9ff", m.borderWidth && (A.stroke = m.borderColor, A["stroke-width"] = m.borderWidth))), o.zIndex = T, L += "-" + T, (p = k.plotLinesAndBandsGroups[L]) || (k.plotLinesAndBandsGroups[L] = p = l.g("plot-" + L).attr(o).add()), d && (M.svgElem = i = l.path().attr(A).add(p)), O) s = k.getPlotLinePath({
                            value: t,
                            lineWidth: i.strokeWidth(),
                            acrossPanes: m.acrossPanes
                        });
                        else {
                            if (!x) return;
                            s = k.getPlotBandPath(e, u, m)
                        }
                        return !M.eventsAdded && P && (U(P, function(V, B) {
                            i.on(B, function(r) {
                                P[B].apply(M, [r])
                            })
                        }), M.eventsAdded = !0), (d || !i.d) && s && s.length ? i.attr({
                            d: s
                        }) : i && (s ? (i.show(), i.animate({
                            d: s
                        })) : i.d && (i.hide(), h && (M.label = h = h.destroy()))), n && (it(n.text) || it(n.formatter)) && s && s.length && k.width > 0 && k.height > 0 && !s.isFlat ? (n = Z({
                            align: g && x && "center",
                            x: g ? !x && 4 : 10,
                            verticalAlign: !g && x && "middle",
                            y: g ? x ? 16 : 10 : x ? 6 : -4,
                            rotation: g && !x && 90
                        }, n), this.renderLabel(n, s, x, T)) : h && h.hide(), M
                    }
                    renderLabel(M, k, g, f) {
                        let m = this.axis,
                            C = m.chart.renderer,
                            T = this.label;
                        T || (this.label = T = C.text(this.getLabelText(M), 0, 0, M.useHTML).attr({
                            align: M.textAlign || M.align,
                            rotation: M.rotation,
                            class: "highcharts-plot-" + (g ? "band" : "line") + "-label " + (M.className || ""),
                            zIndex: f
                        }), m.chart.styledMode || T.css(Z({
                            fontSize: "0.8em",
                            textOverflow: "ellipsis"
                        }, M.style)), T.add());
                        let P = k.xBounds || [k[0][1], k[1][1], g ? k[2][1] : k[0][1]],
                            o = k.yBounds || [k[0][2], k[1][2], g ? k[2][2] : k[0][2]],
                            l = rt(P),
                            n = rt(o);
                        if (T.align(M, !1, {
                            x: l,
                            y: n,
                            width: ht(P) - l,
                            height: ht(o) - n
                        }), !T.alignValue || T.alignValue === "left") {
                            let h = M.clip ? m.width : m.chart.chartWidth;
                            T.css({
                                width: (T.rotation === 90 ? m.height - (T.alignAttr.y - m.top) : h - (T.alignAttr.x - m.left)) + "px"
                            })
                        }
                        T.show(!0)
                    }
                    getLabelText(M) {
                        return it(M.formatter) ? M.formatter.call(this) : M.text
                    }
                    destroy() {
                        ot(this.axis.plotLinesAndBands, this), delete this.axis, nt(this)
                    }
                }
                return R
            }), ft(Y, "Core/Tooltip.js", [Y["Core/Templating.js"], Y["Core/Globals.js"], Y["Core/Renderer/RendererUtilities.js"], Y["Core/Renderer/RendererRegistry.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt, it) {
                let {
                    format: nt
                } = et, {
                    doc: ot,
                    isSafari: K
                } = Q, {
                    distribute: Z
                } = ht, {
                    addEvent: U,
                    clamp: S,
                    css: R,
                    discardElement: E,
                    extend: M,
                    fireEvent: k,
                    isArray: g,
                    isNumber: f,
                    isString: m,
                    merge: C,
                    pick: T,
                    splat: P,
                    syncTimeout: o
                } = it;
                class l {
                    constructor(h, u) {
                        this.allowShared = !0, this.crosshairs = [], this.distance = 0, this.isHidden = !0, this.isSticky = !1, this.now = {}, this.options = {}, this.outside = !1, this.chart = h, this.init(h, u)
                    }
                    bodyFormatter(h) {
                        return h.map(function(u) {
                            let e = u.series.tooltipOptions;
                            return (e[(u.point.formatPrefix || "point") + "Formatter"] || u.point.tooltipFormatter).call(u.point, e[(u.point.formatPrefix || "point") + "Format"] || "")
                        })
                    }
                    cleanSplit(h) {
                        this.chart.series.forEach(function(u) {
                            let e = u && u.tt;
                            e && (!e.isActive || h ? u.tt = e.destroy() : e.isActive = !1)
                        })
                    }
                    defaultFormatter(h) {
                        let u, e = this.points || P(this);
                        return (u = (u = [h.tooltipFooterHeaderFormatter(e[0])]).concat(h.bodyFormatter(e))).push(h.tooltipFooterHeaderFormatter(e[0], !0)), u
                    }
                    destroy() {
                        this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), E(this.container)), it.clearTimeout(this.hideTimer), it.clearTimeout(this.tooltipTimeout)
                    }
                    getAnchor(h, u) {
                        let e, t = this.chart,
                            i = t.pointer,
                            s = t.inverted,
                            p = t.plotTop,
                            x = t.plotLeft;
                        if ((h = P(h))[0].series && h[0].series.yAxis && !h[0].series.yAxis.options.reversedStacks && (h = h.slice().reverse()), this.followPointer && u) u.chartX === void 0 && (u = i.normalize(u)), e = [u.chartX - x, u.chartY - p];
                        else if (h[0].tooltipPos) e = h[0].tooltipPos;
                        else {
                            let O = 0,
                                d = 0;
                            h.forEach(function(A) {
                                let L = A.pos(!0);
                                L && (O += L[0], d += L[1])
                            }), O /= h.length, d /= h.length, this.shared && h.length > 1 && u && (s ? O = u.chartX : d = u.chartY), e = [O - x, d - p]
                        }
                        return e.map(Math.round)
                    }
                    getClassName(h, u, e) {
                        let t = this.options,
                            i = h.series,
                            s = i.options;
                        return [t.className, "highcharts-label", e && "highcharts-tooltip-header", u ? "highcharts-tooltip-box" : "highcharts-tooltip", !e && "highcharts-color-" + T(h.colorIndex, i.colorIndex), s && s.className].filter(m).join(" ")
                    }
                    getLabel() {
                        let h = this,
                            u = this.chart.styledMode,
                            e = this.options,
                            t = this.split && this.allowShared,
                            i = this.container,
                            s = this.chart.renderer;
                        if (this.label) {
                            let p = !this.label.hasClass("highcharts-label");
                            (!t && p || t && !p) && this.destroy()
                        }
                        if (!this.label) {
                            if (this.outside) {
                                let p = this.chart.options.chart.style,
                                    x = rt.getRendererType();
                                this.container = i = Q.doc.createElement("div"), i.className = "highcharts-tooltip-container", R(i, {
                                    position: "absolute",
                                    top: "1px",
                                    pointerEvents: "none",
                                    zIndex: Math.max(this.options.style.zIndex || 0, (p && p.zIndex || 0) + 3)
                                }), this.renderer = s = new x(i, 0, 0, p, void 0, void 0, s.styledMode)
                            }
                            if (t ? this.label = s.g("tooltip") : (this.label = s.label("", 0, 0, e.shape, void 0, void 0, e.useHTML, void 0, "tooltip").attr({
                                padding: e.padding,
                                r: e.borderRadius
                            }), u || this.label.attr({
                                fill: e.backgroundColor,
                                "stroke-width": e.borderWidth || 0
                            }).css(e.style).css({
                                pointerEvents: e.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none")
                            })), h.outside) {
                                let p = this.label,
                                    {
                                        xSetter: x,
                                        ySetter: O
                                    } = p;
                                p.xSetter = function(d) {
                                    x.call(p, h.distance), i && (i.style.left = d + "px")
                                }, p.ySetter = function(d) {
                                    O.call(p, h.distance), i && (i.style.top = d + "px")
                                }
                            }
                            this.label.attr({
                                zIndex: 8
                            }).shadow(e.shadow).add()
                        }
                        return i && !i.parentElement && Q.doc.body.appendChild(i), this.label
                    }
                    getPlayingField() {
                        let {
                            body: h,
                            documentElement: u
                        } = ot, {
                            chart: e,
                            distance: t,
                            outside: i
                        } = this;
                        return {
                            width: i ? Math.max(h.scrollWidth, u.scrollWidth, h.offsetWidth, u.offsetWidth, u.clientWidth) - 2 * t : e.chartWidth,
                            height: i ? Math.max(h.scrollHeight, u.scrollHeight, h.offsetHeight, u.offsetHeight, u.clientHeight) : e.chartHeight
                        }
                    }
                    getPosition(h, u, e) {
                        let t = this.chart,
                            i = this.distance,
                            s = {},
                            p = t.inverted && e.h || 0,
                            x = this.outside,
                            O = this.getPlayingField(),
                            d = O.width,
                            A = O.height,
                            L = t.pointer.getChartPosition(),
                            V = w => w * L.scaleX,
                            B = w => w * L.scaleY,
                            r = w => {
                                let G = w === "x";
                                return [w, G ? d : A, G ? h : u].concat(x ? [G ? V(h) : B(u), G ? L.left - i + V(e.plotX + t.plotLeft) : L.top - i + B(e.plotY + t.plotTop), 0, G ? d : A] : [G ? h : u, G ? e.plotX + t.plotLeft : e.plotY + t.plotTop, G ? t.plotLeft : t.plotTop, G ? t.plotLeft + t.plotWidth : t.plotTop + t.plotHeight])
                            },
                            c = r("y"),
                            b = r("x"),
                            N, z = !!e.negative;
                        !t.polar && t.hoverSeries && t.hoverSeries.yAxis && t.hoverSeries.yAxis.reversed && (z = !z);
                        let W = !this.followPointer && T(e.ttBelow, !t.inverted === z),
                            a = function(w, G, X, _, $, st, D) {
                                let j = x ? w === "y" ? B(i) : V(i) : i,
                                    F = (X - _) / 2,
                                    H = _ < $ - i,
                                    q = $ + i + _ < G,
                                    J = $ - j - X + F,
                                    at = $ + j - F;
                                if (W && q) s[w] = at;
                                else if (!W && H) s[w] = J;
                                else if (H) s[w] = Math.min(D - _, J - p < 0 ? J : J - p);
                                else {
                                    if (!q) return !1;
                                    s[w] = Math.max(st, at + p + X > G ? at : at + p)
                                }
                            },
                            v = function(w, G, X, _, $) {
                                let st;
                                return $ < i || $ > G - i ? st = !1 : $ < X / 2 ? s[w] = 1 : $ > G - _ / 2 ? s[w] = G - _ - 2 : s[w] = $ - X / 2, st
                            },
                            y = function(w) {
                                let G = c;
                                c = b, b = G, N = w
                            },
                            I = function() {
                                a.apply(0, c) !== !1 ? v.apply(0, b) !== !1 || N || (y(!0), I()) : N ? s.x = s.y = 0 : (y(!0), I())
                            };
                        return (t.inverted || this.len > 1) && y(), I(), s
                    }
                    hide(h) {
                        let u = this;
                        it.clearTimeout(this.hideTimer), h = T(h, this.options.hideDelay), this.isHidden || (this.hideTimer = o(function() {
                            let e = u.getLabel();
                            u.getLabel().animate({
                                opacity: 0
                            }, {
                                duration: h && 150,
                                complete: () => {
                                    e.hide(), u.container && u.container.remove()
                                }
                            }), u.isHidden = !0
                        }, h))
                    }
                    init(h, u) {
                        this.chart = h, this.options = u, this.crosshairs = [], this.now = {
                            x: 0,
                            y: 0
                        }, this.isHidden = !0, this.split = u.split && !h.inverted && !h.polar, this.shared = u.shared || this.split, this.outside = T(u.outside, !!(h.scrollablePixelsX || h.scrollablePixelsY))
                    }
                    shouldStickOnContact(h) {
                        return !!(!this.followPointer && this.options.stickOnContact && (!h || this.chart.pointer.inClass(h.target, "highcharts-tooltip")))
                    }
                    move(h, u, e, t) {
                        let i = this,
                            s = i.now,
                            p = i.options.animation !== !1 && !i.isHidden && (Math.abs(h - s.x) > 1 || Math.abs(u - s.y) > 1),
                            x = i.followPointer || i.len > 1;
                        M(s, {
                            x: p ? (2 * s.x + h) / 3 : h,
                            y: p ? (s.y + u) / 2 : u,
                            anchorX: x ? void 0 : p ? (2 * s.anchorX + e) / 3 : e,
                            anchorY: x ? void 0 : p ? (s.anchorY + t) / 2 : t
                        }), i.getLabel().attr(s), i.drawTracker(), p && (it.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
                            i && i.move(h, u, e, t)
                        }, 32))
                    }
                    refresh(h, u) {
                        let e = this.chart,
                            t = this.options,
                            i = e.pointer,
                            s = P(h),
                            p = s[0],
                            x = [],
                            O = t.format,
                            d = t.formatter || this.defaultFormatter,
                            A = this.shared,
                            L = e.styledMode,
                            V = {};
                        if (!t.enabled || !p.series) return;
                        it.clearTimeout(this.hideTimer), this.allowShared = !(!g(h) && h.series && h.series.noSharedTooltip), this.followPointer = !this.split && p.series.tooltipOptions.followPointer;
                        let B = this.getAnchor(h, u),
                            r = B[0],
                            c = B[1];
                        A && this.allowShared ? (i.applyInactiveState(s), s.forEach(function(z) {
                            z.setState("hover"), x.push(z.getLabelConfig())
                        }), (V = p.getLabelConfig()).points = x) : V = p.getLabelConfig(), this.len = x.length;
                        let b = m(O) ? nt(O, V, e) : d.call(V, this),
                            N = p.series;
                        if (this.distance = T(N.tooltipOptions.distance, 16), b === !1) this.hide();
                        else {
                            if (this.split && this.allowShared) this.renderSplit(b, s);
                            else {
                                let z = r,
                                    W = c;
                                if (u && i.isDirectTouch && (z = u.chartX - e.plotLeft, W = u.chartY - e.plotTop), e.polar || N.options.clip === !1 || s.some(a => i.isDirectTouch || a.series.shouldShowTooltip(z, W))) {
                                    let a = this.getLabel();
                                    (!t.style.width || L) && a.css({
                                        width: (this.outside ? this.getPlayingField() : e.spacingBox).width + "px"
                                    }), a.attr({
                                        text: b && b.join ? b.join("") : b
                                    }), a.addClass(this.getClassName(p), !0), L || a.attr({
                                        stroke: t.borderColor || p.color || N.color || "#666666"
                                    }), this.updatePosition({
                                        plotX: r,
                                        plotY: c,
                                        negative: p.negative,
                                        ttBelow: p.ttBelow,
                                        h: B[2] || 0
                                    })
                                } else {
                                    this.hide();
                                    return
                                }
                            }
                            this.isHidden && this.label && this.label.attr({
                                opacity: 1
                            }).show(), this.isHidden = !1
                        }
                        k(this, "refresh")
                    }
                    renderSplit(h, u) {
                        let e = this,
                            {
                                chart: t,
                                chart: {
                                    chartWidth: i,
                                    chartHeight: s,
                                    plotHeight: p,
                                    plotLeft: x,
                                    plotTop: O,
                                    pointer: d,
                                    scrollablePixelsY: A = 0,
                                    scrollablePixelsX: L,
                                    scrollingContainer: {
                                        scrollLeft: V,
                                        scrollTop: B
                                    } = {
                                        scrollLeft: 0,
                                        scrollTop: 0
                                    },
                                    styledMode: r
                                },
                                distance: c,
                                options: b,
                                options: {
                                    positioner: N
                                }
                            } = e,
                            z = e.outside && typeof L != "number" ? ot.documentElement.getBoundingClientRect() : {
                                left: V,
                                right: V + i,
                                top: B,
                                bottom: B + s
                            },
                            W = e.getLabel(),
                            a = this.renderer || t.renderer,
                            v = !!(t.xAxis[0] && t.xAxis[0].opposite),
                            {
                                left: y,
                                top: I
                            } = d.getChartPosition(),
                            w = O + B,
                            G = 0,
                            X = p - A;

                        function _(H, q, J, at, tt = !0) {
                            let dt, pt;
                            return J ? (dt = v ? 0 : X, pt = S(H - at / 2, z.left, z.right - at - (e.outside ? y : 0))) : (dt = q - w, pt = S(pt = tt ? H - at - c : H + c, tt ? pt : z.left, z.right)), {
                                x: pt,
                                y: dt
                            }
                        }
                        m(h) && (h = [!1, h]);
                        let $ = h.slice(0, u.length + 1).reduce(function(H, q, J) {
                            if (q !== !1 && q !== "") {
                                let at = u[J - 1] || {
                                        isHeader: !0,
                                        plotX: u[0].plotX,
                                        plotY: p,
                                        series: {}
                                    },
                                    tt = at.isHeader,
                                    dt = tt ? e : at.series,
                                    pt = dt.tt = function(gt, ct, bt) {
                                        let yt = gt,
                                            {
                                                isHeader: vt,
                                                series: Mt
                                            } = ct;
                                        if (!yt) {
                                            let kt = {
                                                padding: b.padding,
                                                r: b.borderRadius
                                            };
                                            r || (kt.fill = b.backgroundColor, kt["stroke-width"] = b.borderWidth ?? 1), yt = a.label("", 0, 0, b[vt ? "headerShape" : "shape"], void 0, void 0, b.useHTML).addClass(e.getClassName(ct, !0, vt)).attr(kt).add(W)
                                        }
                                        return yt.isActive = !0, yt.attr({
                                            text: bt
                                        }), r || yt.css(b.style).attr({
                                            stroke: b.borderColor || ct.color || Mt.color || "#333333"
                                        }), yt
                                    }(dt.tt, at, q.toString()),
                                    lt = pt.getBBox(),
                                    ut = lt.width + pt.strokeWidth();
                                tt && (G = lt.height, X += G, v && (w -= G));
                                let {
                                    anchorX: mt,
                                    anchorY: xt
                                } = function(gt) {
                                    let ct, bt, {
                                        isHeader: yt,
                                        plotX: vt = 0,
                                        plotY: Mt = 0,
                                        series: kt
                                    } = gt;
                                    if (yt) ct = Math.max(x + vt, x), bt = O + p / 2;
                                    else {
                                        let {
                                            xAxis: wt,
                                            yAxis: St
                                        } = kt;
                                        ct = wt.pos + S(vt, -c, wt.len + c), kt.shouldShowTooltip(0, St.pos - O + Mt, {
                                            ignoreX: !0
                                        }) && (bt = St.pos + Mt)
                                    }
                                    return {
                                        anchorX: ct = S(ct, z.left - c, z.right + c),
                                        anchorY: bt
                                    }
                                }(at);
                                if (typeof xt == "number") {
                                    let gt = lt.height + 1,
                                        ct = N ? N.call(e, ut, gt, at) : _(mt, xt, tt, ut);
                                    H.push({
                                        align: N ? 0 : void 0,
                                        anchorX: mt,
                                        anchorY: xt,
                                        boxWidth: ut,
                                        point: at,
                                        rank: T(ct.rank, tt ? 1 : 0),
                                        size: gt,
                                        target: ct.y,
                                        tt: pt,
                                        x: ct.x
                                    })
                                } else pt.isActive = !1
                            }
                            return H
                        }, []);
                        !N && $.some(H => {
                            let {
                                outside: q
                            } = e, J = (q ? y : 0) + H.anchorX;
                            return J < z.left && J + H.boxWidth < z.right || J < y - z.left + H.boxWidth && z.right - J > J
                        }) && ($ = $.map(H => {
                            let {
                                x: q,
                                y: J
                            } = _(H.anchorX, H.anchorY, H.point.isHeader, H.boxWidth, !1);
                            return M(H, {
                                target: J,
                                x: q
                            })
                        })), e.cleanSplit(), Z($, X);
                        let st = {
                            left: y,
                            right: y
                        };
                        $.forEach(function(H) {
                            let {
                                x: q,
                                boxWidth: J,
                                isHeader: at
                            } = H;
                            !at && (e.outside && y + q < st.left && (st.left = y + q), !at && e.outside && st.left + J > st.right && (st.right = y + q))
                        }), $.forEach(function(H) {
                            let {
                                x: q,
                                anchorX: J,
                                anchorY: at,
                                pos: tt,
                                point: {
                                    isHeader: dt
                                }
                            } = H, pt = {
                                visibility: tt === void 0 ? "hidden" : "inherit",
                                x: q,
                                y: (tt || 0) + w,
                                anchorX: J,
                                anchorY: at
                            };
                            if (e.outside && q < J) {
                                let lt = y - st.left;
                                lt > 0 && (dt || (pt.x = q + lt, pt.anchorX = J + lt), dt && (pt.x = (st.right - st.left) / 2, pt.anchorX = J + lt))
                            }
                            H.tt.attr(pt)
                        });
                        let {
                            container: D,
                            outside: j,
                            renderer: F
                        } = e;
                        if (j && D && F) {
                            let {
                                width: H,
                                height: q,
                                x: J,
                                y: at
                            } = W.getBBox();
                            F.setSize(H + J, q + at, !1), D.style.left = st.left + "px", D.style.top = I + "px"
                        }
                        K && W.attr({
                            opacity: W.opacity === 1 ? .999 : 1
                        })
                    }
                    drawTracker() {
                        if (!this.shouldStickOnContact()) {
                            this.tracker && (this.tracker = this.tracker.destroy());
                            return
                        }
                        let h = this.chart,
                            u = this.label,
                            e = this.shared ? h.hoverPoints : h.hoverPoint;
                        if (!u || !e) return;
                        let t = {
                                x: 0,
                                y: 0,
                                width: 0,
                                height: 0
                            },
                            i = this.getAnchor(e),
                            s = u.getBBox();
                        i[0] += h.plotLeft - (u.translateX || 0), i[1] += h.plotTop - (u.translateY || 0), t.x = Math.min(0, i[0]), t.y = Math.min(0, i[1]), t.width = i[0] < 0 ? Math.max(Math.abs(i[0]), s.width - i[0]) : Math.max(Math.abs(i[0]), s.width), t.height = i[1] < 0 ? Math.max(Math.abs(i[1]), s.height - Math.abs(i[1])) : Math.max(Math.abs(i[1]), s.height), this.tracker ? this.tracker.attr(t) : (this.tracker = u.renderer.rect(t).addClass("highcharts-tracker").add(u), h.styledMode || this.tracker.attr({
                            fill: "rgba(0,0,0,0)"
                        }))
                    }
                    styledModeFormat(h) {
                        return h.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"')
                    }
                    tooltipFooterHeaderFormatter(h, u) {
                        let e = h.series,
                            t = e.tooltipOptions,
                            i = e.xAxis,
                            s = i && i.dateTime,
                            p = {
                                isFooter: u,
                                labelConfig: h
                            },
                            x = t.xDateFormat,
                            O = t[u ? "footerFormat" : "headerFormat"];
                        return k(this, "headerFormatter", p, function(d) {
                            s && !x && f(h.key) && (x = s.getXDateFormat(h.key, t.dateTimeLabelFormats)), s && x && (h.point && h.point.tooltipDateKeys || ["key"]).forEach(function(A) {
                                O = O.replace("{point." + A + "}", "{point." + A + ":" + x + "}")
                            }), e.chart.styledMode && (O = this.styledModeFormat(O)), d.text = nt(O, {
                                point: h,
                                series: e
                            }, this.chart)
                        }), p.text
                    }
                    update(h) {
                        this.destroy(), this.init(this.chart, C(!0, this.options, h))
                    }
                    updatePosition(h) {
                        let {
                            chart: u,
                            container: e,
                            distance: t,
                            options: i,
                            renderer: s
                        } = this, {
                            height: p = 0,
                            width: x = 0
                        } = this.getLabel(), O = u.pointer, {
                            left: d,
                            top: A,
                            scaleX: L,
                            scaleY: V
                        } = O.getChartPosition(), B = (i.positioner || this.getPosition).call(this, x, p, h), r = (h.plotX || 0) + u.plotLeft, c = (h.plotY || 0) + u.plotTop, b;
                        s && e && (i.positioner && (B.x += d - t, B.y += A - t), b = (i.borderWidth || 0) + 2 * t + 2, s.setSize(x + b, p + b, !1), (L !== 1 || V !== 1) && (R(e, {
                            transform: `scale(${L}, ${V})`
                        }), r *= L, c *= V), r += d - B.x, c += A - B.y), this.move(Math.round(B.x), Math.round(B.y || 0), r, c)
                    }
                }
                return function(n) {
                    let h = [];
                    n.compose = function(u) {
                        it.pushUnique(h, u) && U(u, "afterInit", function() {
                            let e = this.chart;
                            e.options.tooltip && (e.tooltip = new n(e, e.options.tooltip))
                        })
                    }
                }(l || (l = {})), l
            }), ft(Y, "Core/Series/Point.js", [Y["Core/Renderer/HTML/AST.js"], Y["Core/Animation/AnimationUtilities.js"], Y["Core/Defaults.js"], Y["Core/Templating.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt, it) {
                let {
                    animObject: nt
                } = Q, {
                    defaultOptions: ot
                } = ht, {
                    format: K
                } = rt, {
                    addEvent: Z,
                    defined: U,
                    erase: S,
                    extend: R,
                    fireEvent: E,
                    getNestedProperty: M,
                    isArray: k,
                    isFunction: g,
                    isNumber: f,
                    isObject: m,
                    merge: C,
                    objectEach: T,
                    pick: P,
                    syncTimeout: o,
                    removeEvent: l,
                    uniqueKey: n
                } = it;
                class h {
                    constructor() {
                        this.category = void 0, this.destroyed = !1, this.formatPrefix = "point", this.id = void 0, this.isNull = !1, this.name = void 0, this.options = void 0, this.percentage = void 0, this.selected = !1, this.series = void 0, this.shapeArgs = void 0, this.total = void 0, this.visible = !0, this.x = void 0
                    }
                    animateBeforeDestroy() {
                        let e = this,
                            t = {
                                x: e.startXPos,
                                opacity: 0
                            },
                            i = e.getGraphicalProps();
                        i.singular.forEach(function(s) {
                            e[s] = e[s].animate(s === "dataLabel" ? {
                                x: e[s].startXPos,
                                y: e[s].startYPos,
                                opacity: 0
                            } : t)
                        }), i.plural.forEach(function(s) {
                            e[s].forEach(function(p) {
                                p.element && p.animate(R({
                                    x: e.startXPos
                                }, p.startYPos ? {
                                    x: p.startXPos,
                                    y: p.startYPos
                                } : {}))
                            })
                        })
                    }
                    applyOptions(e, t) {
                        let i = this.series,
                            s = i.options.pointValKey || i.pointValKey;
                        return R(this, e = h.prototype.optionsToObject.call(this, e)), this.options = this.options ? R(this.options, e) : e, e.group && delete this.group, e.dataLabels && delete this.dataLabels, s && (this.y = h.prototype.getNestedProperty.call(this, s)), this.selected && (this.state = "select"), "name" in this && t === void 0 && i.xAxis && i.xAxis.hasNames && (this.x = i.xAxis.nameToX(this)), this.x === void 0 && i ? t === void 0 ? this.x = i.autoIncrement() : this.x = t : f(e.x) && i.options.relativeXValue && (this.x = i.autoIncrement(e.x)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? "null" : "point", this
                    }
                    destroy() {
                        if (!this.destroyed) {
                            let e = this,
                                t = e.series,
                                i = t.chart,
                                s = t.options.dataSorting,
                                p = i.hoverPoints,
                                x = e.series.chart.renderer.globalAnimation,
                                O = nt(x),
                                d = () => {
                                    for (let A in (e.graphic || e.graphics || e.dataLabel || e.dataLabels) && (l(e), e.destroyElements()), e) delete e[A]
                                };
                            e.legendItem && i.legend.destroyItem(e), p && (e.setState(), S(p, e), p.length || (i.hoverPoints = null)), e === i.hoverPoint && e.onMouseOut(), s && s.enabled ? (this.animateBeforeDestroy(), o(d, O.duration)) : d(), i.pointCount--
                        }
                        this.destroyed = !0
                    }
                    destroyElements(e) {
                        let t = this,
                            i = t.getGraphicalProps(e);
                        i.singular.forEach(function(s) {
                            t[s] = t[s].destroy()
                        }), i.plural.forEach(function(s) {
                            t[s].forEach(function(p) {
                                p && p.element && p.destroy()
                            }), delete t[s]
                        })
                    }
                    firePointEvent(e, t, i) {
                        let s = this,
                            p = this.series,
                            x = p.options;
                        (x.point.events[e] || s.options && s.options.events && s.options.events[e]) && s.importEvents(), e === "click" && x.allowPointSelect && (i = function(O) {
                            !s.destroyed && s.select && s.select(null, O.ctrlKey || O.metaKey || O.shiftKey)
                        }), E(s, e, t, i)
                    }
                    getClassName() {
                        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (this.colorIndex !== void 0 ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "")
                    }
                    getGraphicalProps(e) {
                        let t, i, s = this,
                            p = [],
                            x = {
                                singular: [],
                                plural: []
                            };
                        for ((e = e || {
                            graphic: 1,
                            dataLabel: 1
                        }).graphic && p.push("graphic", "connector"), e.dataLabel && p.push("dataLabel", "dataLabelPath", "dataLabelUpper"), i = p.length; i--;) s[t = p[i]] && x.singular.push(t);
                        return ["graphic", "dataLabel"].forEach(function(O) {
                            let d = O + "s";
                            e[O] && s[d] && x.plural.push(d)
                        }), x
                    }
                    getLabelConfig() {
                        return {
                            x: this.category,
                            y: this.y,
                            color: this.color,
                            colorIndex: this.colorIndex,
                            key: this.name || this.category,
                            series: this.series,
                            point: this,
                            percentage: this.percentage,
                            total: this.total || this.stackTotal
                        }
                    }
                    getNestedProperty(e) {
                        return e ? e.indexOf("custom.") === 0 ? M(e, this.options) : this[e] : void 0
                    }
                    getZone() {
                        let e = this.series,
                            t = e.zones,
                            i = e.zoneAxis || "y",
                            s, p = 0;
                        for (s = t[0]; this[i] >= s.value;) s = t[++p];
                        return this.nonZonedColor || (this.nonZonedColor = this.color), s && s.color && !this.options.color ? this.color = s.color : this.color = this.nonZonedColor, s
                    }
                    hasNewShapeType() {
                        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType
                    }
                    init(e, t, i) {
                        return this.series = e, this.applyOptions(t, i), this.id = U(this.id) ? this.id : n(), this.resolveColor(), e.chart.pointCount++, E(this, "afterInit"), this
                    }
                    isValid() {
                        return (f(this.x) || this.x instanceof Date) && f(this.y)
                    }
                    optionsToObject(e) {
                        let t = this.series,
                            i = t.options.keys,
                            s = i || t.pointArrayMap || ["y"],
                            p = s.length,
                            x = {},
                            O, d = 0,
                            A = 0;
                        if (f(e) || e === null) x[s[0]] = e;
                        else if (k(e))
                            for (!i && e.length > p && ((O = typeof e[0]) == "string" ? x.name = e[0] : O === "number" && (x.x = e[0]), d++); A < p;) i && e[d] === void 0 || (s[A].indexOf(".") > 0 ? h.prototype.setNestedProperty(x, e[d], s[A]) : x[s[A]] = e[d]), d++, A++;
                        else typeof e == "object" && (x = e, e.dataLabels && (t.hasDataLabels = () => !0), e.marker && (t._hasPointMarkers = !0));
                        return x
                    }
                    pos(e, t = this.plotY) {
                        if (!this.destroyed) {
                            let {
                                plotX: i,
                                series: s
                            } = this, {
                                chart: p,
                                xAxis: x,
                                yAxis: O
                            } = s, d = 0, A = 0;
                            if (f(i) && f(t)) return e && (d = x ? x.pos : p.plotLeft, A = O ? O.pos : p.plotTop), p.inverted && x && O ? [O.len - t + A, x.len - i + d] : [i + d, t + A]
                        }
                    }
                    resolveColor() {
                        let e = this.series,
                            t = e.chart.options.chart,
                            i = e.chart.styledMode,
                            s, p, x = t.colorCount,
                            O;
                        delete this.nonZonedColor, e.options.colorByPoint ? (i || (s = (p = e.options.colors || e.chart.options.colors)[e.colorCounter], x = p.length), O = e.colorCounter, e.colorCounter++, e.colorCounter === x && (e.colorCounter = 0)) : (i || (s = e.color), O = e.colorIndex), this.colorIndex = P(this.options.colorIndex, O), this.color = P(this.options.color, s)
                    }
                    setNestedProperty(e, t, i) {
                        return i.split(".").reduce(function(p, x, O, d) {
                            let A = d.length - 1 === O;
                            return p[x] = A ? t : m(p[x], !0) ? p[x] : {}, p[x]
                        }, e), e
                    }
                    shouldDraw() {
                        return !this.isNull
                    }
                    tooltipFormatter(e) {
                        let t = this.series,
                            i = t.tooltipOptions,
                            s = P(i.valueDecimals, ""),
                            p = i.valuePrefix || "",
                            x = i.valueSuffix || "";
                        return t.chart.styledMode && (e = t.chart.tooltip.styledModeFormat(e)), (t.pointArrayMap || ["y"]).forEach(function(O) {
                            O = "{point." + O, (p || x) && (e = e.replace(RegExp(O + "}", "g"), p + O + "}" + x)), e = e.replace(RegExp(O + "}", "g"), O + ":,." + s + "f}")
                        }), K(e, {
                            point: this,
                            series: this.series
                        }, t.chart)
                    }
                    update(e, t, i, s) {
                        let p, x = this,
                            O = x.series,
                            d = x.graphic,
                            A = O.chart,
                            L = O.options;

                        function V() {
                            x.applyOptions(e);
                            let B = d && x.hasMockGraphic,
                                r = x.y === null ? !B : B;
                            d && r && (x.graphic = d.destroy(), delete x.hasMockGraphic), m(e, !0) && (d && d.element && e && e.marker && e.marker.symbol !== void 0 && (x.graphic = d.destroy()), e != null && e.dataLabels && x.dataLabel && (x.dataLabel = x.dataLabel.destroy())), p = x.index, O.updateParallelArrays(x, p), L.data[p] = m(L.data[p], !0) || m(e, !0) ? x.options : P(e, L.data[p]), O.isDirty = O.isDirtyData = !0, !O.fixedBox && O.hasCartesianSeries && (A.isDirtyBox = !0), L.legendType === "point" && (A.isDirtyLegend = !0), t && A.redraw(i)
                        }
                        t = P(t, !0), s === !1 ? V() : x.firePointEvent("update", {
                            options: e
                        }, V)
                    }
                    remove(e, t) {
                        this.series.removePoint(this.series.data.indexOf(this), e, t)
                    }
                    select(e, t) {
                        let i = this,
                            s = i.series,
                            p = s.chart;
                        e = P(e, !i.selected), this.selectedStaging = e, i.firePointEvent(e ? "select" : "unselect", {
                            accumulate: t
                        }, function() {
                            i.selected = i.options.selected = e, s.options.data[s.data.indexOf(i)] = i.options, i.setState(e && "select"), t || p.getSelectedPoints().forEach(function(x) {
                                let O = x.series;
                                x.selected && x !== i && (x.selected = x.options.selected = !1, O.options.data[O.data.indexOf(x)] = x.options, x.setState(p.hoverPoints && O.options.inactiveOtherPoints ? "inactive" : ""), x.firePointEvent("unselect"))
                            })
                        }), delete this.selectedStaging
                    }
                    onMouseOver(e) {
                        let t = this.series,
                            i = t.chart,
                            s = i.pointer;
                        e = e ? s.normalize(e) : s.getChartCoordinatesFromPoint(this, i.inverted), s.runPointActions(e, this)
                    }
                    onMouseOut() {
                        let e = this.series.chart;
                        this.firePointEvent("mouseOut"), this.series.options.inactiveOtherPoints || (e.hoverPoints || []).forEach(function(t) {
                            t.setState()
                        }), e.hoverPoints = e.hoverPoint = null
                    }
                    importEvents() {
                        if (!this.hasImportedEvents) {
                            let e = this,
                                t = C(e.series.options.point, e.options),
                                i = t.events;
                            e.events = i, T(i, function(s, p) {
                                g(s) && Z(e, p, s)
                            }), this.hasImportedEvents = !0
                        }
                    }
                    setState(e, t) {
                        let i = this.series,
                            s = this.state,
                            p = i.options.states[e || "normal"] || {},
                            x = ot.plotOptions[i.type].marker && i.options.marker,
                            O = x && x.enabled === !1,
                            d = x && x.states && x.states[e || "normal"] || {},
                            A = d.enabled === !1,
                            L = this.marker || {},
                            V = i.chart,
                            B = x && i.markerAttribs,
                            r = i.halo,
                            c, b, N, z = i.stateMarkerGraphic,
                            W;
                        if ((e = e || "") === this.state && !t || this.selected && e !== "select" || p.enabled === !1 || e && (A || O && d.enabled === !1) || e && L.states && L.states[e] && L.states[e].enabled === !1) return;
                        if (this.state = e, B && (c = i.markerAttribs(this, e)), this.graphic && !this.hasMockGraphic) {
                            if (s && this.graphic.removeClass("highcharts-point-" + s), e && this.graphic.addClass("highcharts-point-" + e), !V.styledMode) {
                                b = i.pointAttribs(this, e), N = P(V.options.chart.animation, p.animation);
                                let I = b.opacity;
                                i.options.inactiveOtherPoints && f(I) && (this.dataLabels || []).forEach(function(w) {
                                    w && !w.hasClass("highcharts-data-label-hidden") && (w.animate({
                                        opacity: I
                                    }, N), w.connector && w.connector.animate({
                                        opacity: I
                                    }, N))
                                }), this.graphic.animate(b, N)
                            }
                            c && this.graphic.animate(c, P(V.options.chart.animation, d.animation, x.animation)), z && z.hide()
                        } else e && d && (W = L.symbol || i.symbol, z && z.currentSymbol !== W && (z = z.destroy()), c && (z ? z[t ? "animate" : "attr"]({
                            x: c.x,
                            y: c.y
                        }) : W && (i.stateMarkerGraphic = z = V.renderer.symbol(W, c.x, c.y, c.width, c.height).add(i.markerGroup), z.currentSymbol = W)), !V.styledMode && z && this.state !== "inactive" && z.attr(i.pointAttribs(this, e))), z && (z[e && this.isInside ? "show" : "hide"](), z.element.point = this, z.addClass(this.getClassName(), !0));
                        let a = p.halo,
                            v = this.graphic || z,
                            y = v && v.visibility || "inherit";
                        a && a.size && v && y !== "hidden" && !this.isCluster ? (r || (i.halo = r = V.renderer.path().add(v.parentGroup)), r.show()[t ? "animate" : "attr"]({
                            d: this.haloPath(a.size)
                        }), r.attr({
                            class: "highcharts-halo highcharts-color-" + P(this.colorIndex, i.colorIndex) + (this.className ? " " + this.className : ""),
                            visibility: y,
                            zIndex: -1
                        }), r.point = this, V.styledMode || r.attr(R({
                            fill: this.color || i.color,
                            "fill-opacity": a.opacity
                        }, et.filterUserAttributes(a.attributes || {})))) : r && r.point && r.point.haloPath && r.animate({
                            d: r.point.haloPath(0)
                        }, null, r.hide), E(this, "afterSetState", {
                            state: e
                        })
                    }
                    haloPath(e) {
                        let t = this.pos();
                        return t ? this.series.chart.renderer.symbols.circle(Math.floor(t[0]) - e, t[1] - e, 2 * e, 2 * e) : []
                    }
                }
                return h
            }), ft(Y, "Core/Pointer.js", [Y["Core/Color/Color.js"], Y["Core/Globals.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                let {
                    parse: rt
                } = et, {
                    charts: it,
                    noop: nt
                } = Q, {
                    addEvent: ot,
                    attr: K,
                    css: Z,
                    defined: U,
                    extend: S,
                    find: R,
                    fireEvent: E,
                    isNumber: M,
                    isObject: k,
                    objectEach: g,
                    offset: f,
                    pick: m,
                    splat: C
                } = ht;
                class T {
                    constructor(o, l) {
                        this.lastValidTouch = {}, this.pinchDown = [], this.runChartClick = !1, this.eventsToUnbind = [], this.chart = o, this.hasDragged = !1, this.options = l, this.init(o, l)
                    }
                    applyInactiveState(o) {
                        let l = [],
                            n;
                        (o || []).forEach(function(h) {
                            n = h.series, l.push(n), n.linkedParent && l.push(n.linkedParent), n.linkedSeries && (l = l.concat(n.linkedSeries)), n.navigatorSeries && l.push(n.navigatorSeries)
                        }), this.chart.series.forEach(function(h) {
                            l.indexOf(h) === -1 ? h.setState("inactive", !0) : h.options.inactiveOtherPoints && h.setAllPointsToState("inactive")
                        })
                    }
                    destroy() {
                        let o = this;
                        this.eventsToUnbind.forEach(l => l()), this.eventsToUnbind = [], !Q.chartCount && (T.unbindDocumentMouseUp && (T.unbindDocumentMouseUp = T.unbindDocumentMouseUp()), T.unbindDocumentTouchEnd && (T.unbindDocumentTouchEnd = T.unbindDocumentTouchEnd())), clearInterval(o.tooltipTimeout), g(o, function(l, n) {
                            o[n] = void 0
                        })
                    }
                    getSelectionMarkerAttrs(o, l) {
                        let n = {
                            args: {
                                chartX: o,
                                chartY: l
                            },
                            attrs: {},
                            shapeType: "rect"
                        };
                        return E(this, "getSelectionMarkerAttrs", n, h => {
                            let u, {
                                    chart: e,
                                    mouseDownX: t = 0,
                                    mouseDownY: i = 0,
                                    zoomHor: s,
                                    zoomVert: p
                                } = this,
                                x = h.attrs;
                            x.x = e.plotLeft, x.y = e.plotTop, x.width = s ? 1 : e.plotWidth, x.height = p ? 1 : e.plotHeight, s && (u = o - t, x.width = Math.abs(u), x.x = (u > 0 ? 0 : u) + t), p && (u = l - i, x.height = Math.abs(u), x.y = (u > 0 ? 0 : u) + i)
                        }), n
                    }
                    drag(o) {
                        let l = this.chart,
                            n = l.options.chart,
                            h = l.plotLeft,
                            u = l.plotTop,
                            e = l.plotWidth,
                            t = l.plotHeight,
                            i = this.mouseDownX || 0,
                            s = this.mouseDownY || 0,
                            p = k(n.panning) ? n.panning && n.panning.enabled : n.panning,
                            x = n.panKey && o[n.panKey + "Key"],
                            O = o.chartX,
                            d = o.chartY,
                            A, L = this.selectionMarker;
                        if ((!L || !L.touch) && (O < h ? O = h : O > h + e && (O = h + e), d < u ? d = u : d > u + t && (d = u + t), this.hasDragged = Math.sqrt(Math.pow(i - O, 2) + Math.pow(s - d, 2)), this.hasDragged > 10)) {
                            A = l.isInsidePlot(i - h, s - u, {
                                visiblePlotOnly: !0
                            });
                            let {
                                shapeType: V,
                                attrs: B
                            } = this.getSelectionMarkerAttrs(O, d);
                            (l.hasCartesianSeries || l.mapView) && (this.zoomX || this.zoomY) && A && !x && !L && (this.selectionMarker = L = l.renderer[V](), L.attr({
                                class: "highcharts-selection-marker",
                                zIndex: 7
                            }).add(), l.styledMode || L.attr({
                                fill: n.selectionMarkerFill || rt("#334eff").setOpacity(.25).get()
                            })), L && L.attr(B), A && !L && p && l.pan(o, n.panning)
                        }
                    }
                    dragStart(o) {
                        let l = this.chart;
                        l.mouseIsDown = o.type, l.cancelClick = !1, l.mouseDownX = this.mouseDownX = o.chartX, l.mouseDownY = this.mouseDownY = o.chartY
                    }
                    getSelectionBox(o) {
                        let l = {
                            args: {
                                marker: o
                            },
                            result: {}
                        };
                        return E(this, "getSelectionBox", l, n => {
                            n.result = {
                                x: o.attr ? +o.attr("x") : o.x,
                                y: o.attr ? +o.attr("y") : o.y,
                                width: o.attr ? o.attr("width") : o.width,
                                height: o.attr ? o.attr("height") : o.height
                            }
                        }), l.result
                    }
                    drop(o) {
                        let l = this,
                            n = this.chart,
                            h = this.hasPinched;
                        if (this.selectionMarker) {
                            let {
                                x: u,
                                y: e,
                                width: t,
                                height: i
                            } = this.getSelectionBox(this.selectionMarker), s = {
                                originalEvent: o,
                                xAxis: [],
                                yAxis: [],
                                x: u,
                                y: e,
                                width: t,
                                height: i
                            }, p = !!n.mapView;
                            (this.hasDragged || h) && (n.axes.forEach(function(x) {
                                if (x.zoomEnabled && U(x.min) && (h || l[{
                                    xAxis: "zoomX",
                                    yAxis: "zoomY"
                                } [x.coll]]) && M(u) && M(e) && M(t) && M(i)) {
                                    let O = x.horiz,
                                        d = o.type === "touchend" ? x.minPixelPadding : 0,
                                        A = x.toValue((O ? u : e) + d),
                                        L = x.toValue((O ? u + t : e + i) - d);
                                    s[x.coll].push({
                                        axis: x,
                                        min: Math.min(A, L),
                                        max: Math.max(A, L)
                                    }), p = !0
                                }
                            }), p && E(n, "selection", s, function(x) {
                                n.zoom(S(x, h ? {
                                    animation: !1
                                } : null))
                            })), M(n.index) && (this.selectionMarker = this.selectionMarker.destroy()), h && this.scaleGroups()
                        }
                        n && M(n.index) && (Z(n.container, {
                            cursor: n._cursor
                        }), n.cancelClick = +this.hasDragged > 10, n.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = [])
                    }
                    findNearestKDPoint(o, l, n) {
                        let h;
                        return o.forEach(function(u) {
                            let e = u.noSharedTooltip && l,
                                t = !e && 0 > u.options.findNearestPointBy.indexOf("y"),
                                i = u.searchPoint(n, t);
                            k(i, !0) && i.series && (!k(h, !0) || function(s, p) {
                                let x = s.distX - p.distX,
                                    O = s.dist - p.dist,
                                    d = (p.series.group && p.series.group.zIndex) - (s.series.group && s.series.group.zIndex);
                                return x !== 0 && l ? x : O !== 0 ? O : d !== 0 ? d : s.series.index > p.series.index ? -1 : 1
                            }(h, i) > 0) && (h = i)
                        }), h
                    }
                    getChartCoordinatesFromPoint(o, l) {
                        let n = o.series,
                            h = n.xAxis,
                            u = n.yAxis,
                            e = o.shapeArgs;
                        if (h && u) {
                            let t = m(o.clientX, o.plotX),
                                i = o.plotY || 0;
                            return o.isNode && e && M(e.x) && M(e.y) && (t = e.x, i = e.y), l ? {
                                chartX: u.len + u.pos - i,
                                chartY: h.len + h.pos - t
                            } : {
                                chartX: t + h.pos,
                                chartY: i + u.pos
                            }
                        }
                        if (e && e.x && e.y) return {
                            chartX: e.x,
                            chartY: e.y
                        }
                    }
                    getChartPosition() {
                        if (this.chartPosition) return this.chartPosition;
                        let {
                            container: o
                        } = this.chart, l = f(o);
                        this.chartPosition = {
                            left: l.left,
                            top: l.top,
                            scaleX: 1,
                            scaleY: 1
                        };
                        let n = o.offsetWidth,
                            h = o.offsetHeight;
                        return n > 2 && h > 2 && (this.chartPosition.scaleX = l.width / n, this.chartPosition.scaleY = l.height / h), this.chartPosition
                    }
                    getCoordinates(o) {
                        let l = {
                            xAxis: [],
                            yAxis: []
                        };
                        return this.chart.axes.forEach(function(n) {
                            l[n.isXAxis ? "xAxis" : "yAxis"].push({
                                axis: n,
                                value: n.toValue(o[n.horiz ? "chartX" : "chartY"])
                            })
                        }), l
                    }
                    getHoverData(o, l, n, h, u, e) {
                        let t = [],
                            i = function(A) {
                                return A.visible && !(!u && A.directTouch) && m(A.options.enableMouseTracking, !0)
                            },
                            s = l,
                            p, x = {
                                chartX: e ? e.chartX : void 0,
                                chartY: e ? e.chartY : void 0,
                                shared: u
                            };
                        E(this, "beforeGetHoverData", x), p = s && !s.stickyTracking ? [s] : n.filter(A => A.stickyTracking && (x.filter || i)(A));
                        let d = h && o || !e ? o : this.findNearestKDPoint(p, u, e);
                        return s = d && d.series, d && (u && !s.noSharedTooltip ? (p = n.filter(function(A) {
                            return x.filter ? x.filter(A) : i(A) && !A.noSharedTooltip
                        })).forEach(function(A) {
                            let L = R(A.points, function(V) {
                                return V.x === d.x && !V.isNull
                            });
                            k(L) && (A.boosted && A.boost && (L = A.boost.getPoint(L)), t.push(L))
                        }) : t.push(d)), E(this, "afterGetHoverData", x = {
                            hoverPoint: d
                        }), {
                            hoverPoint: x.hoverPoint,
                            hoverSeries: s,
                            hoverPoints: t
                        }
                    }
                    getPointFromEvent(o) {
                        let l = o.target,
                            n;
                        for (; l && !n;) n = l.point, l = l.parentNode;
                        return n
                    }
                    onTrackerMouseOut(o) {
                        let l = this.chart,
                            n = o.relatedTarget,
                            h = l.hoverSeries;
                        this.isDirectTouch = !1, !h || !n || h.stickyTracking || this.inClass(n, "highcharts-tooltip") || this.inClass(n, "highcharts-series-" + h.index) && this.inClass(n, "highcharts-tracker") || h.onMouseOut()
                    }
                    inClass(o, l) {
                        let n = o,
                            h;
                        for (; n;) {
                            if (h = K(n, "class")) {
                                if (h.indexOf(l) !== -1) return !0;
                                if (h.indexOf("highcharts-container") !== -1) return !1
                            }
                            n = n.parentElement
                        }
                    }
                    init(o, l) {
                        this.options = l, this.chart = o, this.runChartClick = !!(l.chart.events && l.chart.events.click), this.pinchDown = [], this.lastValidTouch = {}, this.setDOMEvents(), E(this, "afterInit")
                    }
                    normalize(o, l) {
                        let n = o.touches,
                            h = n ? n.length ? n.item(0) : m(n.changedTouches, o.changedTouches)[0] : o;
                        l || (l = this.getChartPosition());
                        let u = h.pageX - l.left,
                            e = h.pageY - l.top;
                        return S(o, {
                            chartX: Math.round(u /= l.scaleX),
                            chartY: Math.round(e /= l.scaleY)
                        })
                    }
                    onContainerClick(o) {
                        let l = this.chart,
                            n = l.hoverPoint,
                            h = this.normalize(o),
                            u = l.plotLeft,
                            e = l.plotTop;
                        !l.cancelClick && (n && this.inClass(h.target, "highcharts-tracker") ? (E(n.series, "click", S(h, {
                            point: n
                        })), l.hoverPoint && n.firePointEvent("click", h)) : (S(h, this.getCoordinates(h)), l.isInsidePlot(h.chartX - u, h.chartY - e, {
                            visiblePlotOnly: !0
                        }) && E(l, "click", h)))
                    }
                    onContainerMouseDown(o) {
                        let l = (1 & (o.buttons || o.button)) == 1;
                        o = this.normalize(o), Q.isFirefox && o.button !== 0 && this.onContainerMouseMove(o), (o.button === void 0 || l) && (this.zoomOption(o), l && o.preventDefault && o.preventDefault(), this.dragStart(o))
                    }
                    onContainerMouseLeave(o) {
                        let l = it[m(T.hoverChartIndex, -1)];
                        o = this.normalize(o), this.onContainerMouseMove(o), l && o.relatedTarget && !this.inClass(o.relatedTarget, "highcharts-tooltip") && (l.pointer.reset(), l.pointer.chartPosition = void 0)
                    }
                    onContainerMouseEnter(o) {
                        delete this.chartPosition
                    }
                    onContainerMouseMove(o) {
                        let l = this.chart,
                            n = l.tooltip,
                            h = this.normalize(o);
                        this.setHoverChartIndex(o), (l.mouseIsDown === "mousedown" || this.touchSelect(h)) && this.drag(h), !l.openMenu && (this.inClass(h.target, "highcharts-tracker") || l.isInsidePlot(h.chartX - l.plotLeft, h.chartY - l.plotTop, {
                            visiblePlotOnly: !0
                        })) && !(n && n.shouldStickOnContact(h)) && (this.inClass(h.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(h))
                    }
                    onDocumentTouchEnd(o) {
                        let l = it[m(T.hoverChartIndex, -1)];
                        l && l.pointer.drop(o)
                    }
                    onContainerTouchMove(o) {
                        this.touchSelect(o) ? this.onContainerMouseMove(o) : this.touch(o)
                    }
                    onContainerTouchStart(o) {
                        this.touchSelect(o) ? this.onContainerMouseDown(o) : (this.zoomOption(o), this.touch(o, !0))
                    }
                    onDocumentMouseMove(o) {
                        let l = this.chart,
                            n = l.tooltip,
                            h = this.chartPosition,
                            u = this.normalize(o, h);
                        !h || l.isInsidePlot(u.chartX - l.plotLeft, u.chartY - l.plotTop, {
                            visiblePlotOnly: !0
                        }) || n && n.shouldStickOnContact(u) || this.inClass(u.target, "highcharts-tracker") || this.reset()
                    }
                    onDocumentMouseUp(o) {
                        let l = it[m(T.hoverChartIndex, -1)];
                        l && l.pointer.drop(o)
                    }
                    pinch(o) {
                        let l = this,
                            n = l.chart,
                            h = l.pinchDown,
                            u = o.touches || [],
                            e = u.length,
                            t = l.lastValidTouch,
                            i = l.hasZoom,
                            s = {},
                            p = e === 1 && (l.inClass(o.target, "highcharts-tracker") && n.runTrackerClick || l.runChartClick),
                            x = {},
                            O = l.chart.tooltip,
                            d = e === 1 && m(O && O.options.followTouchMove, !0),
                            A = l.selectionMarker;
                        e > 1 ? l.initiated = !0 : d && (l.initiated = !1), i && l.initiated && !p && o.cancelable !== !1 && o.preventDefault(), [].map.call(u, function(L) {
                            return l.normalize(L)
                        }), o.type === "touchstart" ? ([].forEach.call(u, function(L, V) {
                            h[V] = {
                                chartX: L.chartX,
                                chartY: L.chartY
                            }
                        }), t.x = [h[0].chartX, h[1] && h[1].chartX], t.y = [h[0].chartY, h[1] && h[1].chartY], n.axes.forEach(function(L) {
                            if (L.zoomEnabled) {
                                let V = n.bounds[L.horiz ? "h" : "v"],
                                    B = L.minPixelPadding,
                                    r = L.toPixels(Math.min(m(L.options.min, L.dataMin), L.dataMin)),
                                    c = L.toPixels(Math.max(m(L.options.max, L.dataMax), L.dataMax)),
                                    b = Math.min(r, c),
                                    N = Math.max(r, c);
                                V.min = Math.min(L.pos, b - B), V.max = Math.max(L.pos + L.len, N + B)
                            }
                        }), l.res = !0) : d ? this.runPointActions(l.normalize(o)) : h.length && (E(n, "touchpan", {
                            originalEvent: o
                        }, () => {
                            A || (l.selectionMarker = A = S({
                                destroy: nt,
                                touch: !0
                            }, n.plotBox)), l.pinchTranslate(h, u, s, A, x, t), l.hasPinched = i, l.scaleGroups(s, x)
                        }), l.res && (l.res = !1, this.reset(!1, 0)))
                    }
                    pinchTranslate(o, l, n, h, u, e) {
                        this.zoomHor && this.pinchTranslateDirection(!0, o, l, n, h, u, e), this.zoomVert && this.pinchTranslateDirection(!1, o, l, n, h, u, e)
                    }
                    pinchTranslateDirection(o, l, n, h, u, e, t, i) {
                        let s = this.chart,
                            p = o ? "x" : "y",
                            x = o ? "X" : "Y",
                            O = "chart" + x,
                            d = o ? "width" : "height",
                            A = s["plot" + (o ? "Left" : "Top")],
                            L = s.inverted,
                            V = s.bounds[o ? "h" : "v"],
                            B = l.length === 1,
                            r = l[0][O],
                            c = !B && l[1][O],
                            b = function() {
                                typeof y == "number" && Math.abs(r - c) > 20 && (a = i || Math.abs(v - y) / Math.abs(r - c)), W = (A - v) / a + r, N = s["plot" + (o ? "Width" : "Height")] / a
                            },
                            N, z, W, a = i || 1,
                            v = n[0][O],
                            y = !B && n[1][O],
                            I;
                        b(), (z = W) < V.min ? (z = V.min, I = !0) : z + N > V.max && (z = V.max - N, I = !0), I ? (v -= .8 * (v - t[p][0]), typeof y == "number" && (y -= .8 * (y - t[p][1])), b()) : t[p] = [v, y], L || (e[p] = W - A, e[d] = N);
                        let w = L ? o ? "scaleY" : "scaleX" : "scale" + x,
                            G = L ? 1 / a : a;
                        u[d] = N, u[p] = z, h[w] = a * (L && !o ? -1 : 1), h["translate" + x] = G * A + (v - G * r)
                    }
                    reset(o, l) {
                        let n = this.chart,
                            h = n.hoverSeries,
                            u = n.hoverPoint,
                            e = n.hoverPoints,
                            t = n.tooltip,
                            i = t && t.shared ? e : u;
                        o && i && C(i).forEach(function(s) {
                            s.series.isCartesian && s.plotX === void 0 && (o = !1)
                        }), o ? t && i && C(i).length && (t.refresh(i), t.shared && e ? e.forEach(function(s) {
                            s.setState(s.state, !0), s.series.isCartesian && (s.series.xAxis.crosshair && s.series.xAxis.drawCrosshair(null, s), s.series.yAxis.crosshair && s.series.yAxis.drawCrosshair(null, s))
                        }) : u && (u.setState(u.state, !0), n.axes.forEach(function(s) {
                            s.crosshair && u.series[s.coll] === s && s.drawCrosshair(null, u)
                        }))) : (u && u.onMouseOut(), e && e.forEach(function(s) {
                            s.setState()
                        }), h && h.onMouseOut(), t && t.hide(l), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), n.axes.forEach(function(s) {
                            s.hideCrosshair()
                        }), this.hoverX = n.hoverPoints = n.hoverPoint = null)
                    }
                    runPointActions(o, l, n) {
                        let h = this.chart,
                            u = h.series,
                            e = h.tooltip && h.tooltip.options.enabled ? h.tooltip : void 0,
                            t = !!e && e.shared,
                            i = l || h.hoverPoint,
                            s = i && i.series || h.hoverSeries,
                            p = (!o || o.type !== "touchmove") && (!!l || s && s.directTouch && this.isDirectTouch),
                            x = this.getHoverData(i, s, u, p, t, o);
                        i = x.hoverPoint, s = x.hoverSeries;
                        let O = x.hoverPoints,
                            d = s && s.tooltipOptions.followPointer && !s.tooltipOptions.split,
                            A = t && s && !s.noSharedTooltip;
                        if (i && (n || i !== h.hoverPoint || e && e.isHidden)) {
                            if ((h.hoverPoints || []).forEach(function(L) {
                                O.indexOf(L) === -1 && L.setState()
                            }), h.hoverSeries !== s && s.onMouseOver(), this.applyInactiveState(O), (O || []).forEach(function(L) {
                                L.setState("hover")
                            }), h.hoverPoint && h.hoverPoint.firePointEvent("mouseOut"), !i.series) return;
                            h.hoverPoints = O, h.hoverPoint = i, i.firePointEvent("mouseOver", void 0, () => {
                                e && i && e.refresh(A ? O : i, o)
                            })
                        } else if (d && e && !e.isHidden) {
                            let L = e.getAnchor([{}], o);
                            h.isInsidePlot(L[0], L[1], {
                                visiblePlotOnly: !0
                            }) && e.updatePosition({
                                plotX: L[0],
                                plotY: L[1]
                            })
                        }
                        this.unDocMouseMove || (this.unDocMouseMove = ot(h.container.ownerDocument, "mousemove", function(L) {
                            let V = it[T.hoverChartIndex];
                            V && V.pointer.onDocumentMouseMove(L)
                        }), this.eventsToUnbind.push(this.unDocMouseMove)), h.axes.forEach(function(L) {
                            let V, B = m((L.crosshair || {}).snap, !0);
                            !B || (V = h.hoverPoint) && V.series[L.coll] === L || (V = R(O, r => r.series && r.series[L.coll] === L)), V || !B ? L.drawCrosshair(o, V) : L.hideCrosshair()
                        })
                    }
                    scaleGroups(o, l) {
                        let n = this.chart;
                        n.series.forEach(function(h) {
                            let u = o || h.getPlotBox("series");
                            h.group && (h.xAxis && h.xAxis.zoomEnabled || n.mapView) && (h.group.attr(u), h.markerGroup && (h.markerGroup.attr(o || h.getPlotBox("marker")), h.markerGroup.clip(l ? n.clipRect : null)), h.dataLabelsGroup && h.dataLabelsGroup.attr(u))
                        }), n.clipRect.attr(l || n.clipBox)
                    }
                    setDOMEvents() {
                        let o = this.chart.container,
                            l = o.ownerDocument;
                        o.onmousedown = this.onContainerMouseDown.bind(this), o.onmousemove = this.onContainerMouseMove.bind(this), o.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(ot(o, "mouseenter", this.onContainerMouseEnter.bind(this))), this.eventsToUnbind.push(ot(o, "mouseleave", this.onContainerMouseLeave.bind(this))), T.unbindDocumentMouseUp || (T.unbindDocumentMouseUp = ot(l, "mouseup", this.onDocumentMouseUp.bind(this)));
                        let n = this.chart.renderTo.parentElement;
                        for (; n && n.tagName !== "BODY";) this.eventsToUnbind.push(ot(n, "scroll", () => {
                            delete this.chartPosition
                        })), n = n.parentElement;
                        Q.hasTouch && (this.eventsToUnbind.push(ot(o, "touchstart", this.onContainerTouchStart.bind(this), {
                            passive: !1
                        })), this.eventsToUnbind.push(ot(o, "touchmove", this.onContainerTouchMove.bind(this), {
                            passive: !1
                        })), T.unbindDocumentTouchEnd || (T.unbindDocumentTouchEnd = ot(l, "touchend", this.onDocumentTouchEnd.bind(this), {
                            passive: !1
                        })))
                    }
                    setHoverChartIndex(o) {
                        let l = this.chart,
                            n = Q.charts[m(T.hoverChartIndex, -1)];
                        n && n !== l && n.pointer.onContainerMouseLeave(o || {
                            relatedTarget: l.container
                        }), n && n.mouseIsDown || (T.hoverChartIndex = l.index)
                    }
                    touch(o, l) {
                        let n, h, u = this.chart;
                        this.setHoverChartIndex(), o.touches.length === 1 ? (o = this.normalize(o), u.isInsidePlot(o.chartX - u.plotLeft, o.chartY - u.plotTop, {
                            visiblePlotOnly: !0
                        }) && !u.openMenu ? (l && this.runPointActions(o), o.type === "touchmove" && (n = !!(h = this.pinchDown)[0] && Math.sqrt(Math.pow(h[0].chartX - o.chartX, 2) + Math.pow(h[0].chartY - o.chartY, 2)) >= 4), m(n, !0) && this.pinch(o)) : l && this.reset()) : o.touches.length === 2 && this.pinch(o)
                    }
                    touchSelect(o) {
                        return !!(this.chart.zooming.singleTouch && o.touches && o.touches.length === 1)
                    }
                    zoomOption(o) {
                        let l = this.chart,
                            n = (l.options.chart, l.inverted),
                            h = l.zooming.type || "",
                            u, e;
                        /touch/.test(o.type) && (h = m(l.zooming.pinchType, h)), this.zoomX = u = /x/.test(h), this.zoomY = e = /y/.test(h), this.zoomHor = u && !n || e && n, this.zoomVert = e && !n || u && n, this.hasZoom = u || e
                    }
                }
                return function(P) {
                    let o = [],
                        l = [];
                    P.compose = function(n) {
                        ht.pushUnique(l, n) && ot(n, "beforeRender", function() {
                            this.pointer = new P(this, this.options)
                        })
                    }, P.dissolve = function() {
                        for (let n = 0, h = o.length; n < h; ++n) o[n]();
                        o.length = 0
                    }
                }(T || (T = {})), T
            }), ft(Y, "Core/Legend/Legend.js", [Y["Core/Animation/AnimationUtilities.js"], Y["Core/Templating.js"], Y["Core/Globals.js"], Y["Core/Series/Point.js"], Y["Core/Renderer/RendererUtilities.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt, it, nt) {
                let {
                    animObject: ot,
                    setAnimation: K
                } = et, {
                    format: Z
                } = Q, {
                    marginNames: U
                } = ht, {
                    distribute: S
                } = it, {
                    addEvent: R,
                    createElement: E,
                    css: M,
                    defined: k,
                    discardElement: g,
                    find: f,
                    fireEvent: m,
                    isNumber: C,
                    merge: T,
                    pick: P,
                    relativeLength: o,
                    stableSort: l,
                    syncTimeout: n
                } = nt;
                class h {
                    constructor(e, t) {
                        this.allItems = [], this.box = void 0, this.contentGroup = void 0, this.display = !1, this.group = void 0, this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.options = void 0, this.padding = 0, this.pages = [], this.proximate = !1, this.scrollGroup = void 0, this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = e, this.init(e, t)
                    }
                    init(e, t) {
                        this.chart = e, this.setOptions(t), t.enabled && (this.render(), R(this.chart, "endResize", function() {
                            this.legend.positionCheckboxes()
                        })), R(this.chart, "render", () => {
                            this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems())
                        })
                    }
                    setOptions(e) {
                        let t = P(e.padding, 8);
                        this.options = e, this.chart.styledMode || (this.itemStyle = e.itemStyle, this.itemHiddenStyle = T(this.itemStyle, e.itemHiddenStyle)), this.itemMarginTop = e.itemMarginTop, this.itemMarginBottom = e.itemMarginBottom, this.padding = t, this.initialItemY = t - 5, this.symbolWidth = P(e.symbolWidth, 16), this.pages = [], this.proximate = e.layout === "proximate" && !this.chart.inverted, this.baseline = void 0
                    }
                    update(e, t) {
                        let i = this.chart;
                        this.setOptions(T(!0, this.options, e)), this.destroy(), i.isDirtyLegend = i.isDirtyBox = !0, P(t, !0) && i.redraw(), m(this, "afterUpdate", {
                            redraw: t
                        })
                    }
                    colorizeItem(e, t) {
                        let {
                            group: i,
                            label: s,
                            line: p,
                            symbol: x
                        } = e.legendItem || {};
                        if (i && i[t ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"), !this.chart.styledMode) {
                            let {
                                itemHiddenStyle: O
                            } = this, d = O.color, A = t && e.color || d, L = e.options && e.options.marker, V = {
                                fill: A
                            };
                            s == null || s.css(T(t ? this.itemStyle : O)), p == null || p.attr({
                                stroke: A
                            }), x && (L && x.isMarker && (V = e.pointAttribs(), t || (V.stroke = V.fill = d)), x.attr(V))
                        }
                        m(this, "afterColorizeItem", {
                            item: e,
                            visible: t
                        })
                    }
                    positionItems() {
                        this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes()
                    }
                    positionItem(e) {
                        let {
                            group: t,
                            x: i = 0,
                            y: s = 0
                        } = e.legendItem || {}, p = this.options, x = p.symbolPadding, O = !p.rtl, d = e.checkbox;
                        if (t && t.element) {
                            let A = {
                                translateX: O ? i : this.legendWidth - i - 2 * x - 4,
                                translateY: s
                            };
                            t[k(t.translateY) ? "animate" : "attr"](A, void 0, () => {
                                m(this, "afterPositionItem", {
                                    item: e
                                })
                            })
                        }
                        d && (d.x = i, d.y = s)
                    }
                    destroyItem(e) {
                        let t = e.checkbox,
                            i = e.legendItem || {};
                        for (let s of ["group", "label", "line", "symbol"]) i[s] && (i[s] = i[s].destroy());
                        t && g(t), e.legendItem = void 0
                    }
                    destroy() {
                        for (let e of this.getAllItems()) this.destroyItem(e);
                        for (let e of ["clipRect", "up", "down", "pager", "nav", "box", "title", "group"]) this[e] && (this[e] = this[e].destroy());
                        this.display = null
                    }
                    positionCheckboxes() {
                        let e, t = this.group && this.group.alignAttr,
                            i = this.clipHeight || this.legendHeight,
                            s = this.titleHeight;
                        t && (e = t.translateY, this.allItems.forEach(function(p) {
                            let x, O = p.checkbox;
                            O && (x = e + s + O.y + (this.scrollOffset || 0) + 3, M(O, {
                                left: t.translateX + p.checkboxOffset + O.x - 20 + "px",
                                top: x + "px",
                                display: this.proximate || x > e - 6 && x < e + i - 6 ? "" : "none"
                            }))
                        }, this))
                    }
                    renderTitle() {
                        let e = this.options,
                            t = this.padding,
                            i = e.title,
                            s, p = 0;
                        i.text && (this.title || (this.title = this.chart.renderer.label(i.text, t - 3, t - 4, void 0, void 0, void 0, e.useHTML, void 0, "legend-title").attr({
                            zIndex: 1
                        }), this.chart.styledMode || this.title.css(i.style), this.title.add(this.group)), i.width || this.title.css({
                            width: this.maxLegendWidth + "px"
                        }), p = (s = this.title.getBBox()).height, this.offsetWidth = s.width, this.contentGroup.attr({
                            translateY: p
                        })), this.titleHeight = p
                    }
                    setText(e) {
                        let t = this.options;
                        e.legendItem.label.attr({
                            text: t.labelFormat ? Z(t.labelFormat, e, this.chart) : t.labelFormatter.call(e)
                        })
                    }
                    renderItem(e) {
                        let t = e.legendItem = e.legendItem || {},
                            i = this.chart,
                            s = i.renderer,
                            p = this.options,
                            x = p.layout === "horizontal",
                            O = this.symbolWidth,
                            d = p.symbolPadding || 0,
                            A = this.itemStyle,
                            L = this.itemHiddenStyle,
                            V = x ? P(p.itemDistance, 20) : 0,
                            B = !p.rtl,
                            r = !e.series,
                            c = !r && e.series.drawLegendSymbol ? e.series : e,
                            b = c.options,
                            N = !!this.createCheckboxForItem && b && b.showCheckbox,
                            z = p.useHTML,
                            W = e.options.className,
                            a = t.label,
                            v = O + d + V + (N ? 20 : 0);
                        !a && (t.group = s.g("legend-item").addClass("highcharts-" + c.type + "-series highcharts-color-" + e.colorIndex + (W ? " " + W : "") + (r ? " highcharts-series-" + e.index : "")).attr({
                            zIndex: 1
                        }).add(this.scrollGroup), t.label = a = s.text("", B ? O + d : -d, this.baseline || 0, z), i.styledMode || a.css(T(e.visible ? A : L)), a.attr({
                            align: B ? "left" : "right",
                            zIndex: 2
                        }).add(t.group), !this.baseline && (this.fontMetrics = s.fontMetrics(a), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, a.attr("y", this.baseline), this.symbolHeight = P(p.symbolHeight, this.fontMetrics.f), p.squareSymbol && (this.symbolWidth = P(p.symbolWidth, Math.max(this.symbolHeight, 16)), v = this.symbolWidth + d + V + (N ? 20 : 0), B && a.attr("x", this.symbolWidth + d))), c.drawLegendSymbol(this, e), this.setItemEvents && this.setItemEvents(e, a, z)), N && !e.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(e), this.colorizeItem(e, e.visible), (i.styledMode || !A.width) && a.css({
                            width: (p.itemWidth || this.widthOption || i.spacingBox.width) - v + "px"
                        }), this.setText(e);
                        let y = a.getBBox(),
                            I = this.fontMetrics && this.fontMetrics.h || 0;
                        e.itemWidth = e.checkboxOffset = p.itemWidth || t.labelWidth || y.width + v, this.maxItemWidth = Math.max(this.maxItemWidth, e.itemWidth), this.totalItemWidth += e.itemWidth, this.itemHeight = e.itemHeight = Math.round(t.labelHeight || (y.height > 1.5 * I ? y.height : I))
                    }
                    layoutItem(e) {
                        let t = this.options,
                            i = this.padding,
                            s = t.layout === "horizontal",
                            p = e.itemHeight,
                            x = this.itemMarginBottom,
                            O = this.itemMarginTop,
                            d = s ? P(t.itemDistance, 20) : 0,
                            A = this.maxLegendWidth,
                            L = t.alignColumns && this.totalItemWidth > A ? this.maxItemWidth : e.itemWidth,
                            V = e.legendItem || {};
                        s && this.itemX - i + L > A && (this.itemX = i, this.lastLineHeight && (this.itemY += O + this.lastLineHeight + x), this.lastLineHeight = 0), this.lastItemY = O + this.itemY + x, this.lastLineHeight = Math.max(p, this.lastLineHeight), V.x = this.itemX, V.y = this.itemY, s ? this.itemX += L : (this.itemY += O + p + x, this.lastLineHeight = p), this.offsetWidth = this.widthOption || Math.max((s ? this.itemX - i - (e.checkbox ? 0 : d) : L) + i, this.offsetWidth)
                    }
                    getAllItems() {
                        let e = [];
                        return this.chart.series.forEach(function(t) {
                            let i = t && t.options;
                            t && P(i.showInLegend, !k(i.linkedTo) && void 0, !0) && (e = e.concat((t.legendItem || {}).labels || (i.legendType === "point" ? t.data : t)))
                        }), m(this, "afterGetAllItems", {
                            allItems: e
                        }), e
                    }
                    getAlignment() {
                        let e = this.options;
                        return this.proximate ? e.align.charAt(0) + "tv" : e.floating ? "" : e.align.charAt(0) + e.verticalAlign.charAt(0) + e.layout.charAt(0)
                    }
                    adjustMargins(e, t) {
                        let i = this.chart,
                            s = this.options,
                            p = this.getAlignment();
                        p && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function(x, O) {
                            x.test(p) && !k(e[O]) && (i[U[O]] = Math.max(i[U[O]], i.legend[(O + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][O] * s[O % 2 ? "x" : "y"] + P(s.margin, 12) + t[O] + (i.titleOffset[O] || 0)))
                        })
                    }
                    proximatePositions() {
                        let e, t = this.chart,
                            i = [],
                            s = this.options.align === "left";
                        for (let p of (this.allItems.forEach(function(x) {
                            let O, d, A = s,
                                L, V;
                            x.yAxis && (x.xAxis.options.reversed && (A = !A), x.points && (O = f(A ? x.points : x.points.slice(0).reverse(), function(B) {
                                return C(B.plotY)
                            })), d = this.itemMarginTop + x.legendItem.label.getBBox().height + this.itemMarginBottom, V = x.yAxis.top - t.plotTop, L = x.visible ? (O ? O.plotY : x.yAxis.height) + (V - .3 * d) : V + x.yAxis.height, i.push({
                                target: L,
                                size: d,
                                item: x
                            }))
                        }, this), S(i, t.plotHeight))) e = p.item.legendItem || {}, C(p.pos) && (e.y = t.plotTop - t.spacing[0] + p.pos)
                    }
                    render() {
                        let e = this.chart,
                            t = e.renderer,
                            i = this.options,
                            s = this.padding,
                            p = this.getAllItems(),
                            x, O, d, A = this.group,
                            L, V = this.box;
                        this.itemX = s, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = o(i.width, e.spacingBox.width - s), L = e.spacingBox.width - 2 * s - i.x, ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) > -1 && (L /= 2), this.maxLegendWidth = this.widthOption || L, A || (this.group = A = t.g("legend").addClass(i.className || "").attr({
                            zIndex: 7
                        }).add(), this.contentGroup = t.g().attr({
                            zIndex: 1
                        }).add(A), this.scrollGroup = t.g().add(this.contentGroup)), this.renderTitle(), l(p, (B, r) => (B.options && B.options.legendIndex || 0) - (r.options && r.options.legendIndex || 0)), i.reversed && p.reverse(), this.allItems = p, this.display = x = !!p.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, p.forEach(this.renderItem, this), p.forEach(this.layoutItem, this), O = (this.widthOption || this.offsetWidth) + s, d = this.lastItemY + this.lastLineHeight + this.titleHeight, d = this.handleOverflow(d) + s, V || (this.box = V = t.rect().addClass("highcharts-legend-box").attr({
                            r: i.borderRadius
                        }).add(A)), e.styledMode || V.attr({
                            stroke: i.borderColor,
                            "stroke-width": i.borderWidth || 0,
                            fill: i.backgroundColor || "none"
                        }).shadow(i.shadow), O > 0 && d > 0 && V[V.placed ? "animate" : "attr"](V.crisp.call({}, {
                            x: 0,
                            y: 0,
                            width: O,
                            height: d
                        }, V.strokeWidth())), A[x ? "show" : "hide"](), e.styledMode && A.getStyle("display") === "none" && (O = d = 0), this.legendWidth = O, this.legendHeight = d, x && this.align(), this.proximate || this.positionItems(), m(this, "afterRender")
                    }
                    align(e = this.chart.spacingBox) {
                        let t = this.chart,
                            i = this.options,
                            s = e.y;
                        /(lth|ct|rth)/.test(this.getAlignment()) && t.titleOffset[0] > 0 ? s += t.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && t.titleOffset[2] > 0 && (s -= t.titleOffset[2]), s !== e.y && (e = T(e, {
                            y: s
                        })), t.hasRendered || (this.group.placed = !1), this.group.align(T(i, {
                            width: this.legendWidth,
                            height: this.legendHeight,
                            verticalAlign: this.proximate ? "top" : i.verticalAlign
                        }), !0, e)
                    }
                    handleOverflow(e) {
                        let t = this,
                            i = this.chart,
                            s = i.renderer,
                            p = this.options,
                            x = p.y,
                            O = p.verticalAlign === "top",
                            d = this.padding,
                            A = p.maxHeight,
                            L = p.navigation,
                            V = P(L.animation, !0),
                            B = L.arrowSize || 12,
                            r = this.pages,
                            c = this.allItems,
                            b = function(w) {
                                typeof w == "number" ? I.attr({
                                    height: w
                                }) : I && (t.clipRect = I.destroy(), t.contentGroup.clip()), t.contentGroup.div && (t.contentGroup.div.style.clip = w ? "rect(" + d + "px,9999px," + (d + w) + "px,0)" : "auto")
                            },
                            N = function(w) {
                                return t[w] = s.circle(0, 0, 1.3 * B).translate(B / 2, B / 2).add(y), i.styledMode || t[w].attr("fill", "rgba(0,0,0,0.0001)"), t[w]
                            },
                            z, W, a, v = i.spacingBox.height + (O ? -x : x) - d,
                            y = this.nav,
                            I = this.clipRect;
                        return p.layout !== "horizontal" || p.verticalAlign === "middle" || p.floating || (v /= 2), A && (v = Math.min(v, A)), r.length = 0, e && v > 0 && e > v && L.enabled !== !1 ? (this.clipHeight = z = Math.max(v - 20 - this.titleHeight - d, 0), this.currentPage = P(this.currentPage, 1), this.fullHeight = e, c.forEach((w, G) => {
                            a = w.legendItem || {};
                            let X = a.y || 0,
                                _ = Math.round(a.label.getBBox().height),
                                $ = r.length;
                            (!$ || X - r[$ - 1] > z && (W || X) !== r[$ - 1]) && (r.push(W || X), $++), a.pageIx = $ - 1, W && ((c[G - 1].legendItem || {}).pageIx = $ - 1), G === c.length - 1 && X + _ - r[$ - 1] > z && X > r[$ - 1] && (r.push(X), a.pageIx = $), X !== W && (W = X)
                        }), I || (I = t.clipRect = s.clipRect(0, d - 2, 9999, 0), t.contentGroup.clip(I)), b(z), y || (this.nav = y = s.g().attr({
                            zIndex: 1
                        }).add(this.group), this.up = s.symbol("triangle", 0, 0, B, B).add(y), N("upTracker").on("click", function() {
                            t.scroll(-1, V)
                        }), this.pager = s.text("", 15, 10).addClass("highcharts-legend-navigation"), !i.styledMode && L.style && this.pager.css(L.style), this.pager.add(y), this.down = s.symbol("triangle-down", 0, 0, B, B).add(y), N("downTracker").on("click", function() {
                            t.scroll(1, V)
                        })), t.scroll(0), e = v) : y && (b(), this.nav = y.destroy(), this.scrollGroup.attr({
                            translateY: 1
                        }), this.clipHeight = 0), e
                    }
                    scroll(e, t) {
                        let i = this.chart,
                            s = this.pages,
                            p = s.length,
                            x = this.clipHeight,
                            O = this.options.navigation,
                            d = this.pager,
                            A = this.padding,
                            L = this.currentPage + e;
                        if (L > p && (L = p), L > 0) {
                            t !== void 0 && K(t, i), this.nav.attr({
                                translateX: A,
                                translateY: x + this.padding + 7 + this.titleHeight,
                                visibility: "inherit"
                            }), [this.up, this.upTracker].forEach(function(B) {
                                B.attr({
                                    class: L === 1 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                                })
                            }), d.attr({
                                text: L + "/" + p
                            }), [this.down, this.downTracker].forEach(function(B) {
                                B.attr({
                                    x: 18 + this.pager.getBBox().width,
                                    class: L === p ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                                })
                            }, this), i.styledMode || (this.up.attr({
                                fill: L === 1 ? O.inactiveColor : O.activeColor
                            }), this.upTracker.css({
                                cursor: L === 1 ? "default" : "pointer"
                            }), this.down.attr({
                                fill: L === p ? O.inactiveColor : O.activeColor
                            }), this.downTracker.css({
                                cursor: L === p ? "default" : "pointer"
                            })), this.scrollOffset = -s[L - 1] + this.initialItemY, this.scrollGroup.animate({
                                translateY: this.scrollOffset
                            }), this.currentPage = L, this.positionCheckboxes();
                            let V = ot(P(t, i.renderer.globalAnimation, !0));
                            n(() => {
                                m(this, "afterScroll", {
                                    currentPage: L
                                })
                            }, V.duration)
                        }
                    }
                    setItemEvents(e, t, i) {
                        let s = this,
                            p = e.legendItem || {},
                            x = s.chart.renderer.boxWrapper,
                            O = e instanceof rt,
                            d = "highcharts-legend-" + (O ? "point" : "series") + "-active",
                            A = s.chart.styledMode,
                            L = i ? [t, p.symbol] : [p.group],
                            V = B => {
                                s.allItems.forEach(r => {
                                    e !== r && [r].concat(r.linkedSeries || []).forEach(c => {
                                        c.setState(B, !O)
                                    })
                                })
                            };
                        for (let B of L) B && B.on("mouseover", function() {
                            e.visible && V("inactive"), e.setState("hover"), e.visible && x.addClass(d), A || t.css(s.options.itemHoverStyle)
                        }).on("mouseout", function() {
                            s.chart.styledMode || t.css(T(e.visible ? s.itemStyle : s.itemHiddenStyle)), V(""), x.removeClass(d), e.setState()
                        }).on("click", function(r) {
                            let c = "legendItemClick",
                                b = function() {
                                    e.setVisible && e.setVisible(), V(e.visible ? "inactive" : "")
                                };
                            x.removeClass(d), r = {
                                browserEvent: r
                            }, e.firePointEvent ? e.firePointEvent(c, r, b) : m(e, c, r, b)
                        })
                    }
                    createCheckboxForItem(e) {
                        e.checkbox = E("input", {
                            type: "checkbox",
                            className: "highcharts-legend-checkbox",
                            checked: e.selected,
                            defaultChecked: e.selected
                        }, this.options.itemCheckboxStyle, this.chart.container), R(e.checkbox, "click", function(t) {
                            let i = t.target;
                            m(e.series || e, "checkboxClick", {
                                checked: i.checked,
                                item: e
                            }, function() {
                                e.select()
                            })
                        })
                    }
                }
                return function(u) {
                    let e = [];
                    u.compose = function(t) {
                        nt.pushUnique(e, t) && R(t, "beforeMargins", function() {
                            this.legend = new u(this, this.options.legend)
                        })
                    }
                }(h || (h = {})), h
            }), ft(Y, "Core/Legend/LegendSymbol.js", [Y["Core/Utilities.js"]], function(et) {
                var Q, ht;
                let {
                    extend: rt,
                    merge: it,
                    pick: nt
                } = et;
                return (ht = Q || (Q = {})).lineMarker = function(ot, K) {
                    let Z = this.legendItem = this.legendItem || {},
                        U = this.options,
                        S = ot.symbolWidth,
                        R = ot.symbolHeight,
                        E = this.symbol || "circle",
                        M = R / 2,
                        k = this.chart.renderer,
                        g = Z.group,
                        f = ot.baseline - Math.round(.3 * ot.fontMetrics.b),
                        m = {},
                        C, T = U.marker,
                        P = 0;
                    if (this.chart.styledMode || (m = {
                        "stroke-width": Math.min(U.lineWidth || 0, 24)
                    }, U.dashStyle ? m.dashstyle = U.dashStyle : U.linecap === "square" || (m["stroke-linecap"] = "round")), Z.line = k.path().addClass("highcharts-graph").attr(m).add(g), m["stroke-linecap"] && (P = Math.min(Z.line.strokeWidth(), S) / 2), S && Z.line.attr({
                        d: [
                            ["M", P, f],
                            ["L", S - P, f]
                        ]
                    }), T && T.enabled !== !1 && S) {
                        let o = Math.min(nt(T.radius, M), M);
                        E.indexOf("url") === 0 && (T = it(T, {
                            width: R,
                            height: R
                        }), o = 0), Z.symbol = C = k.symbol(E, S / 2 - o, f - o, 2 * o, 2 * o, rt({
                            context: "legend"
                        }, T)).addClass("highcharts-point").add(g), C.isMarker = !0
                    }
                }, ht.rectangle = function(ot, K) {
                    let Z = K.legendItem || {},
                        U = ot.options,
                        S = ot.symbolHeight,
                        R = U.squareSymbol,
                        E = R ? S : ot.symbolWidth;
                    Z.symbol = this.chart.renderer.rect(R ? (ot.symbolWidth - S) / 2 : 0, ot.baseline - S + 1, E, S, nt(ot.options.symbolRadius, S / 2)).addClass("highcharts-point").attr({
                        zIndex: 3
                    }).add(Z.group)
                }, Q
            }), ft(Y, "Core/Series/SeriesDefaults.js", [], function() {
                return {
                    lineWidth: 2,
                    allowPointSelect: !1,
                    crisp: !0,
                    showCheckbox: !1,
                    animation: {
                        duration: 1e3
                    },
                    enableMouseTracking: !0,
                    events: {},
                    marker: {
                        enabledThreshold: 2,
                        lineColor: "#ffffff",
                        lineWidth: 0,
                        radius: 4,
                        states: {
                            normal: {
                                animation: !0
                            },
                            hover: {
                                animation: {
                                    duration: 150
                                },
                                enabled: !0,
                                radiusPlus: 2,
                                lineWidthPlus: 1
                            },
                            select: {
                                fillColor: "#cccccc",
                                lineColor: "#000000",
                                lineWidth: 2
                            }
                        }
                    },
                    point: {
                        events: {}
                    },
                    dataLabels: {
                        animation: {},
                        align: "center",
                        borderWidth: 0,
                        defer: !0,
                        formatter: function() {
                            let {
                                numberFormatter: et
                            } = this.series.chart;
                            return typeof this.y != "number" ? "" : et(this.y, -1)
                        },
                        padding: 5,
                        style: {
                            fontSize: "0.7em",
                            fontWeight: "bold",
                            color: "contrast",
                            textOutline: "1px contrast"
                        },
                        verticalAlign: "bottom",
                        x: 0,
                        y: 0
                    },
                    cropThreshold: 300,
                    opacity: 1,
                    pointRange: 0,
                    softThreshold: !0,
                    states: {
                        normal: {
                            animation: !0
                        },
                        hover: {
                            animation: {
                                duration: 150
                            },
                            lineWidthPlus: 1,
                            marker: {},
                            halo: {
                                size: 10,
                                opacity: .25
                            }
                        },
                        select: {
                            animation: {
                                duration: 0
                            }
                        },
                        inactive: {
                            animation: {
                                duration: 150
                            },
                            opacity: .2
                        }
                    },
                    stickyTracking: !0,
                    turboThreshold: 1e3,
                    findNearestPointBy: "x"
                }
            }), ft(Y, "Core/Series/SeriesRegistry.js", [Y["Core/Globals.js"], Y["Core/Defaults.js"], Y["Core/Series/Point.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt) {
                var it;
                let {
                    defaultOptions: nt
                } = Q, {
                    extendClass: ot,
                    merge: K
                } = rt;
                return function(Z) {
                    function U(S, R) {
                        let E = nt.plotOptions || {},
                            M = R.defaultOptions,
                            k = R.prototype;
                        k.type = S, k.pointClass || (k.pointClass = ht), M && (E[S] = M), Z.seriesTypes[S] = R
                    }
                    Z.seriesTypes = et.seriesTypes, Z.registerSeriesType = U, Z.seriesType = function(S, R, E, M, k) {
                        let g = nt.plotOptions || {};
                        return R = R || "", g[S] = K(g[R], E), U(S, ot(Z.seriesTypes[R] || function() {}, M)), Z.seriesTypes[S].prototype.type = S, k && (Z.seriesTypes[S].prototype.pointClass = ot(ht, k)), Z.seriesTypes[S]
                    }
                }(it || (it = {})), it
            }), ft(Y, "Core/Series/Series.js", [Y["Core/Animation/AnimationUtilities.js"], Y["Core/Defaults.js"], Y["Core/Foundation.js"], Y["Core/Globals.js"], Y["Core/Legend/LegendSymbol.js"], Y["Core/Series/Point.js"], Y["Core/Series/SeriesDefaults.js"], Y["Core/Series/SeriesRegistry.js"], Y["Core/Renderer/SVG/SVGElement.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt, it, nt, ot, K, Z, U) {
                let {
                    animObject: S,
                    setAnimation: R
                } = et, {
                    defaultOptions: E
                } = Q, {
                    registerEventOptions: M
                } = ht, {
                    hasTouch: k,
                    svg: g,
                    win: f
                } = rt, {
                    seriesTypes: m
                } = K, {
                    addEvent: C,
                    arrayMax: T,
                    arrayMin: P,
                    clamp: o,
                    correctFloat: l,
                    defined: n,
                    diffObjects: h,
                    erase: u,
                    error: e,
                    extend: t,
                    find: i,
                    fireEvent: s,
                    getClosestDistance: p,
                    getNestedProperty: x,
                    insertItem: O,
                    isArray: d,
                    isNumber: A,
                    isString: L,
                    merge: V,
                    objectEach: B,
                    pick: r,
                    removeEvent: c,
                    splat: b,
                    syncTimeout: N
                } = U;
                class z {
                    constructor() {
                        this._i = void 0, this.chart = void 0, this.data = void 0, this.eventOptions = void 0, this.eventsToUnbind = void 0, this.index = void 0, this.linkedSeries = void 0, this.options = void 0, this.points = void 0, this.processedXData = void 0, this.processedYData = void 0, this.tooltipOptions = void 0, this.userOptions = void 0, this.xAxis = void 0, this.yAxis = void 0, this.zones = void 0
                    }
                    init(a, v) {
                        let y;
                        s(this, "init", {
                            options: v
                        });
                        let I = this,
                            w = a.series;
                        this.eventsToUnbind = [], I.chart = a, I.options = I.setOptions(v);
                        let G = I.options,
                            X = G.visible !== !1;
                        I.linkedSeries = [], I.bindAxes(), t(I, {
                            name: G.name,
                            state: "",
                            visible: X,
                            selected: G.selected === !0
                        }), M(this, G);
                        let _ = G.events;
                        (_ && _.click || G.point && G.point.events && G.point.events.click || G.allowPointSelect) && (a.runTrackerClick = !0), I.getColor(), I.getSymbol(), I.parallelArrays.forEach(function($) {
                            I[$ + "Data"] || (I[$ + "Data"] = [])
                        }), I.isCartesian && (a.hasCartesianSeries = !0), w.length && (y = w[w.length - 1]), I._i = r(y && y._i, -1) + 1, I.opacity = I.options.opacity, a.orderItems("series", O(this, w)), G.dataSorting && G.dataSorting.enabled ? I.setDataSortingOptions() : I.points || I.data || I.setData(G.data, !1), s(this, "afterInit")
                    }
                    is(a) {
                        return m[a] && this instanceof m[a]
                    }
                    bindAxes() {
                        let a, v = this,
                            y = v.options,
                            I = v.chart;
                        s(this, "bindAxes", null, function() {
                            (v.axisTypes || []).forEach(function(w) {
                                I[w].forEach(function(G) {
                                    a = G.options, (r(y[w], 0) === G.index || y[w] !== void 0 && y[w] === a.id) && (O(v, G.series), v[w] = G, G.isDirty = !0)
                                }), v[w] || v.optionalAxis === w || e(18, !0, I)
                            })
                        }), s(this, "afterBindAxes")
                    }
                    updateParallelArrays(a, v, y) {
                        let I = a.series,
                            w = A(v) ? function(G) {
                                let X = G === "y" && I.toYData ? I.toYData(a) : a[G];
                                I[G + "Data"][v] = X
                            } : function(G) {
                                Array.prototype[v].apply(I[G + "Data"], y)
                            };
                        I.parallelArrays.forEach(w)
                    }
                    hasData() {
                        return this.visible && this.dataMax !== void 0 && this.dataMin !== void 0 || this.visible && this.yData && this.yData.length > 0
                    }
                    hasMarkerChanged(a, v) {
                        let y = a.marker,
                            I = v.marker || {};
                        return y && (I.enabled && !y.enabled || I.symbol !== y.symbol || I.height !== y.height || I.width !== y.width)
                    }
                    autoIncrement(a) {
                        let v = this.options,
                            y = v.pointIntervalUnit,
                            I = v.relativeXValue,
                            w = this.chart.time,
                            G = this.xIncrement,
                            X, _;
                        return G = r(G, v.pointStart, 0), this.pointInterval = _ = r(this.pointInterval, v.pointInterval, 1), I && A(a) && (_ *= a), y && (X = new w.Date(G), y === "day" ? w.set("Date", X, w.get("Date", X) + _) : y === "month" ? w.set("Month", X, w.get("Month", X) + _) : y === "year" && w.set("FullYear", X, w.get("FullYear", X) + _), _ = X.getTime() - G), I && A(a) ? G + _ : (this.xIncrement = G + _, G)
                    }
                    setDataSortingOptions() {
                        let a = this.options;
                        t(this, {
                            requireSorting: !1,
                            sorted: !1,
                            enabledDataSorting: !0,
                            allowDG: !1
                        }), n(a.pointRange) || (a.pointRange = 1)
                    }
                    setOptions(a) {
                        var at, tt;
                        let v, y = this.chart,
                            I = y.options,
                            w = I.plotOptions,
                            G = y.userOptions || {},
                            X = V(a),
                            _ = y.styledMode,
                            $ = {
                                plotOptions: w,
                                userOptions: X
                            };
                        s(this, "setOptions", $);
                        let st = $.plotOptions[this.type],
                            D = G.plotOptions || {},
                            j = D.series || {},
                            F = E.plotOptions[this.type] || {},
                            H = D[this.type] || {};
                        this.userOptions = $.userOptions;
                        let q = V(st, w.series, H, X);
                        this.tooltipOptions = V(E.tooltip, (at = E.plotOptions.series) == null ? void 0 : at.tooltip, F == null ? void 0 : F.tooltip, y.userOptions.tooltip, (tt = D.series) == null ? void 0 : tt.tooltip, H.tooltip, X.tooltip), this.stickyTracking = r(X.stickyTracking, H.stickyTracking, j.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || q.stickyTracking), st.marker === null && delete q.marker, this.zoneAxis = q.zoneAxis;
                        let J = this.zones = (q.zones || []).slice();
                        return (q.negativeColor || q.negativeFillColor) && !q.zones && (v = {
                            value: q[this.zoneAxis + "Threshold"] || q.threshold || 0,
                            className: "highcharts-negative"
                        }, _ || (v.color = q.negativeColor, v.fillColor = q.negativeFillColor), J.push(v)), J.length && n(J[J.length - 1].value) && J.push(_ ? {} : {
                            color: this.color,
                            fillColor: this.fillColor
                        }), s(this, "afterSetOptions", {
                            options: q
                        }), q
                    }
                    getName() {
                        return r(this.options.name, "Series " + (this.index + 1))
                    }
                    getCyclic(a, v, y) {
                        let I, w, G = this.chart,
                            X = `${a}Index`,
                            _ = `${a}Counter`,
                            $ = (y == null ? void 0 : y.length) || G.options.chart.colorCount;
                        !v && (n(w = r(a === "color" ? this.options.colorIndex : void 0, this[X])) ? I = w : (G.series.length || (G[_] = 0), I = G[_] % $, G[_] += 1), y && (v = y[I])), I !== void 0 && (this[X] = I), this[a] = v
                    }
                    getColor() {
                        this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || E.plotOptions[this.type].color, this.chart.options.colors)
                    }
                    getPointsCollection() {
                        return (this.hasGroupedData ? this.points : this.data) || []
                    }
                    getSymbol() {
                        let a = this.options.marker;
                        this.getCyclic("symbol", a.symbol, this.chart.options.symbols)
                    }
                    findPointIndex(a, v) {
                        let y, I, w, G = a.id,
                            X = a.x,
                            _ = this.points,
                            $ = this.options.dataSorting;
                        if (G) {
                            let st = this.chart.get(G);
                            st instanceof nt && (y = st)
                        } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
                            let st = D => !D.touched && D.index === a.index;
                            if ($ && $.matchByName ? st = D => !D.touched && D.name === a.name : this.options.relativeXValue && (st = D => !D.touched && D.options.x === a.x), !(y = i(_, st))) return
                        }
                        return y && (w = y && y.index) !== void 0 && (I = !0), w === void 0 && A(X) && (w = this.xData.indexOf(X, v)), w !== -1 && w !== void 0 && this.cropped && (w = w >= this.cropStart ? w - this.cropStart : w), !I && A(w) && _[w] && _[w].touched && (w = void 0), w
                    }
                    updateData(a, v) {
                        let y = this.options,
                            I = y.dataSorting,
                            w = this.points,
                            G = [],
                            X = this.requireSorting,
                            _ = a.length === w.length,
                            $, st, D, j, F = !0;
                        if (this.xIncrement = null, a.forEach(function(H, q) {
                            let J, at = n(H) && this.pointClass.prototype.optionsToObject.call({
                                    series: this
                                }, H) || {},
                                tt = at.x;
                            at.id || A(tt) ? ((J = this.findPointIndex(at, j)) === -1 || J === void 0 ? G.push(H) : w[J] && H !== y.data[J] ? (w[J].update(H, !1, null, !1), w[J].touched = !0, X && (j = J + 1)) : w[J] && (w[J].touched = !0), (!_ || q !== J || I && I.enabled || this.hasDerivedData) && ($ = !0)) : G.push(H)
                        }, this), $)
                            for (st = w.length; st--;)(D = w[st]) && !D.touched && D.remove && D.remove(!1, v);
                        else !_ || I && I.enabled ? F = !1 : (a.forEach(function(H, q) {
                            H === w[q].y || w[q].destroyed || w[q].update(H, !1, null, !1)
                        }), G.length = 0);
                        return w.forEach(function(H) {
                            H && (H.touched = !1)
                        }), !!F && (G.forEach(function(H) {
                            this.addPoint(H, !1, null, null, !1)
                        }, this), this.xIncrement === null && this.xData && this.xData.length && (this.xIncrement = T(this.xData), this.autoIncrement()), !0)
                    }
                    setData(a, v = !0, y, I) {
                        var ct;
                        let w = this,
                            G = w.points,
                            X = G && G.length || 0,
                            _ = w.options,
                            $ = w.chart,
                            st = _.dataSorting,
                            D = w.xAxis,
                            j = _.turboThreshold,
                            F = this.xData,
                            H = this.yData,
                            q = w.pointArrayMap,
                            J = q && q.length,
                            at = _.keys,
                            tt, dt, pt, lt = 0,
                            ut = 1,
                            mt = null,
                            xt;
                        $.options.chart.allowMutatingData || (_.data && delete w.options.data, w.userOptions.data && delete w.userOptions.data, xt = V(!0, a)), a = xt || a || [];
                        let gt = a.length;
                        if (st && st.enabled && (a = this.sortData(a)), $.options.chart.allowMutatingData && I !== !1 && gt && X && !w.cropped && !w.hasGroupedData && w.visible && !w.boosted && (pt = this.updateData(a, y)), !pt) {
                            if (w.xIncrement = null, w.colorCounter = 0, this.parallelArrays.forEach(function(bt) {
                                w[bt + "Data"].length = 0
                            }), j && gt > j)
                                if (A(mt = w.getFirstValidPoint(a)))
                                    for (tt = 0; tt < gt; tt++) F[tt] = this.autoIncrement(), H[tt] = a[tt];
                                else if (d(mt))
                                    if (J)
                                        if (mt.length === J)
                                            for (tt = 0; tt < gt; tt++) F[tt] = this.autoIncrement(), H[tt] = a[tt];
                                        else
                                            for (tt = 0; tt < gt; tt++) dt = a[tt], F[tt] = dt[0], H[tt] = dt.slice(1, J + 1);
                                    else if (at && (lt = at.indexOf("x"), ut = at.indexOf("y"), lt = lt >= 0 ? lt : 0, ut = ut >= 0 ? ut : 1), mt.length === 1 && (ut = 0), lt === ut)
                                        for (tt = 0; tt < gt; tt++) F[tt] = this.autoIncrement(), H[tt] = a[tt][ut];
                                    else
                                        for (tt = 0; tt < gt; tt++) dt = a[tt], F[tt] = dt[lt], H[tt] = dt[ut];
                                else e(12, !1, $);
                            else
                                for (tt = 0; tt < gt; tt++) dt = {
                                    series: w
                                }, w.pointClass.prototype.applyOptions.apply(dt, [a[tt]]), w.updateParallelArrays(dt, tt);
                            for (H && L(H[0]) && e(14, !0, $), w.data = [], w.options.data = w.userOptions.data = a, tt = X; tt--;)(ct = G[tt]) == null || ct.destroy();
                            D && (D.minRange = D.userMinRange), w.isDirty = $.isDirtyBox = !0, w.isDirtyData = !!G, y = !1
                        }
                        _.legendType === "point" && (this.processData(), this.generatePoints()), v && $.redraw(y)
                    }
                    sortData(a) {
                        let v = this,
                            y = v.options,
                            I = y.dataSorting,
                            w = I.sortKey || "y",
                            G = function(_, $) {
                                return n($) && _.pointClass.prototype.optionsToObject.call({
                                    series: _
                                }, $) || {}
                            };
                        return a.forEach(function(_, $) {
                            a[$] = G(v, _), a[$].index = $
                        }, this), a.concat().sort((_, $) => {
                            let st = x(w, _),
                                D = x(w, $);
                            return D < st ? -1 : D > st ? 1 : 0
                        }).forEach(function(_, $) {
                            _.x = $
                        }, this), v.linkedSeries && v.linkedSeries.forEach(function(_) {
                            let $ = _.options,
                                st = $.data;
                            $.dataSorting && $.dataSorting.enabled || !st || (st.forEach(function(D, j) {
                                st[j] = G(_, D), a[j] && (st[j].x = a[j].x, st[j].index = j)
                            }), _.setData(st, !1))
                        }), a
                    }
                    getProcessedData(a) {
                        let v = this,
                            y = v.xAxis,
                            I = v.options,
                            w = I.cropThreshold,
                            G = a || v.getExtremesFromAll || I.getExtremesFromAll,
                            X = y == null ? void 0 : y.logarithmic,
                            _ = v.isCartesian,
                            $, st, D = 0,
                            j, F, H, q = v.xData,
                            J = v.yData,
                            at = !1,
                            tt = q.length;
                        y && (F = (j = y.getExtremes()).min, H = j.max, at = !!(y.categories && !y.names.length)), _ && v.sorted && !G && (!w || tt > w || v.forceCrop) && (q[tt - 1] < F || q[0] > H ? (q = [], J = []) : v.yData && (q[0] < F || q[tt - 1] > H) && (q = ($ = this.cropData(v.xData, v.yData, F, H)).xData, J = $.yData, D = $.start, st = !0));
                        let dt = p([X ? q.map(X.log2lin) : q], () => v.requireSorting && !at && e(15, !1, v.chart));
                        return {
                            xData: q,
                            yData: J,
                            cropped: st,
                            cropStart: D,
                            closestPointRange: dt
                        }
                    }
                    processData(a) {
                        let v = this.xAxis;
                        if (this.isCartesian && !this.isDirty && !v.isDirty && !this.yAxis.isDirty && !a) return !1;
                        let y = this.getProcessedData();
                        this.cropped = y.cropped, this.cropStart = y.cropStart, this.processedXData = y.xData, this.processedYData = y.yData, this.closestPointRange = this.basePointRange = y.closestPointRange, s(this, "afterProcessData")
                    }
                    cropData(a, v, y, I) {
                        let w = a.length,
                            G, X, _ = 0,
                            $ = w;
                        for (G = 0; G < w; G++)
                            if (a[G] >= y) {
                                _ = Math.max(0, G - 1);
                                break
                            } for (X = G; X < w; X++)
                            if (a[X] > I) {
                                $ = X + 1;
                                break
                            } return {
                            xData: a.slice(_, $),
                            yData: v.slice(_, $),
                            start: _,
                            end: $
                        }
                    }
                    generatePoints() {
                        let a = this.options,
                            v = this.processedData || a.data,
                            y = this.processedXData,
                            I = this.processedYData,
                            w = this.pointClass,
                            G = y.length,
                            X = this.cropStart || 0,
                            _ = this.hasGroupedData,
                            $ = a.keys,
                            st = [],
                            D = a.dataGrouping && a.dataGrouping.groupAll ? X : 0,
                            j, F, H, q, J = this.data;
                        if (!J && !_) {
                            let at = [];
                            at.length = v.length, J = this.data = at
                        }
                        for ($ && _ && (this.options.keys = !1), q = 0; q < G; q++) F = X + q, _ ? ((H = new w().init(this, [y[q]].concat(b(I[q])))).dataGroup = this.groupMap[D + q], H.dataGroup.options && (H.options = H.dataGroup.options, t(H, H.dataGroup.options), delete H.dataLabels)) : (H = J[F]) || v[F] === void 0 || (J[F] = H = new w().init(this, v[F], y[q])), H && (H.index = _ ? D + q : F, st[q] = H);
                        if (this.options.keys = $, J && (G !== (j = J.length) || _))
                            for (q = 0; q < j; q++) q !== X || _ || (q += G), J[q] && (J[q].destroyElements(), J[q].plotX = void 0);
                        this.data = J, this.points = st, s(this, "afterGeneratePoints")
                    }
                    getXExtremes(a) {
                        return {
                            min: P(a),
                            max: T(a)
                        }
                    }
                    getExtremes(a, v) {
                        let y = this.xAxis,
                            I = this.yAxis,
                            w = this.processedXData || this.xData,
                            G = [],
                            X = this.requireSorting && !this.is("column") ? 1 : 0,
                            _ = !!I && I.positiveValuesOnly,
                            $, st, D, j, F, H, q, J = 0,
                            at = 0,
                            tt = 0;
                        a = a || this.stackedYData || this.processedYData || [];
                        let dt = a.length;
                        for (y && (J = ($ = y.getExtremes()).min, at = $.max), H = 0; H < dt; H++)
                            if (j = w[H], st = (A(F = a[H]) || d(F)) && ((A(F) ? F > 0 : F.length) || !_), D = v || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !y || (w[H + X] || j) >= J && (w[H - X] || j) <= at, st && D)
                                if (q = F.length)
                                    for (; q--;) A(F[q]) && (G[tt++] = F[q]);
                                else G[tt++] = F;
                        let pt = {
                            activeYData: G,
                            dataMin: P(G),
                            dataMax: T(G)
                        };
                        return s(this, "afterGetExtremes", {
                            dataExtremes: pt
                        }), pt
                    }
                    applyExtremes() {
                        let a = this.getExtremes();
                        return this.dataMin = a.dataMin, this.dataMax = a.dataMax, a
                    }
                    getFirstValidPoint(a) {
                        let v = a.length,
                            y = 0,
                            I = null;
                        for (; I === null && y < v;) I = a[y], y++;
                        return I
                    }
                    translate() {
                        var dt;
                        this.processedXData || this.processData(), this.generatePoints();
                        let a = this.options,
                            v = a.stacking,
                            y = this.xAxis,
                            I = y.categories,
                            w = this.enabledDataSorting,
                            G = this.yAxis,
                            X = this.points,
                            _ = X.length,
                            $ = this.pointPlacementToXValue(),
                            st = !!$,
                            D = a.threshold,
                            j = a.startFromThreshold ? D : 0,
                            F, H, q, J, at = Number.MAX_VALUE;

                        function tt(pt) {
                            return o(pt, -1e5, 1e5)
                        }
                        for (F = 0; F < _; F++) {
                            let pt, lt = X[F],
                                ut = lt.x,
                                mt, xt, gt = lt.y,
                                ct = lt.low,
                                bt = v && ((dt = G.stacking) == null ? void 0 : dt.stacks[(this.negStacks && gt < (j ? 0 : D) ? "-" : "") + this.stackKey]);
                            H = y.translate(ut, !1, !1, !1, !0, $), lt.plotX = A(H) ? l(tt(H)) : void 0, v && this.visible && bt && bt[ut] && (J = this.getStackIndicator(J, ut, this.index), !lt.isNull && J.key && (xt = (mt = bt[ut]).points[J.key]), mt && d(xt) && (ct = xt[0], gt = xt[1], ct === j && J.key === bt[ut].base && (ct = r(A(D) ? D : G.min)), G.positiveValuesOnly && n(ct) && ct <= 0 && (ct = void 0), lt.total = lt.stackTotal = r(mt.total), lt.percentage = n(lt.y) && mt.total ? lt.y / mt.total * 100 : void 0, lt.stackY = gt, this.irregularWidths || mt.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), lt.yBottom = n(ct) ? tt(G.translate(ct, !1, !0, !1, !0)) : void 0, this.dataModify && (gt = this.dataModify.modifyValue(gt, F)), A(gt) && lt.plotX !== void 0 && (pt = A(pt = G.translate(gt, !1, !0, !1, !0)) ? tt(pt) : void 0), lt.plotY = pt, lt.isInside = this.isPointInside(lt), lt.clientX = st ? l(y.translate(ut, !1, !1, !1, !0, $)) : H, lt.negative = (lt.y || 0) < (D || 0), lt.category = r(I && I[lt.x], lt.x), lt.isNull || lt.visible === !1 || (q !== void 0 && (at = Math.min(at, Math.abs(H - q))), q = H), lt.zone = this.zones.length ? lt.getZone() : void 0, !lt.graphic && this.group && w && (lt.isNew = !0)
                        }
                        this.closestPointRangePx = at, s(this, "afterTranslate")
                    }
                    getValidPoints(a, v, y) {
                        let I = this.chart;
                        return (a || this.points || []).filter(function(w) {
                            let {
                                plotX: G,
                                plotY: X
                            } = w;
                            return !(!y && (w.isNull || !A(X))) && (!v || !!I.isInsidePlot(G, X, {
                                inverted: I.inverted
                            })) && w.visible !== !1
                        })
                    }
                    getClipBox() {
                        let {
                            chart: a,
                            xAxis: v,
                            yAxis: y
                        } = this, I = V(a.clipBox);
                        return v && v.len !== a.plotSizeX && (I.width = v.len), y && y.len !== a.plotSizeY && (I.height = y.len), I
                    }
                    getSharedClipKey() {
                        return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0), this.sharedClipKey
                    }
                    setClip() {
                        let {
                            chart: a,
                            group: v,
                            markerGroup: y
                        } = this, I = a.sharedClips, w = a.renderer, G = this.getClipBox(), X = this.getSharedClipKey(), _ = I[X];
                        _ ? _.animate(G) : I[X] = _ = w.clipRect(G), v && v.clip(this.options.clip === !1 ? void 0 : _), y && y.clip()
                    }
                    animate(a) {
                        let {
                            chart: v,
                            group: y,
                            markerGroup: I
                        } = this, w = v.inverted, G = S(this.options.animation), X = [this.getSharedClipKey(), G.duration, G.easing, G.defer].join(","), _ = v.sharedClips[X], $ = v.sharedClips[X + "m"];
                        if (a && y) {
                            let st = this.getClipBox();
                            if (_) _.attr("height", st.height);
                            else {
                                st.width = 0, w && (st.x = v.plotHeight), _ = v.renderer.clipRect(st), v.sharedClips[X] = _;
                                let D = {
                                    x: -99,
                                    y: -99,
                                    width: w ? v.plotWidth + 199 : 99,
                                    height: w ? 99 : v.plotHeight + 199
                                };
                                $ = v.renderer.clipRect(D), v.sharedClips[X + "m"] = $
                            }
                            y.clip(_), I && I.clip($)
                        } else if (_ && !_.hasClass("highcharts-animating")) {
                            let st = this.getClipBox(),
                                D = G.step;
                            I && I.element.childNodes.length && (G.step = function(j, F) {
                                D && D.apply(F, arguments), F.prop === "width" && $ && $.element && $.attr(w ? "height" : "width", j + 99)
                            }), _.addClass("highcharts-animating").animate(st, G)
                        }
                    }
                    afterAnimate() {
                        this.setClip(), B(this.chart.sharedClips, (a, v, y) => {
                            a && !this.chart.container.querySelector(`[clip-path="url(#${a.id})"]`) && (a.destroy(), delete y[v])
                        }), this.finishedAnimating = !0, s(this, "afterAnimate")
                    }
                    drawPoints(a = this.points) {
                        let v, y, I, w, G, X, _, $ = this.chart,
                            st = $.styledMode,
                            {
                                colorAxis: D,
                                options: j
                            } = this,
                            F = j.marker,
                            H = this[this.specialGroup || "markerGroup"],
                            q = this.xAxis,
                            J = r(F.enabled, !q || !!q.isRadial || null, this.closestPointRangePx >= F.enabledThreshold * F.radius);
                        if (F.enabled !== !1 || this._hasPointMarkers)
                            for (v = 0; v < a.length; v++)
                                if (w = (I = (y = a[v]).graphic) ? "animate" : "attr", G = y.marker || {}, X = !!y.marker, (J && G.enabled === void 0 || G.enabled) && !y.isNull && y.visible !== !1) {
                                    let tt = r(G.symbol, this.symbol, "rect");
                                    _ = this.markerAttribs(y, y.selected && "select"), this.enabledDataSorting && (y.startXPos = q.reversed ? -(_.width || 0) : q.width);
                                    let dt = y.isInside !== !1;
                                    if (!I && dt && ((_.width || 0) > 0 || y.hasImage) && (y.graphic = I = $.renderer.symbol(tt, _.x, _.y, _.width, _.height, X ? G : F).add(H), this.enabledDataSorting && $.hasRendered && (I.attr({
                                        x: y.startXPos
                                    }), w = "animate")), I && w === "animate" && I[dt ? "show" : "hide"](dt).animate(_), I) {
                                        let pt = this.pointAttribs(y, st || !y.selected ? void 0 : "select");
                                        st ? D && I.css({
                                            fill: pt.fill
                                        }) : I[w](pt)
                                    }
                                    I && I.addClass(y.getClassName(), !0)
                                } else I && (y.graphic = I.destroy())
                    }
                    markerAttribs(a, v) {
                        let y = this.options,
                            I = y.marker,
                            w = a.marker || {},
                            G = w.symbol || I.symbol,
                            X = {},
                            _, $, st = r(w.radius, I && I.radius);
                        v && (_ = I.states[v], st = r(($ = w.states && w.states[v]) && $.radius, _ && _.radius, st && st + (_ && _.radiusPlus || 0))), a.hasImage = G && G.indexOf("url") === 0, a.hasImage && (st = 0);
                        let D = a.pos();
                        return A(st) && D && (X.x = D[0] - st, X.y = D[1] - st, y.crisp && (X.x = Math.floor(X.x))), st && (X.width = X.height = 2 * st), X
                    }
                    pointAttribs(a, v) {
                        let y = this.options.marker,
                            I = a && a.options,
                            w = I && I.marker || {},
                            G = I && I.color,
                            X = a && a.color,
                            _ = a && a.zone && a.zone.color,
                            $, st, D = this.color,
                            j, F, H = r(w.lineWidth, y.lineWidth),
                            q = 1;
                        return D = G || _ || X || D, j = w.fillColor || y.fillColor || D, F = w.lineColor || y.lineColor || D, v = v || "normal", $ = y.states[v] || {}, H = r((st = w.states && w.states[v] || {}).lineWidth, $.lineWidth, H + r(st.lineWidthPlus, $.lineWidthPlus, 0)), j = st.fillColor || $.fillColor || j, {
                            stroke: F = st.lineColor || $.lineColor || F,
                            "stroke-width": H,
                            fill: j,
                            opacity: q = r(st.opacity, $.opacity, q)
                        }
                    }
                    destroy(a) {
                        let v, y, I, w = this,
                            G = w.chart,
                            X = /AppleWebKit\/533/.test(f.navigator.userAgent),
                            _ = w.data || [];
                        for (s(w, "destroy", {
                            keepEventsForUpdate: a
                        }), this.removeEvents(a), (w.axisTypes || []).forEach(function($) {
                            (I = w[$]) && I.series && (u(I.series, w), I.isDirty = I.forceRedraw = !0)
                        }), w.legendItem && w.chart.legend.destroyItem(w), v = _.length; v--;)(y = _[v]) && y.destroy && y.destroy();
                        w.clips && w.clips.forEach($ => $.destroy()), U.clearTimeout(w.animationTimeout), B(w, function($, st) {
                            $ instanceof Z && !$.survive && $[X && st === "group" ? "hide" : "destroy"]()
                        }), G.hoverSeries === w && (G.hoverSeries = void 0), u(G.series, w), G.orderItems("series"), B(w, function($, st) {
                            a && st === "hcEvents" || delete w[st]
                        })
                    }
                    applyZones() {
                        let a = this,
                            v = this.chart,
                            y = v.renderer,
                            I = this.zones,
                            w = this.clips || [],
                            G = this.graph,
                            X = this.area,
                            _ = Math.max(v.plotWidth, v.plotHeight),
                            $ = this[(this.zoneAxis || "y") + "Axis"],
                            st = v.inverted,
                            D, j, F, H, q, J, at, tt, dt, pt, lt, ut = !1;
                        I.length && (G || X) && $ && $.min !== void 0 ? (q = $.reversed, J = $.horiz, G && !this.showLine && G.hide(), X && X.hide(), H = $.getExtremes(), I.forEach(function(mt, xt) {
                            D = q ? J ? v.plotWidth : 0 : J ? 0 : $.toPixels(H.min) || 0, D = o(r(j, D), 0, _), j = o(Math.round($.toPixels(r(mt.value, H.max), !0) || 0), 0, _), ut && (D = j = $.toPixels(H.max)), at = Math.abs(D - j), tt = Math.min(D, j), dt = Math.max(D, j), $.isXAxis ? (F = {
                                x: st ? dt : tt,
                                y: 0,
                                width: at,
                                height: _
                            }, J || (F.x = v.plotHeight - F.x)) : (F = {
                                x: 0,
                                y: st ? dt : tt,
                                width: _,
                                height: at
                            }, J && (F.y = v.plotWidth - F.y)), w[xt] ? w[xt].animate(F) : w[xt] = y.clipRect(F), pt = a["zone-area-" + xt], lt = a["zone-graph-" + xt], G && lt && lt.clip(w[xt]), X && pt && pt.clip(w[xt]), ut = mt.value > H.max, a.resetZones && j === 0 && (j = void 0)
                        }), this.clips = w) : a.visible && (G && G.show(), X && X.show())
                    }
                    plotGroup(a, v, y, I, w) {
                        let G = this[a],
                            X = !G,
                            _ = {
                                visibility: y,
                                zIndex: I || .1
                            };
                        return this.opacity === void 0 || this.chart.styledMode || this.state === "inactive" || (_.opacity = this.opacity), X && (this[a] = G = this.chart.renderer.g().add(w)), G.addClass("highcharts-" + v + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (n(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (G.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0), G.attr(_)[X ? "attr" : "animate"](this.getPlotBox(v)), G
                    }
                    getPlotBox(a) {
                        let v = this.xAxis,
                            y = this.yAxis,
                            I = this.chart,
                            w = I.inverted && !I.polar && v && this.invertible !== !1 && a === "series";
                        return I.inverted && (v = y, y = this.xAxis), {
                            translateX: v ? v.left : I.plotLeft,
                            translateY: y ? y.top : I.plotTop,
                            rotation: w ? 90 : 0,
                            rotationOriginX: w ? (v.len - y.len) / 2 : 0,
                            rotationOriginY: w ? (v.len + y.len) / 2 : 0,
                            scaleX: w ? -1 : 1,
                            scaleY: 1
                        }
                    }
                    removeEvents(a) {
                        a || c(this), this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function(v) {
                            v()
                        }), this.eventsToUnbind.length = 0)
                    }
                    render() {
                        let a = this,
                            v = a.chart,
                            y = a.options,
                            I = S(y.animation),
                            w = a.visible ? "inherit" : "hidden",
                            G = y.zIndex,
                            X = a.hasRendered,
                            _ = v.seriesGroup;
                        v.inverted;
                        let $ = a.finishedAnimating ? 0 : I.duration;
                        s(this, "render"), a.plotGroup("group", "series", w, G, _), a.markerGroup = a.plotGroup("markerGroup", "markers", w, G, _), y.clip !== !1 && a.setClip(), a.animate && $ && a.animate(!0), a.drawGraph && (a.drawGraph(), a.applyZones()), a.visible && a.drawPoints(), a.drawDataLabels && a.drawDataLabels(), a.redrawPoints && a.redrawPoints(), a.drawTracker && y.enableMouseTracking && a.drawTracker(), a.animate && $ && a.animate(), X || ($ && I.defer && ($ += I.defer), a.animationTimeout = N(function() {
                            a.afterAnimate()
                        }, $ || 0)), a.isDirty = !1, a.hasRendered = !0, s(a, "afterRender")
                    }
                    redraw() {
                        let a = this.isDirty || this.isDirtyData;
                        this.translate(), this.render(), a && delete this.kdTree
                    }
                    reserveSpace() {
                        return this.visible || !this.chart.options.chart.ignoreHiddenSeries
                    }
                    searchPoint(a, v) {
                        let y = this.xAxis,
                            I = this.yAxis,
                            w = this.chart.inverted;
                        return this.searchKDTree({
                            clientX: w ? y.len - a.chartY + y.pos : a.chartX - y.pos,
                            plotY: w ? I.len - a.chartX + I.pos : a.chartY - I.pos
                        }, v, a)
                    }
                    buildKDTree(a) {
                        this.buildingKdTree = !0;
                        let v = this,
                            y = v.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
                        delete v.kdTree, N(function() {
                            v.kdTree = function I(w, G, X) {
                                let _, $, st = w && w.length;
                                if (st) return _ = v.kdAxisArray[G % X], w.sort(function(D, j) {
                                    return D[_] - j[_]
                                }), {
                                    point: w[$ = Math.floor(st / 2)],
                                    left: I(w.slice(0, $), G + 1, X),
                                    right: I(w.slice($ + 1), G + 1, X)
                                }
                            }(v.getValidPoints(null, !v.directTouch), y, y), v.buildingKdTree = !1
                        }, v.options.kdNow || a && a.type === "touchstart" ? 0 : 1)
                    }
                    searchKDTree(a, v, y) {
                        let I = this,
                            [w, G] = this.kdAxisArray,
                            X = v ? "distX" : "dist",
                            _ = (I.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1,
                            $ = !!I.isBubble;
                        if (this.kdTree || this.buildingKdTree || this.buildKDTree(y), this.kdTree) return function st(D, j, F, H) {
                            var mt;
                            let q = j.point,
                                J = I.kdAxisArray[F % H],
                                at, tt, dt = q;
                            (function(xt, gt) {
                                var St;
                                let ct = xt[w],
                                    bt = gt[w],
                                    yt = n(ct) && n(bt) ? ct - bt : null,
                                    vt = xt[G],
                                    Mt = gt[G],
                                    kt = n(vt) && n(Mt) ? vt - Mt : 0,
                                    wt = $ && ((St = gt.marker) == null ? void 0 : St.radius) || 0;
                                gt.dist = Math.sqrt((yt && yt * yt || 0) + kt * kt) - wt, gt.distX = n(yt) ? Math.abs(yt) - wt : Number.MAX_VALUE
                            })(D, q);
                            let pt = (D[J] || 0) - (q[J] || 0) + ($ && ((mt = q.marker) == null ? void 0 : mt.radius) || 0),
                                lt = pt < 0 ? "left" : "right",
                                ut = pt < 0 ? "right" : "left";
                            return j[lt] && (dt = (at = st(D, j[lt], F + 1, H))[X] < dt[X] ? at : q), j[ut] && Math.sqrt(pt * pt) < dt[X] && (dt = (tt = st(D, j[ut], F + 1, H))[X] < dt[X] ? tt : dt), dt
                        }(a, this.kdTree, _, _)
                    }
                    pointPlacementToXValue() {
                        let {
                            options: {
                                pointPlacement: a,
                                pointRange: v
                            },
                            xAxis: y
                        } = this, I = a;
                        return I === "between" && (I = y.reversed ? -.5 : .5), A(I) ? I * (v || y.pointRange) : 0
                    }
                    isPointInside(a) {
                        let {
                            chart: v,
                            xAxis: y,
                            yAxis: I
                        } = this;
                        return a.plotY !== void 0 && a.plotX !== void 0 && a.plotY >= 0 && a.plotY <= (I ? I.len : v.plotHeight) && a.plotX >= 0 && a.plotX <= (y ? y.len : v.plotWidth)
                    }
                    drawTracker() {
                        let a = this,
                            v = a.options,
                            y = v.trackByArea,
                            I = [].concat(y ? a.areaPath : a.graphPath),
                            w = a.chart,
                            G = w.pointer,
                            X = w.renderer,
                            _ = w.options.tooltip.snap,
                            $ = a.tracker,
                            st = function(j) {
                                v.enableMouseTracking && w.hoverSeries !== a && a.onMouseOver()
                            },
                            D = "rgba(192,192,192," + (g ? 1e-4 : .002) + ")";
                        $ ? $.attr({
                            d: I
                        }) : a.graph && (a.tracker = X.path(I).attr({
                            visibility: a.visible ? "inherit" : "hidden",
                            zIndex: 2
                        }).addClass(y ? "highcharts-tracker-area" : "highcharts-tracker-line").add(a.group), w.styledMode || a.tracker.attr({
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            stroke: D,
                            fill: y ? D : "none",
                            "stroke-width": a.graph.strokeWidth() + (y ? 0 : 2 * _)
                        }), [a.tracker, a.markerGroup, a.dataLabelsGroup].forEach(function(j) {
                            j && (j.addClass("highcharts-tracker").on("mouseover", st).on("mouseout", function(F) {
                                G.onTrackerMouseOut(F)
                            }), v.cursor && !w.styledMode && j.css({
                                cursor: v.cursor
                            }), k && j.on("touchstart", st))
                        })), s(this, "afterDrawTracker")
                    }
                    addPoint(a, v, y, I, w) {
                        let G, X, _ = this.options,
                            $ = this.data,
                            st = this.chart,
                            D = this.xAxis,
                            j = D && D.hasNames && D.names,
                            F = _.data,
                            H = this.xData;
                        v = r(v, !0);
                        let q = {
                            series: this
                        };
                        this.pointClass.prototype.applyOptions.apply(q, [a]);
                        let J = q.x;
                        if (X = H.length, this.requireSorting && J < H[X - 1])
                            for (G = !0; X && H[X - 1] > J;) X--;
                        this.updateParallelArrays(q, "splice", [X, 0, 0]), this.updateParallelArrays(q, X), j && q.name && (j[J] = q.name), F.splice(X, 0, a), (G || this.processedData) && (this.data.splice(X, 0, null), this.processData()), _.legendType === "point" && this.generatePoints(), y && ($[0] && $[0].remove ? $[0].remove(!1) : ($.shift(), this.updateParallelArrays(q, "shift"), F.shift())), w !== !1 && s(this, "addPoint", {
                            point: q
                        }), this.isDirty = !0, this.isDirtyData = !0, v && st.redraw(I)
                    }
                    removePoint(a, v, y) {
                        let I = this,
                            w = I.data,
                            G = w[a],
                            X = I.points,
                            _ = I.chart,
                            $ = function() {
                                X && X.length === w.length && X.splice(a, 1), w.splice(a, 1), I.options.data.splice(a, 1), I.updateParallelArrays(G || {
                                    series: I
                                }, "splice", [a, 1]), G && G.destroy(), I.isDirty = !0, I.isDirtyData = !0, v && _.redraw()
                            };
                        R(y, _), v = r(v, !0), G ? G.firePointEvent("remove", null, $) : $()
                    }
                    remove(a, v, y, I) {
                        let w = this,
                            G = w.chart;

                        function X() {
                            w.destroy(I), G.isDirtyLegend = G.isDirtyBox = !0, G.linkSeries(I), r(a, !0) && G.redraw(v)
                        }
                        y !== !1 ? s(w, "remove", null, X) : X()
                    }
                    update(a, v) {
                        var at, tt;
                        s(this, "update", {
                            options: a = h(a, this.userOptions)
                        });
                        let y = this,
                            I = y.chart,
                            w = y.userOptions,
                            G = y.initialType || y.type,
                            X = I.options.plotOptions,
                            _ = m[G].prototype,
                            $ = y.finishedAnimating && {
                                animation: !1
                            },
                            st = {},
                            D, j, F = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"],
                            H = a.type || w.type || I.options.chart.type,
                            q = !(this.hasDerivedData || H && H !== this.type || a.pointStart !== void 0 || a.pointInterval !== void 0 || a.relativeXValue !== void 0 || a.joinBy || a.mapData || ["dataGrouping", "pointStart", "pointInterval", "pointIntervalUnit", "keys"].some(dt => y.hasOptionChanged(dt)));
                        H = H || G, q && (F.push("data", "isDirtyData", "isDirtyCanvas", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "clips", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), a.visible !== !1 && F.push("area", "graph"), y.parallelArrays.forEach(function(dt) {
                            F.push(dt + "Data")
                        }), a.data && (a.dataSorting && t(y.options.dataSorting, a.dataSorting), this.setData(a.data, !1))), a = V(w, $, {
                            index: w.index === void 0 ? y.index : w.index,
                            pointStart: r((at = X == null ? void 0 : X.series) == null ? void 0 : at.pointStart, w.pointStart, y.xData[0])
                        }, !q && {
                            data: y.options.data
                        }, a), q && a.data && (a.data = y.options.data), (F = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(F)).forEach(function(dt) {
                            F[dt] = y[dt], delete y[dt]
                        });
                        let J = !1;
                        if (m[H]) {
                            if (J = H !== y.type, y.remove(!1, !1, !1, !0), J)
                                if (Object.setPrototypeOf) Object.setPrototypeOf(y, m[H].prototype);
                                else {
                                    let dt = Object.hasOwnProperty.call(y, "hcEvents") && y.hcEvents;
                                    for (j in _) y[j] = void 0;
                                    t(y, m[H].prototype), dt ? y.hcEvents = dt : delete y.hcEvents
                                }
                        } else e(17, !0, I, {
                            missingModuleFor: H
                        });
                        if (F.forEach(function(dt) {
                            y[dt] = F[dt]
                        }), y.init(I, a), q && this.points)
                            for (let dt of ((D = y.options).visible === !1 ? (st.graphic = 1, st.dataLabel = 1) : (this.hasMarkerChanged(D, w) && (st.graphic = 1), (tt = y.hasDataLabels) != null && tt.call(y) || (st.dataLabel = 1)), this.points)) dt && dt.series && (dt.resolveColor(), Object.keys(st).length && dt.destroyElements(st), D.showInLegend === !1 && dt.legendItem && I.legend.destroyItem(dt));
                        y.initialType = G, I.linkSeries(), J && y.linkedSeries.length && (y.isDirtyData = !0), s(this, "afterUpdate"), r(v, !0) && I.redraw(!!q && void 0)
                    }
                    setName(a) {
                        this.name = this.options.name = this.userOptions.name = a, this.chart.isDirtyLegend = !0
                    }
                    hasOptionChanged(a) {
                        var X, _;
                        let v = this.chart,
                            y = this.options[a],
                            I = v.options.plotOptions,
                            w = this.userOptions[a],
                            G = r((X = I == null ? void 0 : I[this.type]) == null ? void 0 : X[a], (_ = I == null ? void 0 : I.series) == null ? void 0 : _[a]);
                        return w && !n(G) ? y !== w : y !== r(G, y)
                    }
                    onMouseOver() {
                        let a = this.chart,
                            v = a.hoverSeries;
                        a.pointer.setHoverChartIndex(), v && v !== this && v.onMouseOut(), this.options.events.mouseOver && s(this, "mouseOver"), this.setState("hover"), a.hoverSeries = this
                    }
                    onMouseOut() {
                        let a = this.options,
                            v = this.chart,
                            y = v.tooltip,
                            I = v.hoverPoint;
                        v.hoverSeries = null, I && I.onMouseOut(), this && a.events.mouseOut && s(this, "mouseOut"), y && !this.stickyTracking && (!y.shared || this.noSharedTooltip) && y.hide(), v.series.forEach(function(w) {
                            w.setState("", !0)
                        })
                    }
                    setState(a, v) {
                        let y = this,
                            I = y.options,
                            w = y.graph,
                            G = I.inactiveOtherPoints,
                            X = I.states,
                            _ = r(X[a || "normal"] && X[a || "normal"].animation, y.chart.options.chart.animation),
                            $, st = I.lineWidth,
                            D = 0,
                            j = I.opacity;
                        if (a = a || "", y.state !== a && ([y.group, y.markerGroup, y.dataLabelsGroup].forEach(function(F) {
                            F && (y.state && F.removeClass("highcharts-series-" + y.state), a && F.addClass("highcharts-series-" + a))
                        }), y.state = a, !y.chart.styledMode)) {
                            if (X[a] && X[a].enabled === !1) return;
                            if (a && (st = X[a].lineWidth || st + (X[a].lineWidthPlus || 0), j = r(X[a].opacity, j)), w && !w.dashstyle && A(st))
                                for ($ = {
                                    "stroke-width": st
                                }, w.animate($, _); y["zone-graph-" + D];) y["zone-graph-" + D].animate($, _), D += 1;
                            G || [y.group, y.markerGroup, y.dataLabelsGroup, y.labelBySeries].forEach(function(F) {
                                F && F.animate({
                                    opacity: j
                                }, _)
                            })
                        }
                        v && G && y.points && y.setAllPointsToState(a || void 0)
                    }
                    setAllPointsToState(a) {
                        this.points.forEach(function(v) {
                            v.setState && v.setState(a)
                        })
                    }
                    setVisible(a, v) {
                        var _;
                        let y = this,
                            I = y.chart,
                            w = I.options.chart.ignoreHiddenSeries,
                            G = y.visible;
                        y.visible = a = y.options.visible = y.userOptions.visible = a === void 0 ? !G : a;
                        let X = a ? "show" : "hide";
                        ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach($ => {
                            var st;
                            (st = y[$]) == null || st[X]()
                        }), (I.hoverSeries === y || ((_ = I.hoverPoint) == null ? void 0 : _.series) === y) && y.onMouseOut(), y.legendItem && I.legend.colorizeItem(y, a), y.isDirty = !0, y.options.stacking && I.series.forEach($ => {
                            $.options.stacking && $.visible && ($.isDirty = !0)
                        }), y.linkedSeries.forEach($ => {
                            $.setVisible(a, !1)
                        }), w && (I.isDirtyBox = !0), s(y, X), v !== !1 && I.redraw()
                    }
                    show() {
                        this.setVisible(!0)
                    }
                    hide() {
                        this.setVisible(!1)
                    }
                    select(a) {
                        this.selected = a = this.options.selected = a === void 0 ? !this.selected : a, this.checkbox && (this.checkbox.checked = a), s(this, a ? "select" : "unselect")
                    }
                    shouldShowTooltip(a, v, y = {}) {
                        return y.series = this, y.visiblePlotOnly = !0, this.chart.isInsidePlot(a, v, y)
                    }
                    drawLegendSymbol(a, v) {
                        var y;
                        (y = it[this.options.legendSymbol || "rectangle"]) == null || y.call(this, a, v)
                    }
                }
                return z.defaultOptions = ot, z.types = K.seriesTypes, z.registerType = K.registerSeriesType, t(z.prototype, {
                    axisTypes: ["xAxis", "yAxis"],
                    coll: "series",
                    colorCounter: 0,
                    directTouch: !1,
                    isCartesian: !0,
                    kdAxisArray: ["clientX", "plotY"],
                    parallelArrays: ["x", "y"],
                    pointClass: nt,
                    requireSorting: !0,
                    sorted: !0
                }), K.series = z, z
            }), ft(Y, "Core/Chart/Chart.js", [Y["Core/Animation/AnimationUtilities.js"], Y["Core/Axis/Axis.js"], Y["Core/Defaults.js"], Y["Core/Templating.js"], Y["Core/Foundation.js"], Y["Core/Globals.js"], Y["Core/Renderer/RendererRegistry.js"], Y["Core/Series/Series.js"], Y["Core/Series/SeriesRegistry.js"], Y["Core/Renderer/SVG/SVGRenderer.js"], Y["Core/Time.js"], Y["Core/Utilities.js"], Y["Core/Renderer/HTML/AST.js"]], function(et, Q, ht, rt, it, nt, ot, K, Z, U, S, R, E) {
                let {
                    animate: M,
                    animObject: k,
                    setAnimation: g
                } = et, {
                    defaultOptions: f,
                    defaultTime: m
                } = ht, {
                    numberFormat: C
                } = rt, {
                    registerEventOptions: T
                } = it, {
                    charts: P,
                    doc: o,
                    marginNames: l,
                    svg: n,
                    win: h
                } = nt, {
                    seriesTypes: u
                } = Z, {
                    addEvent: e,
                    attr: t,
                    createElement: i,
                    css: s,
                    defined: p,
                    diffObjects: x,
                    discardElement: O,
                    erase: d,
                    error: A,
                    extend: L,
                    find: V,
                    fireEvent: B,
                    getStyle: r,
                    isArray: c,
                    isNumber: b,
                    isObject: N,
                    isString: z,
                    merge: W,
                    objectEach: a,
                    pick: v,
                    pInt: y,
                    relativeLength: I,
                    removeEvent: w,
                    splat: G,
                    syncTimeout: X,
                    uniqueKey: _
                } = R;
                class $ {
                    static chart(D, j, F) {
                        return new $(D, j, F)
                    }
                    constructor(D, j, F) {
                        this.axes = void 0, this.axisOffset = void 0, this.bounds = void 0, this.chartHeight = void 0, this.chartWidth = void 0, this.clipBox = void 0, this.colorCounter = void 0, this.container = void 0, this.eventOptions = void 0, this.index = void 0, this.isResizing = void 0, this.labelCollectors = void 0, this.margin = void 0, this.numberFormatter = void 0, this.options = void 0, this.plotBox = void 0, this.plotHeight = void 0, this.plotLeft = void 0, this.plotTop = void 0, this.plotWidth = void 0, this.pointCount = void 0, this.pointer = void 0, this.renderer = void 0, this.renderTo = void 0, this.series = void 0, this.sharedClips = {}, this.spacing = void 0, this.spacingBox = void 0, this.symbolCounter = void 0, this.time = void 0, this.titleOffset = void 0, this.userOptions = void 0, this.xAxis = void 0, this.yAxis = void 0, this.zooming = void 0, this.getArgs(D, j, F)
                    }
                    getArgs(D, j, F) {
                        z(D) || D.nodeName ? (this.renderTo = D, this.init(j, F)) : this.init(D, j)
                    }
                    setZoomOptions() {
                        let D = this.options.chart,
                            j = D.zooming;
                        this.zooming = {
                            ...j,
                            type: v(D.zoomType, j.type),
                            key: v(D.zoomKey, j.key),
                            pinchType: v(D.pinchType, j.pinchType),
                            singleTouch: v(D.zoomBySingleTouch, j.singleTouch, !1),
                            resetButton: W(j.resetButton, D.resetZoomButton)
                        }
                    }
                    init(D, j) {
                        B(this, "init", {
                            args: arguments
                        }, function() {
                            let F = W(f, D),
                                H = F.chart;
                            this.userOptions = L({}, D), this.margin = [], this.spacing = [], this.bounds = {
                                h: {},
                                v: {}
                            }, this.labelCollectors = [], this.callback = j, this.isResizing = 0, this.options = F, this.axes = [], this.series = [], this.time = D.time && Object.keys(D.time).length ? new S(D.time) : nt.time, this.numberFormatter = H.numberFormatter || C, this.styledMode = H.styledMode, this.hasCartesianSeries = H.showAxes, this.index = P.length, P.push(this), nt.chartCount++, T(this, H), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), B(this, "afterInit"), this.firstRender()
                        })
                    }
                    initSeries(D) {
                        let j = this.options.chart,
                            F = D.type || j.type,
                            H = u[F];
                        H || A(17, !0, this, {
                            missingModuleFor: F
                        });
                        let q = new H;
                        return typeof q.init == "function" && q.init(this, D), q
                    }
                    setSeriesData() {
                        this.getSeriesOrderByLinks().forEach(function(D) {
                            D.points || D.data || !D.enabledDataSorting || D.setData(D.options.data, !1)
                        })
                    }
                    getSeriesOrderByLinks() {
                        return this.series.concat().sort(function(D, j) {
                            return D.linkedSeries.length || j.linkedSeries.length ? j.linkedSeries.length - D.linkedSeries.length : 0
                        })
                    }
                    orderItems(D, j = 0) {
                        let F = this[D],
                            H = this.options[D] = G(this.options[D]).slice(),
                            q = this.userOptions[D] = this.userOptions[D] ? G(this.userOptions[D]).slice() : [];
                        if (this.hasRendered && (H.splice(j), q.splice(j)), F)
                            for (let J = j, at = F.length; J < at; ++J) {
                                let tt = F[J];
                                tt && (tt.index = J, tt instanceof K && (tt.name = tt.getName()), tt.options.isInternal || (H[J] = tt.options, q[J] = tt.userOptions))
                            }
                    }
                    isInsidePlot(D, j, F = {}) {
                        let {
                            inverted: H,
                            plotBox: q,
                            plotLeft: J,
                            plotTop: at,
                            scrollablePlotBox: tt
                        } = this, dt = 0, pt = 0;
                        F.visiblePlotOnly && this.scrollingContainer && ({
                            scrollLeft: dt,
                            scrollTop: pt
                        } = this.scrollingContainer);
                        let lt = F.series,
                            ut = F.visiblePlotOnly && tt || q,
                            mt = F.inverted ? j : D,
                            xt = F.inverted ? D : j,
                            gt = {
                                x: mt,
                                y: xt,
                                isInsidePlot: !0,
                                options: F
                            };
                        if (!F.ignoreX) {
                            let ct = lt && (H && !this.polar ? lt.yAxis : lt.xAxis) || {
                                    pos: J,
                                    len: 1 / 0
                                },
                                bt = F.paneCoordinates ? ct.pos + mt : J + mt;
                            bt >= Math.max(dt + J, ct.pos) && bt <= Math.min(dt + J + ut.width, ct.pos + ct.len) || (gt.isInsidePlot = !1)
                        }
                        if (!F.ignoreY && gt.isInsidePlot) {
                            let ct = !H && F.axis && !F.axis.isXAxis && F.axis || lt && (H ? lt.xAxis : lt.yAxis) || {
                                    pos: at,
                                    len: 1 / 0
                                },
                                bt = F.paneCoordinates ? ct.pos + xt : at + xt;
                            bt >= Math.max(pt + at, ct.pos) && bt <= Math.min(pt + at + ut.height, ct.pos + ct.len) || (gt.isInsidePlot = !1)
                        }
                        return B(this, "afterIsInsidePlot", gt), gt.isInsidePlot
                    }
                    redraw(D) {
                        B(this, "beforeRedraw");
                        let j = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
                            F = this.series,
                            H = this.pointer,
                            q = this.legend,
                            J = this.userOptions.legend,
                            at = this.renderer,
                            tt = at.isHidden(),
                            dt = [],
                            pt, lt, ut, mt = this.isDirtyBox,
                            xt = this.isDirtyLegend,
                            gt;
                        for (at.rootFontSize = at.boxWrapper.getStyle("font-size"), this.setResponsive && this.setResponsive(!1), g(!!this.hasRendered && D, this), tt && this.temporaryDisplay(), this.layOutTitles(!1), ut = F.length; ut--;)
                            if (((gt = F[ut]).options.stacking || gt.options.centerInCategory) && (lt = !0, gt.isDirty)) {
                                pt = !0;
                                break
                            } if (pt)
                            for (ut = F.length; ut--;)(gt = F[ut]).options.stacking && (gt.isDirty = !0);
                        F.forEach(function(ct) {
                            ct.isDirty && (ct.options.legendType === "point" ? (typeof ct.updateTotals == "function" && ct.updateTotals(), xt = !0) : J && (J.labelFormatter || J.labelFormat) && (xt = !0)), ct.isDirtyData && B(ct, "updatedData")
                        }), xt && q && q.options.enabled && (q.render(), this.isDirtyLegend = !1), lt && this.getStacks(), j.forEach(function(ct) {
                            ct.updateNames(), ct.setScale()
                        }), this.getMargins(), j.forEach(function(ct) {
                            ct.isDirty && (mt = !0)
                        }), j.forEach(function(ct) {
                            let bt = ct.min + "," + ct.max;
                            ct.extKey !== bt && (ct.extKey = bt, dt.push(function() {
                                B(ct, "afterSetExtremes", L(ct.eventArgs, ct.getExtremes())), delete ct.eventArgs
                            })), (mt || lt) && ct.redraw()
                        }), mt && this.drawChartBox(), B(this, "predraw"), F.forEach(function(ct) {
                            (mt || ct.isDirty) && ct.visible && ct.redraw(), ct.isDirtyData = !1
                        }), H && H.reset(!0), at.draw(), B(this, "redraw"), B(this, "render"), tt && this.temporaryDisplay(!0), dt.forEach(function(ct) {
                            ct.call()
                        })
                    }
                    get(D) {
                        let j = this.series;

                        function F(q) {
                            return q.id === D || q.options && q.options.id === D
                        }
                        let H = V(this.axes, F) || V(this.series, F);
                        for (let q = 0; !H && q < j.length; q++) H = V(j[q].points || [], F);
                        return H
                    }
                    getAxes() {
                        let D = this.options;
                        for (let j of (B(this, "getAxes"), ["xAxis", "yAxis"])) {
                            let F = D[j] = G(D[j] || {});
                            for (let H of F) new Q(this, H, j)
                        }
                        B(this, "afterGetAxes")
                    }
                    getSelectedPoints() {
                        return this.series.reduce((D, j) => (j.getPointsCollection().forEach(F => {
                            v(F.selectedStaging, F.selected) && D.push(F)
                        }), D), [])
                    }
                    getSelectedSeries() {
                        return this.series.filter(function(D) {
                            return D.selected
                        })
                    }
                    setTitle(D, j, F) {
                        this.applyDescription("title", D), this.applyDescription("subtitle", j), this.applyDescription("caption", void 0), this.layOutTitles(F)
                    }
                    applyDescription(D, j) {
                        let F = this,
                            H = this.options[D] = W(this.options[D], j),
                            q = this[D];
                        q && j && (this[D] = q = q.destroy()), H && !q && ((q = this.renderer.text(H.text, 0, 0, H.useHTML).attr({
                            align: H.align,
                            class: "highcharts-" + D,
                            zIndex: H.zIndex || 4
                        }).add()).update = function(J, at) {
                            F.applyDescription(D, J), F.layOutTitles(at)
                        }, this.styledMode || q.css(L(D === "title" ? {
                            fontSize: this.options.isStock ? "1em" : "1.2em"
                        } : {}, H.style)), this[D] = q)
                    }
                    layOutTitles(D = !0) {
                        let j = [0, 0, 0],
                            F = this.renderer,
                            H = this.spacingBox;
                        ["title", "subtitle", "caption"].forEach(function(J) {
                            let at = this[J],
                                tt = this.options[J],
                                dt = tt.verticalAlign || "top",
                                pt = J === "title" ? dt === "top" ? -3 : 0 : dt === "top" ? j[0] + 2 : 0;
                            if (at) {
                                at.css({
                                    width: (tt.width || H.width + (tt.widthAdjust || 0)) + "px"
                                });
                                let lt = F.fontMetrics(at).b,
                                    ut = Math.round(at.getBBox(tt.useHTML).height);
                                at.align(L({
                                    y: dt === "bottom" ? lt : pt + lt,
                                    height: ut
                                }, tt), !1, "spacingBox"), tt.floating || (dt === "top" ? j[0] = Math.ceil(j[0] + ut) : dt === "bottom" && (j[2] = Math.ceil(j[2] + ut)))
                            }
                        }, this), j[0] && (this.options.title.verticalAlign || "top") === "top" && (j[0] += this.options.title.margin), j[2] && this.options.caption.verticalAlign === "bottom" && (j[2] += this.options.caption.margin);
                        let q = !this.titleOffset || this.titleOffset.join(",") !== j.join(",");
                        this.titleOffset = j, B(this, "afterLayOutTitles"), !this.isDirtyBox && q && (this.isDirtyBox = this.isDirtyLegend = q, this.hasRendered && D && this.isDirtyBox && this.redraw())
                    }
                    getContainerBox() {
                        return {
                            width: r(this.renderTo, "width", !0) || 0,
                            height: r(this.renderTo, "height", !0) || 0
                        }
                    }
                    getChartSize() {
                        let D = this.options.chart,
                            j = D.width,
                            F = D.height,
                            H = this.getContainerBox();
                        this.chartWidth = Math.max(0, j || H.width || 600), this.chartHeight = Math.max(0, I(F, this.chartWidth) || (H.height > 1 ? H.height : 400)), this.containerBox = H
                    }
                    temporaryDisplay(D) {
                        let j = this.renderTo,
                            F;
                        if (D)
                            for (; j && j.style;) j.hcOrigStyle && (s(j, j.hcOrigStyle), delete j.hcOrigStyle), j.hcOrigDetached && (o.body.removeChild(j), j.hcOrigDetached = !1), j = j.parentNode;
                        else
                            for (; j && j.style && (o.body.contains(j) || j.parentNode || (j.hcOrigDetached = !0, o.body.appendChild(j)), (r(j, "display", !1) === "none" || j.hcOricDetached) && (j.hcOrigStyle = {
                                display: j.style.display,
                                height: j.style.height,
                                overflow: j.style.overflow
                            }, F = {
                                display: "block",
                                overflow: "hidden"
                            }, j !== this.renderTo && (F.height = 0), s(j, F), j.offsetWidth || j.style.setProperty("display", "block", "important")), (j = j.parentNode) !== o.body););
                    }
                    setClassName(D) {
                        this.container.className = "highcharts-container " + (D || "")
                    }
                    getContainer() {
                        let D = this.options,
                            j = D.chart,
                            F = "data-highcharts-chart",
                            H = _(),
                            q, J = this.renderTo;
                        J || (this.renderTo = J = j.renderTo), z(J) && (this.renderTo = J = o.getElementById(J)), J || A(13, !0, this);
                        let at = y(t(J, F));
                        b(at) && P[at] && P[at].hasRendered && P[at].destroy(), t(J, F, this.index), J.innerHTML = E.emptyHTML, j.skipClone || J.offsetWidth || this.temporaryDisplay(), this.getChartSize();
                        let tt = this.chartWidth,
                            dt = this.chartHeight;
                        s(J, {
                            overflow: "hidden"
                        }), this.styledMode || (q = L({
                            position: "relative",
                            overflow: "hidden",
                            width: tt + "px",
                            height: dt + "px",
                            textAlign: "left",
                            lineHeight: "normal",
                            zIndex: 0,
                            "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                            userSelect: "none",
                            "touch-action": "manipulation",
                            outline: "none"
                        }, j.style || {}));
                        let pt = i("div", {
                            id: H
                        }, q, J);
                        this.container = pt, this._cursor = pt.style.cursor;
                        let lt = j.renderer || !n ? ot.getRendererType(j.renderer) : U;
                        if (this.renderer = new lt(pt, tt, dt, void 0, j.forExport, D.exporting && D.exporting.allowHTML, this.styledMode), this.containerBox = this.getContainerBox(), g(void 0, this), this.setClassName(j.className), this.styledMode)
                            for (let ut in D.defs) this.renderer.definition(D.defs[ut]);
                        else this.renderer.setStyle(j.style);
                        this.renderer.chartIndex = this.index, B(this, "afterGetContainer")
                    }
                    getMargins(D) {
                        let {
                            spacing: j,
                            margin: F,
                            titleOffset: H
                        } = this;
                        this.resetMargins(), H[0] && !p(F[0]) && (this.plotTop = Math.max(this.plotTop, H[0] + j[0])), H[2] && !p(F[2]) && (this.marginBottom = Math.max(this.marginBottom, H[2] + j[2])), this.legend && this.legend.display && this.legend.adjustMargins(F, j), B(this, "getMargins"), D || this.getAxisMargins()
                    }
                    getAxisMargins() {
                        let D = this,
                            j = D.axisOffset = [0, 0, 0, 0],
                            F = D.colorAxis,
                            H = D.margin,
                            q = function(J) {
                                J.forEach(function(at) {
                                    at.visible && at.getOffset()
                                })
                            };
                        D.hasCartesianSeries ? q(D.axes) : F && F.length && q(F), l.forEach(function(J, at) {
                            p(H[at]) || (D[J] += j[at])
                        }), D.setChartSize()
                    }
                    getOptions() {
                        return x(this.userOptions, f)
                    }
                    reflow(D) {
                        let j = this,
                            F = j.containerBox,
                            H = j.getContainerBox();
                        delete j.pointer.chartPosition, !j.isPrinting && !j.isResizing && F && H.width && ((H.width !== F.width || H.height !== F.height) && (R.clearTimeout(j.reflowTimeout), j.reflowTimeout = X(function() {
                            j.container && j.setSize(void 0, void 0, !1)
                        }, D ? 100 : 0)), j.containerBox = H)
                    }
                    setReflow() {
                        let D = this,
                            j = F => {
                                var H;
                                (H = D.options) != null && H.chart.reflow && D.hasLoaded && D.reflow(F)
                            };
                        if (typeof ResizeObserver == "function") new ResizeObserver(j).observe(D.renderTo);
                        else {
                            let F = e(h, "resize", j);
                            e(this, "destroy", F)
                        }
                    }
                    setSize(D, j, F) {
                        let H = this,
                            q = H.renderer;
                        H.isResizing += 1, g(F, H);
                        let J = q.globalAnimation;
                        H.oldChartHeight = H.chartHeight, H.oldChartWidth = H.chartWidth, D !== void 0 && (H.options.chart.width = D), j !== void 0 && (H.options.chart.height = j), H.getChartSize(), H.styledMode || (J ? M : s)(H.container, {
                            width: H.chartWidth + "px",
                            height: H.chartHeight + "px"
                        }, J), H.setChartSize(!0), q.setSize(H.chartWidth, H.chartHeight, J), H.axes.forEach(function(at) {
                            at.isDirty = !0, at.setScale()
                        }), H.isDirtyLegend = !0, H.isDirtyBox = !0, H.layOutTitles(), H.getMargins(), H.redraw(J), H.oldChartHeight = null, B(H, "resize"), setTimeout(() => {
                            H && B(H, "endResize", void 0, () => {
                                H.isResizing -= 1
                            })
                        }, k(J).duration)
                    }
                    setChartSize(D) {
                        let j, F, H, q, J = this.inverted,
                            at = this.renderer,
                            tt = this.chartWidth,
                            dt = this.chartHeight,
                            pt = this.options.chart,
                            lt = this.spacing,
                            ut = this.clipOffset;
                        this.plotLeft = j = Math.round(this.plotLeft), this.plotTop = F = Math.round(this.plotTop), this.plotWidth = H = Math.max(0, Math.round(tt - j - this.marginRight)), this.plotHeight = q = Math.max(0, Math.round(dt - F - this.marginBottom)), this.plotSizeX = J ? q : H, this.plotSizeY = J ? H : q, this.plotBorderWidth = pt.plotBorderWidth || 0, this.spacingBox = at.spacingBox = {
                            x: lt[3],
                            y: lt[0],
                            width: tt - lt[3] - lt[1],
                            height: dt - lt[0] - lt[2]
                        }, this.plotBox = at.plotBox = {
                            x: j,
                            y: F,
                            width: H,
                            height: q
                        };
                        let mt = 2 * Math.floor(this.plotBorderWidth / 2),
                            xt = Math.ceil(Math.max(mt, ut[3]) / 2),
                            gt = Math.ceil(Math.max(mt, ut[0]) / 2);
                        this.clipBox = {
                            x: xt,
                            y: gt,
                            width: Math.floor(this.plotSizeX - Math.max(mt, ut[1]) / 2 - xt),
                            height: Math.max(0, Math.floor(this.plotSizeY - Math.max(mt, ut[2]) / 2 - gt))
                        }, D || (this.axes.forEach(function(ct) {
                            ct.setAxisSize(), ct.setAxisTranslation()
                        }), at.alignElements()), B(this, "afterSetChartSize", {
                            skipAxes: D
                        })
                    }
                    resetMargins() {
                        B(this, "resetMargins");
                        let D = this,
                            j = D.options.chart;
                        ["margin", "spacing"].forEach(function(F) {
                            let H = j[F],
                                q = N(H) ? H : [H, H, H, H];
                            ["Top", "Right", "Bottom", "Left"].forEach(function(J, at) {
                                D[F][at] = v(j[F + J], q[at])
                            })
                        }), l.forEach(function(F, H) {
                            D[F] = v(D.margin[H], D.spacing[H])
                        }), D.axisOffset = [0, 0, 0, 0], D.clipOffset = [0, 0, 0, 0]
                    }
                    drawChartBox() {
                        let D = this.options.chart,
                            j = this.renderer,
                            F = this.chartWidth,
                            H = this.chartHeight,
                            q = this.styledMode,
                            J = this.plotBGImage,
                            at = D.backgroundColor,
                            tt = D.plotBackgroundColor,
                            dt = D.plotBackgroundImage,
                            pt = this.plotLeft,
                            lt = this.plotTop,
                            ut = this.plotWidth,
                            mt = this.plotHeight,
                            xt = this.plotBox,
                            gt = this.clipRect,
                            ct = this.clipBox,
                            bt = this.chartBackground,
                            yt = this.plotBackground,
                            vt = this.plotBorder,
                            Mt, kt, wt, St = "animate";
                        bt || (this.chartBackground = bt = j.rect().addClass("highcharts-background").add(), St = "attr"), q ? Mt = kt = bt.strokeWidth() : (kt = (Mt = D.borderWidth || 0) + (D.shadow ? 8 : 0), wt = {
                            fill: at || "none"
                        }, (Mt || bt["stroke-width"]) && (wt.stroke = D.borderColor, wt["stroke-width"] = Mt), bt.attr(wt).shadow(D.shadow)), bt[St]({
                            x: kt / 2,
                            y: kt / 2,
                            width: F - kt - Mt % 2,
                            height: H - kt - Mt % 2,
                            r: D.borderRadius
                        }), St = "animate", yt || (St = "attr", this.plotBackground = yt = j.rect().addClass("highcharts-plot-background").add()), yt[St](xt), !q && (yt.attr({
                            fill: tt || "none"
                        }).shadow(D.plotShadow), dt && (J ? (dt !== J.attr("href") && J.attr("href", dt), J.animate(xt)) : this.plotBGImage = j.image(dt, pt, lt, ut, mt).add())), gt ? gt.animate({
                            width: ct.width,
                            height: ct.height
                        }) : this.clipRect = j.clipRect(ct), St = "animate", vt || (St = "attr", this.plotBorder = vt = j.rect().addClass("highcharts-plot-border").attr({
                            zIndex: 1
                        }).add()), q || vt.attr({
                            stroke: D.plotBorderColor,
                            "stroke-width": D.plotBorderWidth || 0,
                            fill: "none"
                        }), vt[St](vt.crisp({
                            x: pt,
                            y: lt,
                            width: ut,
                            height: mt
                        }, -vt.strokeWidth())), this.isDirtyBox = !1, B(this, "afterDrawChartBox")
                    }
                    propFromSeries() {
                        let D, j, F, H = this,
                            q = H.options.chart,
                            J = H.options.series;
                        ["inverted", "angular", "polar"].forEach(function(at) {
                            for (j = u[q.type], F = q[at] || j && j.prototype[at], D = J && J.length; !F && D--;)(j = u[J[D].type]) && j.prototype[at] && (F = !0);
                            H[at] = F
                        })
                    }
                    linkSeries(D) {
                        let j = this,
                            F = j.series;
                        F.forEach(function(H) {
                            H.linkedSeries.length = 0
                        }), F.forEach(function(H) {
                            let q = H.options.linkedTo;
                            z(q) && (q = q === ":previous" ? j.series[H.index - 1] : j.get(q)) && q.linkedParent !== H && (q.linkedSeries.push(H), H.linkedParent = q, q.enabledDataSorting && H.setDataSortingOptions(), H.visible = v(H.options.visible, q.options.visible, H.visible))
                        }), B(this, "afterLinkSeries", {
                            isUpdating: D
                        })
                    }
                    renderSeries() {
                        this.series.forEach(function(D) {
                            D.translate(), D.render()
                        })
                    }
                    render() {
                        let D = this.axes,
                            j = this.colorAxis,
                            F = this.renderer,
                            H = function(pt) {
                                pt.forEach(function(lt) {
                                    lt.visible && lt.render()
                                })
                            },
                            q = 0;
                        this.setTitle(), B(this, "beforeMargins"), this.getStacks && this.getStacks(), this.getMargins(!0), this.setChartSize();
                        let J = this.plotWidth;
                        D.some(function(pt) {
                            if (pt.horiz && pt.visible && pt.options.labels.enabled && pt.series.length) return q = 21, !0
                        }), this.plotHeight = Math.max(this.plotHeight - q, 0);
                        let at = this.plotHeight;
                        D.forEach(function(pt) {
                            pt.setScale()
                        }), this.getAxisMargins();
                        let tt = J / this.plotWidth > 1.1,
                            dt = at / this.plotHeight > 1.05;
                        (tt || dt) && (D.forEach(function(pt) {
                            (pt.horiz && tt || !pt.horiz && dt) && pt.setTickInterval(!0)
                        }), this.getMargins()), this.drawChartBox(), this.hasCartesianSeries ? H(D) : j && j.length && H(j), this.seriesGroup || (this.seriesGroup = F.g("series-group").attr({
                            zIndex: 3
                        }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = !0
                    }
                    addCredits(D) {
                        let j = this,
                            F = W(!0, this.options.credits, D);
                        F.enabled && !this.credits && (this.credits = this.renderer.text(F.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
                            F.href && (h.location.href = F.href)
                        }).attr({
                            align: F.position.align,
                            zIndex: 8
                        }), j.styledMode || this.credits.css(F.style), this.credits.add().align(F.position), this.credits.update = function(H) {
                            j.credits = j.credits.destroy(), j.addCredits(H)
                        })
                    }
                    destroy() {
                        let D, j = this,
                            F = j.axes,
                            H = j.series,
                            q = j.container,
                            J = q && q.parentNode;
                        for (B(j, "destroy"), j.renderer.forExport ? d(P, j) : P[j.index] = void 0, nt.chartCount--, j.renderTo.removeAttribute("data-highcharts-chart"), w(j), D = F.length; D--;) F[D] = F[D].destroy();
                        for (this.scroller && this.scroller.destroy && this.scroller.destroy(), D = H.length; D--;) H[D] = H[D].destroy();
                        ["title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer"].forEach(function(at) {
                            let tt = j[at];
                            tt && tt.destroy && (j[at] = tt.destroy())
                        }), q && (q.innerHTML = E.emptyHTML, w(q), J && O(q)), a(j, function(at, tt) {
                            delete j[tt]
                        })
                    }
                    firstRender() {
                        let D = this,
                            j = D.options;
                        D.getContainer(), D.resetMargins(), D.setChartSize(), D.propFromSeries(), D.getAxes();
                        let F = c(j.series) ? j.series : [];
                        j.series = [], F.forEach(function(H) {
                            D.initSeries(H)
                        }), D.linkSeries(), D.setSeriesData(), B(D, "beforeRender"), D.render(), D.pointer.getChartPosition(), D.renderer.imgCount || D.hasLoaded || D.onload(), D.temporaryDisplay(!0)
                    }
                    onload() {
                        this.callbacks.concat([this.callback]).forEach(function(D) {
                            D && this.index !== void 0 && D.apply(this, [this])
                        }, this), B(this, "load"), B(this, "render"), p(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = !0
                    }
                    warnIfA11yModuleNotLoaded() {
                        let {
                            options: D,
                            title: j
                        } = this;
                        !D || this.accessibility || (this.renderer.boxWrapper.attr({
                            role: "img",
                            "aria-label": (j && j.element.textContent || "").replace(/</g, "&lt;")
                        }), D.accessibility && D.accessibility.enabled === !1 || A('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this))
                    }
                    addSeries(D, j, F) {
                        let H, q = this;
                        return D && (j = v(j, !0), B(q, "addSeries", {
                            options: D
                        }, function() {
                            H = q.initSeries(D), q.isDirtyLegend = !0, q.linkSeries(), H.enabledDataSorting && H.setData(D.data, !1), B(q, "afterAddSeries", {
                                series: H
                            }), j && q.redraw(F)
                        })), H
                    }
                    addAxis(D, j, F, H) {
                        return this.createAxis(j ? "xAxis" : "yAxis", {
                            axis: D,
                            redraw: F,
                            animation: H
                        })
                    }
                    addColorAxis(D, j, F) {
                        return this.createAxis("colorAxis", {
                            axis: D,
                            redraw: j,
                            animation: F
                        })
                    }
                    createAxis(D, j) {
                        let F = new Q(this, j.axis, D);
                        return v(j.redraw, !0) && this.redraw(j.animation), F
                    }
                    showLoading(D) {
                        let j = this,
                            F = j.options,
                            H = F.loading,
                            q = function() {
                                J && s(J, {
                                    left: j.plotLeft + "px",
                                    top: j.plotTop + "px",
                                    width: j.plotWidth + "px",
                                    height: j.plotHeight + "px"
                                })
                            },
                            J = j.loadingDiv,
                            at = j.loadingSpan;
                        J || (j.loadingDiv = J = i("div", {
                            className: "highcharts-loading highcharts-loading-hidden"
                        }, null, j.container)), at || (j.loadingSpan = at = i("span", {
                            className: "highcharts-loading-inner"
                        }, null, J), e(j, "redraw", q)), J.className = "highcharts-loading", E.setElementHTML(at, v(D, F.lang.loading, "")), j.styledMode || (s(J, L(H.style, {
                            zIndex: 10
                        })), s(at, H.labelStyle), j.loadingShown || (s(J, {
                            opacity: 0,
                            display: ""
                        }), M(J, {
                            opacity: H.style.opacity || .5
                        }, {
                            duration: H.showDuration || 0
                        }))), j.loadingShown = !0, q()
                    }
                    hideLoading() {
                        let D = this.options,
                            j = this.loadingDiv;
                        j && (j.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || M(j, {
                            opacity: 0
                        }, {
                            duration: D.loading.hideDuration || 100,
                            complete: function() {
                                s(j, {
                                    display: "none"
                                })
                            }
                        })), this.loadingShown = !1
                    }
                    update(D, j, F, H) {
                        let q, J, at, tt = this,
                            dt = {
                                credits: "addCredits",
                                title: "setTitle",
                                subtitle: "setSubtitle",
                                caption: "setCaption"
                            },
                            pt = D.isResponsiveOptions,
                            lt = [];
                        B(tt, "update", {
                            options: D
                        }), pt || tt.setResponsive(!1, !0), D = x(D, tt.options), tt.userOptions = W(tt.userOptions, D);
                        let ut = D.chart;
                        ut && (W(!0, tt.options.chart, ut), this.setZoomOptions(), "className" in ut && tt.setClassName(ut.className), ("inverted" in ut || "polar" in ut || "type" in ut) && (tt.propFromSeries(), q = !0), "alignTicks" in ut && (q = !0), "events" in ut && T(this, ut), a(ut, function(gt, ct) {
                            tt.propsRequireUpdateSeries.indexOf("chart." + ct) !== -1 && (J = !0), tt.propsRequireDirtyBox.indexOf(ct) !== -1 && (tt.isDirtyBox = !0), tt.propsRequireReflow.indexOf(ct) !== -1 && (pt ? tt.isDirtyBox = !0 : at = !0)
                        }), !tt.styledMode && ut.style && tt.renderer.setStyle(tt.options.chart.style || {})), !tt.styledMode && D.colors && (this.options.colors = D.colors), D.time && (this.time === m && (this.time = new S(D.time)), W(!0, tt.options.time, D.time)), a(D, function(gt, ct) {
                            tt[ct] && typeof tt[ct].update == "function" ? tt[ct].update(gt, !1) : typeof tt[dt[ct]] == "function" ? tt[dt[ct]](gt) : ct !== "colors" && tt.collectionsWithUpdate.indexOf(ct) === -1 && W(!0, tt.options[ct], D[ct]), ct !== "chart" && tt.propsRequireUpdateSeries.indexOf(ct) !== -1 && (J = !0)
                        }), this.collectionsWithUpdate.forEach(function(gt) {
                            D[gt] && (G(D[gt]).forEach(function(ct, bt) {
                                let yt, vt = p(ct.id);
                                vt && (yt = tt.get(ct.id)), !yt && tt[gt] && (yt = tt[gt][v(ct.index, bt)]) && (vt && p(yt.options.id) || yt.options.isInternal) && (yt = void 0), yt && yt.coll === gt && (yt.update(ct, !1), F && (yt.touched = !0)), !yt && F && tt.collectionsWithInit[gt] && (tt.collectionsWithInit[gt][0].apply(tt, [ct].concat(tt.collectionsWithInit[gt][1] || []).concat([!1])).touched = !0)
                            }), F && tt[gt].forEach(function(ct) {
                                ct.touched || ct.options.isInternal ? delete ct.touched : lt.push(ct)
                            }))
                        }), lt.forEach(function(gt) {
                            gt.chart && gt.remove && gt.remove(!1)
                        }), q && tt.axes.forEach(function(gt) {
                            gt.update({}, !1)
                        }), J && tt.getSeriesOrderByLinks().forEach(function(gt) {
                            gt.chart && gt.update({}, !1)
                        }, this);
                        let mt = ut && ut.width,
                            xt = ut && (z(ut.height) ? I(ut.height, mt || tt.chartWidth) : ut.height);
                        at || b(mt) && mt !== tt.chartWidth || b(xt) && xt !== tt.chartHeight ? tt.setSize(mt, xt, H) : v(j, !0) && tt.redraw(H), B(tt, "afterUpdate", {
                            options: D,
                            redraw: j,
                            animation: H
                        })
                    }
                    setSubtitle(D, j) {
                        this.applyDescription("subtitle", D), this.layOutTitles(j)
                    }
                    setCaption(D, j) {
                        this.applyDescription("caption", D), this.layOutTitles(j)
                    }
                    showResetZoom() {
                        let D = this,
                            j = f.lang,
                            F = D.zooming.resetButton,
                            H = F.theme,
                            q = F.relativeTo === "chart" || F.relativeTo === "spacingBox" ? null : "scrollablePlotBox";

                        function J() {
                            D.zoomOut()
                        }
                        B(this, "beforeShowResetZoom", null, function() {
                            D.resetZoomButton = D.renderer.button(j.resetZoom, null, null, J, H).attr({
                                align: F.position.align,
                                title: j.resetZoomTitle
                            }).addClass("highcharts-reset-zoom").add().align(F.position, !1, q)
                        }), B(this, "afterShowResetZoom")
                    }
                    zoomOut() {
                        B(this, "selection", {
                            resetSelection: !0
                        }, this.zoom)
                    }
                    zoom(D) {
                        let j = this,
                            F = j.pointer,
                            H = !1,
                            q;
                        !D || D.resetSelection ? (j.axes.forEach(function(at) {
                            q = at.zoom()
                        }), F.initiated = !1) : D.xAxis.concat(D.yAxis).forEach(function(at) {
                            let tt = at.axis,
                                dt = tt.isXAxis,
                                {
                                    hasPinched: pt,
                                    mouseDownX: lt,
                                    mouseDownY: ut
                                } = F;
                            (F[dt ? "zoomX" : "zoomY"] && p(lt) && p(ut) && j.isInsidePlot(lt - j.plotLeft, ut - j.plotTop, {
                                axis: tt,
                                ignoreX: pt,
                                ignoreY: pt
                            }) || !p(j.inverted ? lt : ut)) && (q = tt.zoom(at.min, at.max), tt.displayBtn && (H = !0))
                        });
                        let J = j.resetZoomButton;
                        H && !J ? j.showResetZoom() : !H && N(J) && (j.resetZoomButton = J.destroy()), q && j.redraw(v(j.options.chart.animation, D && D.animation, j.pointCount < 100))
                    }
                    pan(D, j) {
                        let F, H = this,
                            q = H.hoverPoints,
                            J = typeof j == "object" ? j : {
                                enabled: j,
                                type: "x"
                            },
                            at = H.options.chart;
                        at && at.panning && (at.panning = J);
                        let tt = J.type;
                        B(this, "pan", {
                            originalEvent: D
                        }, function() {
                            q && q.forEach(function(lt) {
                                lt.setState()
                            });
                            let dt = H.xAxis;
                            tt === "xy" ? dt = dt.concat(H.yAxis) : tt === "y" && (dt = H.yAxis);
                            let pt = {};
                            dt.forEach(function(lt) {
                                if (!lt.options.panningEnabled || lt.options.isInternal) return;
                                let ut = lt.horiz,
                                    mt = D[ut ? "chartX" : "chartY"],
                                    xt = ut ? "mouseDownX" : "mouseDownY",
                                    gt = H[xt],
                                    ct = lt.minPointOffset || 0,
                                    bt = lt.reversed && !H.inverted || !lt.reversed && H.inverted ? -1 : 1,
                                    yt = lt.getExtremes(),
                                    vt = lt.toValue(gt - mt, !0) + ct * bt,
                                    Mt = lt.toValue(gt + lt.len - mt, !0) - (ct * bt || lt.isXAxis && lt.pointRangePadding || 0),
                                    kt = Mt < vt,
                                    wt = lt.hasVerticalPanning(),
                                    St = kt ? Mt : vt,
                                    At = kt ? vt : Mt,
                                    Ct = lt.panningState,
                                    Lt;
                                wt && !lt.isXAxis && (!Ct || Ct.isDirty) && lt.series.forEach(function(Dt) {
                                    let zt = Dt.getProcessedData(!0),
                                        jt = Dt.getExtremes(zt.yData, !0);
                                    Ct || (Ct = {
                                        startMin: Number.MAX_VALUE,
                                        startMax: -Number.MAX_VALUE
                                    }), b(jt.dataMin) && b(jt.dataMax) && (Ct.startMin = Math.min(v(Dt.options.threshold, 1 / 0), jt.dataMin, Ct.startMin), Ct.startMax = Math.max(v(Dt.options.threshold, -1 / 0), jt.dataMax, Ct.startMax))
                                });
                                let Ot = Math.min(v(Ct && Ct.startMin, yt.dataMin), ct ? yt.min : lt.toValue(lt.toPixels(yt.min) - lt.minPixelPadding)),
                                    Et = Math.max(v(Ct && Ct.startMax, yt.dataMax), ct ? yt.max : lt.toValue(lt.toPixels(yt.max) + lt.minPixelPadding));
                                lt.panningState = Ct, lt.isOrdinal || ((Lt = Ot - St) > 0 && (At += Lt, St = Ot), (Lt = At - Et) > 0 && (At = Et, St -= Lt), lt.series.length && St !== yt.min && At !== yt.max && St >= Ot && At <= Et && (lt.setExtremes(St, At, !1, !1, {
                                    trigger: "pan"
                                }), !H.resetZoomButton && St !== Ot && At !== Et && tt.match("y") && (H.showResetZoom(), lt.displayBtn = !1), F = !0), pt[xt] = mt)
                            }), a(pt, (lt, ut) => {
                                H[ut] = lt
                            }), F && H.redraw(!1), s(H.container, {
                                cursor: "move"
                            })
                        })
                    }
                }
                return L($.prototype, {
                    callbacks: [],
                    collectionsWithInit: {
                        xAxis: [$.prototype.addAxis, [!0]],
                        yAxis: [$.prototype.addAxis, [!1]],
                        series: [$.prototype.addSeries]
                    },
                    collectionsWithUpdate: ["xAxis", "yAxis", "series"],
                    propsRequireDirtyBox: ["backgroundColor", "borderColor", "borderWidth", "borderRadius", "plotBackgroundColor", "plotBackgroundImage", "plotBorderColor", "plotBorderWidth", "plotShadow", "shadow"],
                    propsRequireReflow: ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "spacing", "spacingTop", "spacingRight", "spacingBottom", "spacingLeft"],
                    propsRequireUpdateSeries: ["chart.inverted", "chart.polar", "chart.ignoreHiddenSeries", "chart.type", "colors", "plotOptions", "time", "tooltip"]
                }), $
            }), ft(Y, "Extensions/ScrollablePlotArea.js", [Y["Core/Animation/AnimationUtilities.js"], Y["Core/Axis/Axis.js"], Y["Core/Chart/Chart.js"], Y["Core/Series/Series.js"], Y["Core/Renderer/RendererRegistry.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt, it, nt) {
                let {
                    stop: ot
                } = et, {
                    addEvent: K,
                    createElement: Z,
                    defined: U,
                    merge: S,
                    pick: R
                } = nt;
                K(ht, "afterSetChartSize", function(E) {
                    let M = this.options.chart.scrollablePlotArea,
                        k = M && M.minWidth,
                        g = M && M.minHeight,
                        f, m, C;
                    this.renderer.forExport || (k ? (this.scrollablePixelsX = f = Math.max(0, k - this.chartWidth), f && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = S(this.plotBox), this.plotBox.width = this.plotWidth += f, this.inverted ? this.clipBox.height += f : this.clipBox.width += f, C = {
                        1: {
                            name: "right",
                            value: f
                        }
                    })) : g && (this.scrollablePixelsY = m = Math.max(0, g - this.chartHeight), U(m) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = S(this.plotBox), this.plotBox.height = this.plotHeight += m, this.inverted ? this.clipBox.width += m : this.clipBox.height += m, C = {
                        2: {
                            name: "bottom",
                            value: m
                        }
                    })), C && !E.skipAxes && this.axes.forEach(function(T) {
                        C[T.side] ? T.getPlotLinePath = function() {
                            let P = C[T.side].name,
                                o = C[T.side].value,
                                l = this[P],
                                n;
                            return this[P] = l - o, n = Q.prototype.getPlotLinePath.apply(this, arguments), this[P] = l, n
                        } : (T.setAxisSize(), T.setAxisTranslation())
                    }))
                }), K(ht, "render", function() {
                    this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed()
                }), ht.prototype.setUpScrolling = function() {
                    let E, M = {
                        WebkitOverflowScrolling: "touch",
                        overflowX: "hidden",
                        overflowY: "hidden"
                    };
                    this.scrollablePixelsX && (M.overflowX = "auto"), this.scrollablePixelsY && (M.overflowY = "auto"), this.scrollingParent = Z("div", {
                        className: "highcharts-scrolling-parent"
                    }, {
                        position: "relative"
                    }, this.renderTo), this.scrollingContainer = Z("div", {
                        className: "highcharts-scrolling"
                    }, M, this.scrollingParent), K(this.scrollingContainer, "scroll", () => {
                        this.pointer && (delete this.pointer.chartPosition, this.hoverPoint && (E = this.hoverPoint), this.pointer.runPointActions(void 0, E, !0))
                    }), this.innerContainer = Z("div", {
                        className: "highcharts-inner-container"
                    }, null, this.scrollingContainer), this.innerContainer.appendChild(this.container), this.setUpScrolling = null
                }, ht.prototype.moveFixedElements = function() {
                    let E = this.container,
                        M = this.fixedRenderer,
                        k = [".highcharts-breadcrumbs-group", ".highcharts-contextbutton", ".highcharts-credits", ".highcharts-legend", ".highcharts-legend-checkbox", ".highcharts-navigator-series", ".highcharts-navigator-xaxis", ".highcharts-navigator-yaxis", ".highcharts-navigator", ".highcharts-reset-zoom", ".highcharts-drillup-button", ".highcharts-scrollbar", ".highcharts-subtitle", ".highcharts-title"],
                        g;
                    this.scrollablePixelsX && !this.inverted ? g = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted || this.scrollablePixelsY && !this.inverted ? g = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (g = ".highcharts-yaxis"), g && k.push(`${g}:not(.highcharts-radial-axis)`, `${g}-labels:not(.highcharts-radial-axis-labels)`), k.forEach(function(f) {
                        [].forEach.call(E.querySelectorAll(f), function(m) {
                            (m.namespaceURI === M.SVG_NS ? M.box : M.box.parentNode).appendChild(m), m.style.pointerEvents = "auto"
                        })
                    })
                }, ht.prototype.applyFixed = function() {
                    let E, M, k, g = !this.fixedDiv,
                        f = this.options.chart,
                        m = f.scrollablePlotArea,
                        C = it.getRendererType();
                    g ? (this.fixedDiv = Z("div", {
                        className: "highcharts-fixed"
                    }, {
                        position: "absolute",
                        overflow: "hidden",
                        pointerEvents: "none",
                        zIndex: (f.style && f.style.zIndex || 0) + 2,
                        top: 0
                    }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = E = new C(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = E.path().attr({
                        fill: this.options.chart.backgroundColor || "#fff",
                        "fill-opacity": R(m.opacity, .85),
                        zIndex: -1
                    }).addClass("highcharts-scrollable-mask").add(), K(this, "afterShowResetZoom", this.moveFixedElements), K(this, "afterApplyDrilldown", this.moveFixedElements), K(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight), (this.scrollableDirty || g) && (this.scrollableDirty = !1, this.moveFixedElements()), M = this.chartWidth + (this.scrollablePixelsX || 0), k = this.chartHeight + (this.scrollablePixelsY || 0), ot(this.container), this.container.style.width = M + "px", this.container.style.height = k + "px", this.renderer.boxWrapper.attr({
                        width: M,
                        height: k,
                        viewBox: [0, 0, M, k].join(" ")
                    }), this.chartBackground.attr({
                        width: M,
                        height: k
                    }), this.scrollingContainer.style.height = this.chartHeight + "px", g && (m.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * m.scrollPositionX), m.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * m.scrollPositionY));
                    let T = this.axisOffset,
                        P = this.plotTop - T[0] - 1,
                        o = this.plotLeft - T[3] - 1,
                        l = this.plotTop + this.plotHeight + T[2] + 1,
                        n = this.plotLeft + this.plotWidth + T[1] + 1,
                        h = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
                        u = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0),
                        e;
                    e = this.scrollablePixelsX ? [
                        ["M", 0, P],
                        ["L", this.plotLeft - 1, P],
                        ["L", this.plotLeft - 1, l],
                        ["L", 0, l],
                        ["Z"],
                        ["M", h, P],
                        ["L", this.chartWidth, P],
                        ["L", this.chartWidth, l],
                        ["L", h, l],
                        ["Z"]
                    ] : this.scrollablePixelsY ? [
                        ["M", o, 0],
                        ["L", o, this.plotTop - 1],
                        ["L", n, this.plotTop - 1],
                        ["L", n, 0],
                        ["Z"],
                        ["M", o, u],
                        ["L", o, this.chartHeight],
                        ["L", n, this.chartHeight],
                        ["L", n, u],
                        ["Z"]
                    ] : [
                        ["M", 0, 0]
                    ], this.redrawTrigger !== "adjustHeight" && this.scrollableMask.attr({
                        d: e
                    })
                }, K(Q, "afterInit", function() {
                    this.chart.scrollableDirty = !0
                }), K(rt, "show", function() {
                    this.chart.scrollableDirty = !0
                })
            }), ft(Y, "Core/Axis/Stacking/StackItem.js", [Y["Core/Templating.js"], Y["Core/Series/SeriesRegistry.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                let {
                    format: rt
                } = et, {
                    series: it
                } = Q, {
                    destroyObjectProperties: nt,
                    fireEvent: ot,
                    isNumber: K,
                    pick: Z
                } = ht;
                return class {
                    constructor(U, S, R, E, M) {
                        let k = U.chart.inverted,
                            g = U.reversed;
                        this.axis = U;
                        let f = this.isNegative = !!R != !!g;
                        this.options = S = S || {}, this.x = E, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = !1, this.stack = M, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = {
                            align: S.align || (k ? f ? "left" : "right" : "center"),
                            verticalAlign: S.verticalAlign || (k ? "middle" : f ? "bottom" : "top"),
                            y: S.y,
                            x: S.x
                        }, this.textAlign = S.textAlign || (k ? f ? "right" : "left" : "center")
                    }
                    destroy() {
                        nt(this, this.axis)
                    }
                    render(U) {
                        let S = this.axis.chart,
                            R = this.options,
                            E = R.format,
                            M = E ? rt(E, this, S) : R.formatter.call(this);
                        if (this.label) this.label.attr({
                            text: M,
                            visibility: "hidden"
                        });
                        else {
                            this.label = S.renderer.label(M, null, void 0, R.shape, void 0, void 0, R.useHTML, !1, "stack-labels");
                            let k = {
                                r: R.borderRadius || 0,
                                text: M,
                                padding: Z(R.padding, 5),
                                visibility: "hidden"
                            };
                            S.styledMode || (k.fill = R.backgroundColor, k.stroke = R.borderColor, k["stroke-width"] = R.borderWidth, this.label.css(R.style || {})), this.label.attr(k), this.label.added || this.label.add(U)
                        }
                        this.label.labelrank = S.plotSizeY, ot(this, "afterRender")
                    }
                    setOffset(U, S, R, E, M, k) {
                        let {
                            alignOptions: g,
                            axis: f,
                            label: m,
                            options: C,
                            textAlign: T
                        } = this, P = f.chart, o = this.getStackBox({
                            xOffset: U,
                            width: S,
                            boxBottom: R,
                            boxTop: E,
                            defaultX: M,
                            xAxis: k
                        }), {
                            verticalAlign: l
                        } = g;
                        if (m && o) {
                            let n = m.getBBox(),
                                h = m.padding,
                                u = Z(C.overflow, "justify") === "justify",
                                e;
                            g.x = C.x || 0, g.y = C.y || 0;
                            let {
                                x: t,
                                y: i
                            } = this.adjustStackPosition({
                                labelBox: n,
                                verticalAlign: l,
                                textAlign: T
                            });
                            o.x -= t, o.y -= i, m.align(g, !1, o), (e = P.isInsidePlot(m.alignAttr.x + g.x + t, m.alignAttr.y + g.y + i)) || (u = !1), u && it.prototype.justifyDataLabel.call(f, m, g, m.alignAttr, n, o), m.attr({
                                x: m.alignAttr.x,
                                y: m.alignAttr.y,
                                rotation: C.rotation,
                                rotationOriginX: n.width / 2,
                                rotationOriginY: n.height / 2
                            }), Z(!u && C.crop, !0) && (e = K(m.x) && K(m.y) && P.isInsidePlot(m.x - h + (m.width || 0), m.y) && P.isInsidePlot(m.x + h, m.y)), m[e ? "show" : "hide"]()
                        }
                        ot(this, "afterSetOffset", {
                            xOffset: U,
                            width: S
                        })
                    }
                    adjustStackPosition({
                                            labelBox: U,
                                            verticalAlign: S,
                                            textAlign: R
                                        }) {
                        let E = {
                                bottom: 0,
                                middle: 1,
                                top: 2,
                                right: 1,
                                center: 0,
                                left: -1
                            },
                            M = E[S],
                            k = E[R];
                        return {
                            x: U.width / 2 + U.width / 2 * k,
                            y: U.height / 2 * M
                        }
                    }
                    getStackBox(U) {
                        let S = this.axis,
                            R = S.chart,
                            {
                                boxTop: E,
                                defaultX: M,
                                xOffset: k,
                                width: g,
                                boxBottom: f
                            } = U,
                            m = S.stacking.usePercentage ? 100 : Z(E, this.total, 0),
                            C = S.toPixels(m),
                            T = U.xAxis || R.xAxis[0],
                            P = Z(M, T.translate(this.x)) + k,
                            o = S.toPixels(f || K(S.min) && S.logarithmic && S.logarithmic.lin2log(S.min) || 0),
                            l = Math.abs(C - o),
                            n = R.inverted,
                            h = this.isNegative;
                        return n ? {
                            x: (h ? C : C - l) - R.plotLeft,
                            y: T.height - P - g,
                            width: l,
                            height: g
                        } : {
                            x: P + T.transB - R.plotLeft,
                            y: (h ? C - l : C) - R.plotTop,
                            width: g,
                            height: l
                        }
                    }
                }
            }), ft(Y, "Core/Axis/Stacking/StackingAxis.js", [Y["Core/Animation/AnimationUtilities.js"], Y["Core/Axis/Axis.js"], Y["Core/Series/SeriesRegistry.js"], Y["Core/Axis/Stacking/StackItem.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt, it) {
                var nt;
                let {
                    getDeferredAnimation: ot
                } = et, {
                    series: {
                        prototype: K
                    }
                } = ht, {
                    addEvent: Z,
                    correctFloat: U,
                    defined: S,
                    destroyObjectProperties: R,
                    fireEvent: E,
                    isArray: M,
                    isNumber: k,
                    objectEach: g,
                    pick: f
                } = it;

                function m() {
                    let e = this.inverted;
                    this.axes.forEach(t => {
                        t.stacking && t.stacking.stacks && t.hasVisibleSeries && (t.stacking.oldStacks = t.stacking.stacks)
                    }), this.series.forEach(t => {
                        let i = t.xAxis && t.xAxis.options || {};
                        t.options.stacking && t.reserveSpace() && (t.stackKey = [t.type, f(t.options.stack, ""), e ? i.top : i.left, e ? i.height : i.width].join(","))
                    })
                }

                function C() {
                    var t;
                    let e = this.stacking;
                    if (e) {
                        let i = e.stacks;
                        g(i, (s, p) => {
                            R(s), delete i[p]
                        }), (t = e.stackTotalGroup) == null || t.destroy()
                    }
                }

                function T() {
                    this.stacking || (this.stacking = new u(this))
                }

                function P(e, t, i, s) {
                    return !S(e) || e.x !== t || s && e.stackKey !== s ? e = {
                        x: t,
                        index: 0,
                        key: s,
                        stackKey: s
                    } : e.index++, e.key = [i, t, e.index].join(","), e
                }

                function o() {
                    let e, t = this,
                        i = t.yAxis,
                        s = t.stackKey || "",
                        p = i.stacking.stacks,
                        x = t.processedXData,
                        O = t.options.stacking,
                        d = t[O + "Stacker"];
                    d && [s, "-" + s].forEach(A => {
                        var c;
                        let L = x.length,
                            V, B, r;
                        for (; L--;) V = x[L], e = t.getStackIndicator(e, V, t.index, A), B = (c = p[A]) == null ? void 0 : c[V], (r = B == null ? void 0 : B.points[e.key || ""]) && d.call(t, r, B, L)
                    })
                }

                function l(e, t, i) {
                    let s = t.total ? 100 / t.total : 0;
                    e[0] = U(e[0] * s), e[1] = U(e[1] * s), this.stackedYData[i] = e[1]
                }

                function n(e) {
                    this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && this.chart.series.length > 1 ? K.setStackedPoints.call(this, e, "group") : e.stacking.resetStacks()
                }

                function h(e, t) {
                    var $, st;
                    let i, s, p, x, O, d, A, L, V, B = t || this.options.stacking;
                    if (!B || !this.reserveSpace() || ({
                        group: "xAxis"
                    } [B] || "yAxis") !== e.coll) return;
                    let r = this.processedXData,
                        c = this.processedYData,
                        b = [],
                        N = c.length,
                        z = this.options,
                        W = z.threshold || 0,
                        a = z.startFromThreshold ? W : 0,
                        v = z.stack,
                        y = t ? `${this.type},${B}` : this.stackKey || "",
                        I = "-" + y,
                        w = this.negStacks,
                        G = e.stacking,
                        X = G.stacks,
                        _ = G.oldStacks;
                    for (G.stacksTouched += 1, A = 0; A < N; A++) {
                        L = r[A], V = c[A], d = (i = this.getStackIndicator(i, L, this.index)).key || "", X[O = (s = w && V < (a ? 0 : W)) ? I : y] || (X[O] = {}), X[O][L] || (($ = _[O]) != null && $[L] ? (X[O][L] = _[O][L], X[O][L].total = null) : X[O][L] = new rt(e, e.options.stackLabels, !!s, L, v)), p = X[O][L], V !== null ? (p.points[d] = p.points[this.index] = [f(p.cumulative, a)], S(p.cumulative) || (p.base = d), p.touched = G.stacksTouched, i.index > 0 && this.singleStacks === !1 && (p.points[d][0] = p.points[this.index + "," + L + ",0"][0])) : (delete p.points[d], delete p.points[this.index]);
                        let D = p.total || 0;
                        B === "percent" ? (x = s ? y : I, D = w && ((st = X[x]) != null && st[L]) ? (x = X[x][L]).total = Math.max(x.total || 0, D) + Math.abs(V) || 0 : U(D + (Math.abs(V) || 0))) : B === "group" ? (M(V) && (V = V[0]), V !== null && D++) : D = U(D + (V || 0)), B === "group" ? p.cumulative = (D || 1) - 1 : p.cumulative = U(f(p.cumulative, a) + (V || 0)), p.total = D, V !== null && (p.points[d].push(p.cumulative), b[A] = p.cumulative, p.hasValidPoints = !0)
                    }
                    B === "percent" && (G.usePercentage = !0), B !== "group" && (this.stackedYData = b), G.oldStacks = {}
                }
                class u {
                    constructor(t) {
                        this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = t
                    }
                    buildStacks() {
                        let t, i, s = this.axis,
                            p = s.series,
                            x = s.coll === "xAxis",
                            O = s.options.reversedStacks,
                            d = p.length;
                        for (this.resetStacks(), this.usePercentage = !1, i = d; i--;) t = p[O ? i : d - i - 1], x && t.setGroupedPoints(s), t.setStackedPoints(s);
                        if (!x)
                            for (i = 0; i < d; i++) p[i].modifyStacks();
                        E(s, "afterBuildStacks")
                    }
                    cleanStacks() {
                        this.oldStacks && (this.stacks = this.oldStacks, g(this.stacks, t => {
                            g(t, i => {
                                i.cumulative = i.total
                            })
                        }))
                    }
                    resetStacks() {
                        g(this.stacks, t => {
                            g(t, (i, s) => {
                                k(i.touched) && i.touched < this.stacksTouched ? (i.destroy(), delete t[s]) : (i.total = null, i.cumulative = null)
                            })
                        })
                    }
                    renderStackTotals() {
                        var A;
                        let t = this.axis,
                            i = t.chart,
                            s = i.renderer,
                            p = this.stacks,
                            x = (A = t.options.stackLabels) == null ? void 0 : A.animation,
                            O = ot(i, x || !1),
                            d = this.stackTotalGroup = this.stackTotalGroup || s.g("stack-labels").attr({
                                zIndex: 6,
                                opacity: 0
                            }).add();
                        d.translate(i.plotLeft, i.plotTop), g(p, L => {
                            g(L, V => {
                                V.render(d)
                            })
                        }), d.animate({
                            opacity: 1
                        }, O)
                    }
                }
                return function(e) {
                    let t = [];
                    e.compose = function(i, s, p) {
                        if (it.pushUnique(t, i) && (Z(i, "init", T), Z(i, "destroy", C)), it.pushUnique(t, s)) {
                            let x = s.prototype;
                            x.getStacks = m
                        }
                        if (it.pushUnique(t, p)) {
                            let x = p.prototype;
                            x.getStackIndicator = P, x.modifyStacks = o, x.percentStacker = l, x.setGroupedPoints = n, x.setStackedPoints = h
                        }
                    }
                }(nt || (nt = {})), nt
            }), ft(Y, "Series/Line/LineSeries.js", [Y["Core/Series/Series.js"], Y["Core/Series/SeriesRegistry.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                let {
                    defined: rt,
                    merge: it,
                    isObject: nt
                } = ht;
                class ot extends et {
                    constructor() {
                        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0
                    }
                    drawGraph() {
                        let Z = this,
                            U = this.options,
                            S = (this.gappedPath || this.getGraphPath).call(this),
                            R = this.chart.styledMode,
                            E = [
                                ["graph", "highcharts-graph"]
                            ];
                        R || E[0].push(U.lineColor || this.color || "#cccccc", U.dashStyle), (E = Z.getZonesGraphs(E)).forEach(function(M, k) {
                            let g = M[0],
                                f, m = Z[g],
                                C = m ? "animate" : "attr";
                            m ? (m.endX = Z.preventGraphAnimation ? null : S.xMap, m.animate({
                                d: S
                            })) : S.length && (Z[g] = m = Z.chart.renderer.path(S).addClass(M[1]).attr({
                                zIndex: 1
                            }).add(Z.group)), m && !R && (f = {
                                stroke: M[2],
                                "stroke-width": U.lineWidth || 0,
                                fill: Z.fillGraph && Z.color || "none"
                            }, M[3] ? f.dashstyle = M[3] : U.linecap !== "square" && (f["stroke-linecap"] = f["stroke-linejoin"] = "round"), m[C](f).shadow(k < 2 && U.shadow && it({
                                filterUnits: "userSpaceOnUse"
                            }, nt(U.shadow) ? U.shadow : {}))), m && (m.startX = S.xMap, m.isArea = S.isArea)
                        })
                    }
                    getGraphPath(Z, U, S) {
                        let R = this,
                            E = R.options,
                            M = [],
                            k = [],
                            g, f = E.step;
                        Z = Z || R.points;
                        let m = Z.reversed;
                        return m && Z.reverse(), (f = {
                            right: 1,
                            center: 2
                        } [f] || f && 3) && m && (f = 4 - f), (Z = this.getValidPoints(Z, !1, !(E.connectNulls && !U && !S))).forEach(function(C, T) {
                            let P, o = C.plotX,
                                l = C.plotY,
                                n = Z[T - 1],
                                h = C.isNull || typeof l != "number";
                            (C.leftCliff || n && n.rightCliff) && !S && (g = !0), h && !rt(U) && T > 0 ? g = !E.connectNulls : h && !U ? g = !0 : (T === 0 || g ? P = [
                                ["M", C.plotX, C.plotY]
                            ] : R.getPointSpline ? P = [R.getPointSpline(Z, C, T)] : f ? (P = f === 1 ? [
                                ["L", n.plotX, l]
                            ] : f === 2 ? [
                                ["L", (n.plotX + o) / 2, n.plotY],
                                ["L", (n.plotX + o) / 2, l]
                            ] : [
                                ["L", o, n.plotY]
                            ]).push(["L", o, l]) : P = [
                                ["L", o, l]
                            ], k.push(C.x), f && (k.push(C.x), f === 2 && k.push(C.x)), M.push.apply(M, P), g = !1)
                        }), M.xMap = k, R.graphPath = M, M
                    }
                    getZonesGraphs(Z) {
                        return this.zones.forEach(function(U, S) {
                            let R = ["zone-graph-" + S, "highcharts-graph highcharts-zone-graph-" + S + " " + (U.className || "")];
                            this.chart.styledMode || R.push(U.color || this.color, U.dashStyle || this.options.dashStyle), Z.push(R)
                        }, this), Z
                    }
                }
                return ot.defaultOptions = it(et.defaultOptions, {
                    legendSymbol: "lineMarker"
                }), Q.registerSeriesType("line", ot), ot
            }), ft(Y, "Series/Area/AreaSeries.js", [Y["Core/Color/Color.js"], Y["Core/Series/SeriesRegistry.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                let {
                    seriesTypes: {
                        line: rt
                    }
                } = Q, {
                    extend: it,
                    merge: nt,
                    objectEach: ot,
                    pick: K
                } = ht;
                class Z extends rt {
                    constructor() {
                        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0
                    }
                    drawGraph() {
                        this.areaPath = [], super.drawGraph.apply(this);
                        let S = this,
                            R = this.areaPath,
                            E = this.options,
                            M = this.zones,
                            k = [
                                ["area", "highcharts-area", this.color, E.fillColor]
                            ];
                        M.forEach(function(g, f) {
                            k.push(["zone-area-" + f, "highcharts-area highcharts-zone-area-" + f + " " + g.className, g.color || S.color, g.fillColor || E.fillColor])
                        }), k.forEach(function(g) {
                            let f = g[0],
                                m = {},
                                C = S[f],
                                T = C ? "animate" : "attr";
                            C ? (C.endX = S.preventGraphAnimation ? null : R.xMap, C.animate({
                                d: R
                            })) : (m.zIndex = 0, (C = S[f] = S.chart.renderer.path(R).addClass(g[1]).add(S.group)).isArea = !0), S.chart.styledMode || (g[3] ? m.fill = g[3] : (m.fill = g[2], m["fill-opacity"] = K(E.fillOpacity, .75))), C[T](m), C.startX = R.xMap, C.shiftUnit = E.step ? 2 : 1
                        })
                    }
                    getGraphPath(S) {
                        let R, E, M, k = rt.prototype.getGraphPath,
                            g = this.options,
                            f = g.stacking,
                            m = this.yAxis,
                            C = [],
                            T = [],
                            P = this.index,
                            o = m.stacking.stacks[this.stackKey],
                            l = g.threshold,
                            n = Math.round(m.getThreshold(g.threshold)),
                            h = K(g.connectNulls, f === "percent"),
                            u = function(x, O, d) {
                                let A = S[x],
                                    L = f && o[A.x].points[P],
                                    V = A[d + "Null"] || 0,
                                    B = A[d + "Cliff"] || 0,
                                    r, c, b = !0;
                                B || V ? (r = (V ? L[0] : L[1]) + B, c = L[0] + B, b = !!V) : !f && S[O] && S[O].isNull && (r = c = l), r !== void 0 && (T.push({
                                    plotX: R,
                                    plotY: r === null ? n : m.getThreshold(r),
                                    isNull: b,
                                    isCliff: !0
                                }), C.push({
                                    plotX: R,
                                    plotY: c === null ? n : m.getThreshold(c),
                                    doCurve: !1
                                }))
                            };
                        S = S || this.points, f && (S = this.getStackPoints(S));
                        for (let x = 0, O = S.length; x < O; ++x) f || (S[x].leftCliff = S[x].rightCliff = S[x].leftNull = S[x].rightNull = void 0), E = S[x].isNull, R = K(S[x].rectPlotX, S[x].plotX), M = f ? K(S[x].yBottom, n) : n, E && !h || (h || u(x, x - 1, "left"), E && !f && h || (T.push(S[x]), C.push({
                            x,
                            plotX: R,
                            plotY: M
                        })), h || u(x, x + 1, "right"));
                        let e = k.call(this, T, !0, !0);
                        C.reversed = !0;
                        let t = k.call(this, C, !0, !0),
                            i = t[0];
                        i && i[0] === "M" && (t[0] = ["L", i[1], i[2]]);
                        let s = e.concat(t);
                        s.length && s.push(["Z"]);
                        let p = k.call(this, T, !1, h);
                        return s.xMap = e.xMap, this.areaPath = s, p
                    }
                    getStackPoints(S) {
                        let R = this,
                            E = [],
                            M = [],
                            k = this.xAxis,
                            g = this.yAxis,
                            f = g.stacking.stacks[this.stackKey],
                            m = {},
                            C = g.series,
                            T = C.length,
                            P = g.options.reversedStacks ? 1 : -1,
                            o = C.indexOf(R);
                        if (S = S || this.points, this.options.stacking) {
                            for (let n = 0; n < S.length; n++) S[n].leftNull = S[n].rightNull = void 0, m[S[n].x] = S[n];
                            ot(f, function(n, h) {
                                n.total !== null && M.push(h)
                            }), M.sort(function(n, h) {
                                return n - h
                            });
                            let l = C.map(n => n.visible);
                            M.forEach(function(n, h) {
                                let u = 0,
                                    e, t;
                                if (m[n] && !m[n].isNull) E.push(m[n]), [-1, 1].forEach(function(i) {
                                    let s = i === 1 ? "rightNull" : "leftNull",
                                        p = f[M[h + i]],
                                        x = 0;
                                    if (p) {
                                        let O = o;
                                        for (; O >= 0 && O < T;) {
                                            let d = C[O].index;
                                            !(e = p.points[d]) && (d === R.index ? m[n][s] = !0 : l[O] && (t = f[n].points[d]) && (x -= t[1] - t[0])), O += P
                                        }
                                    }
                                    m[n][i === 1 ? "rightCliff" : "leftCliff"] = x
                                });
                                else {
                                    let i = o;
                                    for (; i >= 0 && i < T;) {
                                        let s = C[i].index;
                                        if (e = f[n].points[s]) {
                                            u = e[1];
                                            break
                                        }
                                        i += P
                                    }
                                    u = K(u, 0), u = g.translate(u, 0, 1, 0, 1), E.push({
                                        isNull: !0,
                                        plotX: k.translate(n, 0, 0, 0, 1),
                                        x: n,
                                        plotY: u,
                                        yBottom: u
                                    })
                                }
                            })
                        }
                        return E
                    }
                }
                return Z.defaultOptions = nt(rt.defaultOptions, {
                    threshold: 0,
                    legendSymbol: "rectangle"
                }), it(Z.prototype, {
                    singleStacks: !1
                }), Q.registerSeriesType("area", Z), Z
            }), ft(Y, "Series/Spline/SplineSeries.js", [Y["Core/Series/SeriesRegistry.js"], Y["Core/Utilities.js"]], function(et, Q) {
                let {
                    line: ht
                } = et.seriesTypes, {
                    merge: rt,
                    pick: it
                } = Q;
                class nt extends ht {
                    constructor() {
                        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0
                    }
                    getPointSpline(K, Z, U) {
                        let S, R, E, M, k = Z.plotX || 0,
                            g = Z.plotY || 0,
                            f = K[U - 1],
                            m = K[U + 1];

                        function C(P) {
                            return P && !P.isNull && P.doCurve !== !1 && !Z.isCliff
                        }
                        if (C(f) && C(m)) {
                            let P = f.plotX || 0,
                                o = f.plotY || 0,
                                l = m.plotX || 0,
                                n = m.plotY || 0,
                                h = 0;
                            S = (1.5 * k + P) / 2.5, R = (1.5 * g + o) / 2.5, E = (1.5 * k + l) / 2.5, M = (1.5 * g + n) / 2.5, E !== S && (h = (M - R) * (E - k) / (E - S) + g - M), R += h, M += h, R > o && R > g ? (R = Math.max(o, g), M = 2 * g - R) : R < o && R < g && (R = Math.min(o, g), M = 2 * g - R), M > n && M > g ? (M = Math.max(n, g), R = 2 * g - M) : M < n && M < g && (M = Math.min(n, g), R = 2 * g - M), Z.rightContX = E, Z.rightContY = M, Z.controlPoints = {
                                low: [S, R],
                                high: [E, M]
                            }
                        }
                        let T = ["C", it(f.rightContX, f.plotX, 0), it(f.rightContY, f.plotY, 0), it(S, k, 0), it(R, g, 0), k, g];
                        return f.rightContX = f.rightContY = void 0, T
                    }
                }
                return nt.defaultOptions = rt(ht.defaultOptions), et.registerSeriesType("spline", nt), nt
            }), ft(Y, "Series/AreaSpline/AreaSplineSeries.js", [Y["Series/Spline/SplineSeries.js"], Y["Core/Series/SeriesRegistry.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                let {
                    area: rt,
                    area: {
                        prototype: it
                    }
                } = Q.seriesTypes, {
                    extend: nt,
                    merge: ot
                } = ht;
                class K extends et {
                    constructor() {
                        super(...arguments), this.data = void 0, this.points = void 0, this.options = void 0
                    }
                }
                return K.defaultOptions = ot(et.defaultOptions, rt.defaultOptions), nt(K.prototype, {
                    getGraphPath: it.getGraphPath,
                    getStackPoints: it.getStackPoints,
                    drawGraph: it.drawGraph
                }), Q.registerSeriesType("areaspline", K), K
            }), ft(Y, "Series/Column/ColumnSeriesDefaults.js", [], function() {
                return {
                    borderRadius: 3,
                    centerInCategory: !1,
                    groupPadding: .2,
                    marker: null,
                    pointPadding: .1,
                    minPointLength: 0,
                    cropThreshold: 50,
                    pointRange: null,
                    states: {
                        hover: {
                            halo: !1,
                            brightness: .1
                        },
                        select: {
                            color: "#cccccc",
                            borderColor: "#000000"
                        }
                    },
                    dataLabels: {
                        align: void 0,
                        verticalAlign: void 0,
                        y: void 0
                    },
                    startFromThreshold: !0,
                    stickyTracking: !1,
                    tooltip: {
                        distance: 6
                    },
                    threshold: 0,
                    borderColor: "#ffffff"
                }
            }), ft(Y, "Series/Column/ColumnSeries.js", [Y["Core/Animation/AnimationUtilities.js"], Y["Core/Color/Color.js"], Y["Series/Column/ColumnSeriesDefaults.js"], Y["Core/Globals.js"], Y["Core/Series/Series.js"], Y["Core/Series/SeriesRegistry.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt, it, nt, ot) {
                let {
                    animObject: K
                } = et, {
                    parse: Z
                } = Q, {
                    hasTouch: U,
                    noop: S
                } = rt, {
                    clamp: R,
                    defined: E,
                    extend: M,
                    fireEvent: k,
                    isArray: g,
                    isNumber: f,
                    merge: m,
                    pick: C,
                    objectEach: T,
                    relativeLength: P
                } = ot;
                class o extends it {
                    constructor() {
                        super(...arguments), this.borderWidth = void 0, this.data = void 0, this.group = void 0, this.options = void 0, this.points = void 0
                    }
                    animate(n) {
                        let h, u, e = this,
                            t = this.yAxis,
                            i = t.pos,
                            s = e.options,
                            p = this.chart.inverted,
                            x = {},
                            O = p ? "translateX" : "translateY";
                        n ? (x.scaleY = .001, u = R(t.toPixels(s.threshold), i, i + t.len), p ? x.translateX = u - t.len : x.translateY = u, e.clipBox && e.setClip(), e.group.attr(x)) : (h = Number(e.group.attr(O)), e.group.animate({
                            scaleY: 1
                        }, M(K(e.options.animation), {
                            step: function(d, A) {
                                e.group && (x[O] = h + A.pos * (i - h), e.group.attr(x))
                            }
                        })))
                    }
                    init(n, h) {
                        super.init.apply(this, arguments);
                        let u = this;
                        (n = u.chart).hasRendered && n.series.forEach(function(e) {
                            e.type === u.type && (e.isDirty = !0)
                        })
                    }
                    getColumnMetrics() {
                        var c, b;
                        let n = this,
                            h = n.options,
                            u = n.xAxis,
                            e = n.yAxis,
                            t = u.options.reversedStacks,
                            i = u.reversed && !t || !u.reversed && t,
                            s = {},
                            p, x = 0;
                        h.grouping === !1 ? x = 1 : n.chart.series.forEach(function(N) {
                            let z, W = N.yAxis,
                                a = N.options;
                            N.type === n.type && N.reserveSpace() && e.len === W.len && e.pos === W.pos && (a.stacking && a.stacking !== "group" ? (s[p = N.stackKey] === void 0 && (s[p] = x++), z = s[p]) : a.grouping !== !1 && (z = x++), N.columnIndex = z)
                        });
                        let O = Math.min(Math.abs(u.transA) * (!((c = u.brokenAxis) != null && c.hasBreaks) && ((b = u.ordinal) == null ? void 0 : b.slope) || h.pointRange || u.closestPointRange || u.tickInterval || 1), u.len),
                            d = O * h.groupPadding,
                            A = (O - 2 * d) / (x || 1),
                            L = Math.min(h.maxPointWidth || u.len, C(h.pointWidth, A * (1 - 2 * h.pointPadding))),
                            V = (A - L) / 2,
                            B = (n.columnIndex || 0) + (i ? 1 : 0),
                            r = V + (d + B * A - O / 2) * (i ? -1 : 1);
                        return n.columnMetrics = {
                            width: L,
                            offset: r,
                            paddedWidth: A,
                            columnCount: x
                        }, n.columnMetrics
                    }
                    crispCol(n, h, u, e) {
                        this.chart;
                        let t = this.borderWidth,
                            i = -(t % 2 ? .5 : 0),
                            s = t % 2 ? .5 : 1;
                        this.options.crisp && (u = Math.round(n + u) + i - (n = Math.round(n) + i));
                        let p = Math.round(h + e) + s,
                            x = .5 >= Math.abs(h) && p > .5;
                        return e = p - (h = Math.round(h) + s), x && e && (h -= 1, e += 1), {
                            x: n,
                            y: h,
                            width: u,
                            height: e
                        }
                    }
                    adjustForMissingColumns(n, h, u, e) {
                        var t;
                        if (!u.isNull && e.columnCount > 1) {
                            let i = this.xAxis.series.filter(O => O.visible).map(O => O.index),
                                s = 0,
                                p = 0;
                            T((t = this.xAxis.stacking) == null ? void 0 : t.stacks, O => {
                                if (typeof u.x == "number") {
                                    let d = O[u.x.toString()];
                                    if (d) {
                                        let A = d.points[this.index];
                                        if (g(A)) {
                                            let L = Object.keys(d.points).filter(V => !V.match(",") && d.points[V] && d.points[V].length > 1).map(parseFloat).filter(V => i.indexOf(V) !== -1).sort((V, B) => B - V);
                                            s = L.indexOf(this.index), p = L.length
                                        }
                                    }
                                }
                            });
                            let x = (p - 1) * e.paddedWidth + h;
                            n = (u.plotX || 0) + x / 2 - h - s * e.paddedWidth
                        }
                        return n
                    }
                    translate() {
                        let n = this,
                            h = n.chart,
                            u = n.options,
                            e = n.dense = n.closestPointRange * n.xAxis.transA < 2,
                            t = n.borderWidth = C(u.borderWidth, e ? 0 : 1),
                            i = n.xAxis,
                            s = n.yAxis,
                            p = u.threshold,
                            x = C(u.minPointLength, 5),
                            O = n.getColumnMetrics(),
                            d = O.width,
                            A = n.pointXOffset = O.offset,
                            L = n.dataMin,
                            V = n.dataMax,
                            B = n.barW = Math.max(d, 1 + 2 * t),
                            r = n.translatedThreshold = s.getThreshold(p);
                        h.inverted && (r -= .5), u.pointPadding && (B = Math.ceil(B)), it.prototype.translate.apply(n), n.points.forEach(function(c) {
                            let b = C(c.yBottom, r),
                                N = 999 + Math.abs(b),
                                z = c.plotX || 0,
                                W = R(c.plotY, -N, s.len + N);
                            c.stackBox;
                            let a, v = Math.min(W, b),
                                y = Math.max(W, b) - v,
                                I = d,
                                w = z + A,
                                G = B;
                            x && Math.abs(y) < x && (y = x, a = !s.reversed && !c.negative || s.reversed && c.negative, f(p) && f(V) && c.y === p && V <= p && (s.min || 0) < p && (L !== V || (s.max || 0) <= p) && (a = !a, c.negative = !c.negative), v = Math.abs(v - r) > x ? b - x : r - (a ? x : 0)), E(c.options.pointWidth) && (w -= Math.round(((I = G = Math.ceil(c.options.pointWidth)) - d) / 2)), u.centerInCategory && !u.stacking && (w = n.adjustForMissingColumns(w, I, c, O)), c.barX = w, c.pointWidth = I, c.tooltipPos = h.inverted ? [R(s.len + s.pos - h.plotLeft - W, s.pos - h.plotLeft, s.len + s.pos - h.plotLeft), i.len + i.pos - h.plotTop - w - G / 2, y] : [i.left - h.plotLeft + w + G / 2, R(W + s.pos - h.plotTop, s.pos - h.plotTop, s.len + s.pos - h.plotTop), y], c.shapeType = n.pointClass.prototype.shapeType || "roundedRect", c.shapeArgs = n.crispCol(w, c.isNull ? r : v, G, c.isNull ? 0 : y)
                        }), k(this, "afterColumnTranslate")
                    }
                    drawGraph() {
                        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data")
                    }
                    pointAttribs(n, h) {
                        let u = this.options,
                            e = this.pointAttrToOptions || {},
                            t = e.stroke || "borderColor",
                            i = e["stroke-width"] || "borderWidth",
                            s, p, x, O = n && n.color || this.color,
                            d = n && n[t] || u[t] || O,
                            A = n && n.options.dashStyle || u.dashStyle,
                            L = n && n[i] || u[i] || this[i] || 0,
                            V = C(n && n.opacity, u.opacity, 1);
                        n && this.zones.length && (p = n.getZone(), O = n.options.color || p && (p.color || n.nonZonedColor) || this.color, p && (d = p.borderColor || d, A = p.dashStyle || A, L = p.borderWidth || L)), h && n && (x = (s = m(u.states[h], n.options.states && n.options.states[h] || {})).brightness, O = s.color || x !== void 0 && Z(O).brighten(s.brightness).get() || O, d = s[t] || d, L = s[i] || L, A = s.dashStyle || A, V = C(s.opacity, V));
                        let B = {
                            fill: O,
                            stroke: d,
                            "stroke-width": L,
                            opacity: V
                        };
                        return A && (B.dashstyle = A), B
                    }
                    drawPoints(n = this.points) {
                        let h, u = this,
                            e = this.chart,
                            t = u.options,
                            i = e.renderer,
                            s = t.animationLimit || 250;
                        n.forEach(function(p) {
                            let x = p.plotY,
                                O = p.graphic,
                                d = !!O,
                                A = O && e.pointCount < s ? "animate" : "attr";
                            f(x) && p.y !== null ? (h = p.shapeArgs, O && p.hasNewShapeType() && (O = O.destroy()), u.enabledDataSorting && (p.startXPos = u.xAxis.reversed ? -(h && h.width || 0) : u.xAxis.width), !O && (p.graphic = O = i[p.shapeType](h).add(p.group || u.group), O && u.enabledDataSorting && e.hasRendered && e.pointCount < s && (O.attr({
                                x: p.startXPos
                            }), d = !0, A = "animate")), O && d && O[A](m(h)), e.styledMode || O[A](u.pointAttribs(p, p.selected && "select")).shadow(p.allowShadow !== !1 && t.shadow), O && (O.addClass(p.getClassName(), !0), O.attr({
                                visibility: p.visible ? "inherit" : "hidden"
                            }))) : O && (p.graphic = O.destroy())
                        })
                    }
                    drawTracker(n = this.points) {
                        let h, u = this,
                            e = u.chart,
                            t = e.pointer,
                            i = function(s) {
                                let p = t.getPointFromEvent(s);
                                p !== void 0 && u.options.enableMouseTracking && (t.isDirectTouch = !0, p.onMouseOver(s))
                            };
                        n.forEach(function(s) {
                            h = g(s.dataLabels) ? s.dataLabels : s.dataLabel ? [s.dataLabel] : [], s.graphic && (s.graphic.element.point = s), h.forEach(function(p) {
                                p.div ? p.div.point = s : p.element.point = s
                            })
                        }), u._hasTracking || (u.trackerGroups.forEach(function(s) {
                            u[s] && (u[s].addClass("highcharts-tracker").on("mouseover", i).on("mouseout", function(p) {
                                t.onTrackerMouseOut(p)
                            }), U && u[s].on("touchstart", i), !e.styledMode && u.options.cursor && u[s].css({
                                cursor: u.options.cursor
                            }))
                        }), u._hasTracking = !0), k(this, "afterDrawTracker")
                    }
                    remove() {
                        let n = this,
                            h = n.chart;
                        h.hasRendered && h.series.forEach(function(u) {
                            u.type === n.type && (u.isDirty = !0)
                        }), it.prototype.remove.apply(n, arguments)
                    }
                }
                return o.defaultOptions = m(it.defaultOptions, ht), M(o.prototype, {
                    directTouch: !0,
                    getSymbol: S,
                    negStacks: !0,
                    trackerGroups: ["group", "dataLabelsGroup"]
                }), nt.registerSeriesType("column", o), o
            }), ft(Y, "Core/Series/DataLabel.js", [Y["Core/Animation/AnimationUtilities.js"], Y["Core/Templating.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                var rt;
                let {
                    getDeferredAnimation: it
                } = et, {
                    format: nt
                } = Q, {
                    defined: ot,
                    extend: K,
                    fireEvent: Z,
                    isArray: U,
                    isString: S,
                    merge: R,
                    objectEach: E,
                    pick: M,
                    pInt: k,
                    splat: g
                } = ht;
                return function(f) {
                    let m = [];

                    function C() {
                        return g(this.options.dataLabels || {}).some(e => e == null ? void 0 : e.enabled)
                    }

                    function T(e, t, i, s, p) {
                        let x = this,
                            O = this.chart,
                            d = this.isCartesian && O.inverted,
                            A = this.enabledDataSorting,
                            L = e.plotX,
                            V = e.plotY,
                            B = i.rotation,
                            r = i.align,
                            c = ot(L) && ot(V) && O.isInsidePlot(L, Math.round(V), {
                                inverted: d,
                                paneCoordinates: !0,
                                series: x
                            }),
                            b = I => {
                                A && x.xAxis && !a && x.setDataLabelStartPos(e, t, p, c, I)
                            },
                            N, z, W, a = M(i.overflow, A ? "none" : "justify") === "justify",
                            v = this.visible && e.visible !== !1 && ot(L) && (e.series.forceDL || A && !a || c || M(i.inside, !!this.options.stacking) && s && O.isInsidePlot(L, d ? s.x + 1 : s.y + s.height - 1, {
                                inverted: d,
                                paneCoordinates: !0,
                                series: x
                            })),
                            y = e.pos();
                        if (v && y) {
                            B && t.attr({
                                align: r
                            });
                            let I = t.getBBox(!0),
                                w = [0, 0];
                            if (N = O.renderer.fontMetrics(t).b, s = K({
                                x: y[0],
                                y: Math.round(y[1]),
                                width: 0,
                                height: 0
                            }, s), K(i, {
                                width: I.width,
                                height: I.height
                            }), B ? (a = !1, z = O.renderer.rotCorr(N, B), W = {
                                x: s.x + (i.x || 0) + s.width / 2 + z.x,
                                y: s.y + (i.y || 0) + {
                                    top: 0,
                                    middle: .5,
                                    bottom: 1
                                } [i.verticalAlign] * s.height
                            }, w = [I.x - Number(t.attr("x")), I.y - Number(t.attr("y"))], b(W), t[p ? "attr" : "animate"](W)) : (b(s), t.align(i, void 0, s), W = t.alignAttr), a && s.height >= 0) this.justifyDataLabel(t, i, W, I, s, p);
                            else if (M(i.crop, !0)) {
                                let {
                                    x: G,
                                    y: X
                                } = W;
                                G += w[0], X += w[1], v = O.isInsidePlot(G, X, {
                                    paneCoordinates: !0,
                                    series: x
                                }) && O.isInsidePlot(G + I.width, X + I.height, {
                                    paneCoordinates: !0,
                                    series: x
                                })
                            }
                            i.shape && !B && t[p ? "attr" : "animate"]({
                                anchorX: y[0],
                                anchorY: y[1]
                            })
                        }
                        p && A && (t.placed = !1), v || A && !a ? t.show() : (t.hide(), t.placed = !1)
                    }

                    function P() {
                        return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6)
                    }

                    function o(e) {
                        let t = this.hasRendered || 0,
                            i = this.initDataLabelsGroup().attr({
                                opacity: +t
                            });
                        return !t && i && (this.visible && i.show(), this.options.animation ? i.animate({
                            opacity: 1
                        }, e) : i.attr({
                            opacity: 1
                        })), i
                    }

                    function l(e) {
                        var b, N, z;
                        e = e || this.points;
                        let t = this,
                            i = t.chart,
                            s = t.options,
                            p = i.renderer,
                            {
                                backgroundColor: x,
                                plotBackgroundColor: O
                            } = i.options.chart,
                            d = i.options.plotOptions,
                            A = p.getContrast(S(O) && O || S(x) && x || "#000000"),
                            L = s.dataLabels,
                            V;
                        L = h(h((b = d == null ? void 0 : d.series) == null ? void 0 : b.dataLabels, (N = d == null ? void 0 : d[t.type]) == null ? void 0 : N.dataLabels), L);
                        let {
                            animation: B,
                            defer: r
                        } = g(L)[0], c = r ? it(i, B, t) : {
                            defer: 0,
                            duration: 0
                        };
                        Z(this, "drawDataLabels"), (z = t.hasDataLabels) != null && z.call(t) && (V = this.initDataLabels(c), e.forEach(W => {
                            var y, I;
                            let a = W.dataLabels || [];
                            g(h(L, W.dlOptions || ((y = W.options) == null ? void 0 : y.dataLabels))).forEach((w, G) => {
                                var at;
                                let X = w.enabled && W.visible && (!W.isNull || W.dataLabelOnNull) && function(tt, dt) {
                                        let pt = dt.filter;
                                        if (pt) {
                                            let lt = pt.operator,
                                                ut = tt[pt.property],
                                                mt = pt.value;
                                            return lt === ">" && ut > mt || lt === "<" && ut < mt || lt === ">=" && ut >= mt || lt === "<=" && ut <= mt || lt === "==" && ut == mt || lt === "===" && ut === mt
                                        }
                                        return !0
                                    }(W, w),
                                    _ = w.style || {},
                                    $ = w.distance,
                                    st, D, j, F, H = {},
                                    q = a[G],
                                    J = !q;
                                if (X) {
                                    if (D = M(w[W.formatPrefix + "Format"], w.format), st = W.getLabelConfig(), j = ot(D) ? nt(D, st, i) : (w[W.formatPrefix + "Formatter"] || w.formatter).call(st, w), F = w.rotation, !i.styledMode && (_.color = M(w.color, _.color, S(t.color) ? t.color : void 0, "#000000"), _.color === "contrast" ? (W.contrastColor = p.getContrast(W.color || t.color), _.color = !ot($) && w.inside || 0 > k($ || 0) || s.stacking ? W.contrastColor : A) : delete W.contrastColor, s.cursor && (_.cursor = s.cursor)), H = {
                                        r: w.borderRadius || 0,
                                        rotation: F,
                                        padding: w.padding,
                                        zIndex: 1
                                    }, !i.styledMode) {
                                        let {
                                            backgroundColor: tt,
                                            borderColor: dt
                                        } = w;
                                        H.fill = tt === "auto" ? W.color : tt, H.stroke = dt === "auto" ? W.color : dt, H["stroke-width"] = w.borderWidth
                                    }
                                    E(H, (tt, dt) => {
                                        tt === void 0 && delete H[dt]
                                    })
                                }
                                if (!q || X && ot(j) && !!q.div == !!w.useHTML && (q.rotation && w.rotation || q.rotation === w.rotation) || (q = void 0, J = !0), X && ot(j) && (q ? H.text = j : (q = F ? p.text(j, 0, 0, w.useHTML).addClass("highcharts-data-label") : p.label(j, 0, 0, w.shape, void 0, void 0, w.useHTML, void 0, "data-label")) && q.addClass(" highcharts-data-label-color-" + W.colorIndex + " " + (w.className || "") + (w.useHTML ? " highcharts-tracker" : "")), q)) {
                                    q.options = w, q.attr(H), i.styledMode || q.css(_).shadow(w.shadow);
                                    let tt = w[W.formatPrefix + "TextPath"] || w.textPath;
                                    tt && !w.useHTML && (q.setTextPath(((at = W.getDataLabelPath) == null ? void 0 : at.call(W, q)) || W.graphic, tt), W.dataLabelPath && !tt.enabled && (W.dataLabelPath = W.dataLabelPath.destroy())), q.added || q.add(V), t.alignDataLabel(W, q, w, void 0, J), q.isActive = !0, a[G] && a[G] !== q && a[G].destroy(), a[G] = q
                                }
                            });
                            let v = a.length;
                            for (; v--;) a[v] && a[v].isActive ? a[v].isActive = !1 : ((I = a[v]) == null || I.destroy(), a.splice(v, 1));
                            W.dataLabel = a[0], W.dataLabels = a
                        })), Z(this, "afterDrawDataLabels")
                    }

                    function n(e, t, i, s, p, x) {
                        let O = this.chart,
                            d = t.align,
                            A = t.verticalAlign,
                            L = e.box ? 0 : e.padding || 0,
                            {
                                x: V = 0,
                                y: B = 0
                            } = t,
                            r, c;
                        return (r = (i.x || 0) + L) < 0 && (d === "right" && V >= 0 ? (t.align = "left", t.inside = !0) : V -= r, c = !0), (r = (i.x || 0) + s.width - L) > O.plotWidth && (d === "left" && V <= 0 ? (t.align = "right", t.inside = !0) : V += O.plotWidth - r, c = !0), (r = i.y + L) < 0 && (A === "bottom" && B >= 0 ? (t.verticalAlign = "top", t.inside = !0) : B -= r, c = !0), (r = (i.y || 0) + s.height - L) > O.plotHeight && (A === "top" && B <= 0 ? (t.verticalAlign = "bottom", t.inside = !0) : B += O.plotHeight - r, c = !0), c && (t.x = V, t.y = B, e.placed = !x, e.align(t, void 0, p)), c
                    }

                    function h(e, t) {
                        let i = [],
                            s;
                        if (U(e) && !U(t)) i = e.map(function(p) {
                            return R(p, t)
                        });
                        else if (U(t) && !U(e)) i = t.map(function(p) {
                            return R(e, p)
                        });
                        else if (U(e) || U(t)) {
                            if (U(e) && U(t))
                                for (s = Math.max(e.length, t.length); s--;) i[s] = R(e[s], t[s])
                        } else i = R(e, t);
                        return i
                    }

                    function u(e, t, i, s, p) {
                        let x = this.chart,
                            O = x.inverted,
                            d = this.xAxis,
                            A = d.reversed,
                            L = ((O ? t.height : t.width) || 0) / 2,
                            V = e.pointWidth,
                            B = V ? V / 2 : 0;
                        t.startXPos = O ? p.x : A ? -L - B : d.width - L + B, t.startYPos = O ? A ? this.yAxis.height - L + B : -L - B : p.y, s ? t.visibility === "hidden" && (t.show(), t.attr({
                            opacity: 0
                        }).animate({
                            opacity: 1
                        })) : t.attr({
                            opacity: 1
                        }).animate({
                            opacity: 0
                        }, void 0, t.hide), x.hasRendered && (i && t.attr({
                            x: t.startXPos,
                            y: t.startYPos
                        }), t.placed = !0)
                    }
                    f.compose = function(e) {
                        if (ht.pushUnique(m, e)) {
                            let t = e.prototype;
                            t.initDataLabelsGroup = P, t.initDataLabels = o, t.alignDataLabel = T, t.drawDataLabels = l, t.justifyDataLabel = n, t.setDataLabelStartPos = u, t.hasDataLabels = C
                        }
                    }
                }(rt || (rt = {})), rt
            }), ft(Y, "Series/Column/ColumnDataLabel.js", [Y["Core/Series/DataLabel.js"], Y["Core/Series/SeriesRegistry.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                var rt;
                let {
                    series: it
                } = Q, {
                    merge: nt,
                    pick: ot
                } = ht;
                return function(K) {
                    let Z = [];

                    function U(S, R, E, M, k) {
                        let g = this.chart.inverted,
                            f = S.series,
                            m = (f.xAxis ? f.xAxis.len : this.chart.plotSizeX) || 0,
                            C = (f.yAxis ? f.yAxis.len : this.chart.plotSizeY) || 0,
                            T = S.dlBox || S.shapeArgs,
                            P = ot(S.below, S.plotY > ot(this.translatedThreshold, C)),
                            o = ot(E.inside, !!this.options.stacking);
                        if (T) {
                            if (M = nt(T), !(E.overflow === "allow" && E.crop === !1)) {
                                M.y < 0 && (M.height += M.y, M.y = 0);
                                let l = M.y + M.height - C;
                                l > 0 && l < M.height && (M.height -= l)
                            }
                            g && (M = {
                                x: C - M.y - M.height,
                                y: m - M.x - M.width,
                                width: M.height,
                                height: M.width
                            }), o || (g ? (M.x += P ? 0 : M.width, M.width = 0) : (M.y += P ? M.height : 0, M.height = 0))
                        }
                        E.align = ot(E.align, !g || o ? "center" : P ? "right" : "left"), E.verticalAlign = ot(E.verticalAlign, g || o ? "middle" : P ? "top" : "bottom"), it.prototype.alignDataLabel.call(this, S, R, E, M, k), E.inside && S.contrastColor && R.css({
                            color: S.contrastColor
                        })
                    }
                    K.compose = function(S) {
                        et.compose(it), ht.pushUnique(Z, S) && (S.prototype.alignDataLabel = U)
                    }
                }(rt || (rt = {})), rt
            }), ft(Y, "Series/Bar/BarSeries.js", [Y["Series/Column/ColumnSeries.js"], Y["Core/Series/SeriesRegistry.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                let {
                    extend: rt,
                    merge: it
                } = ht;
                class nt extends et {
                    constructor() {
                        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0
                    }
                }
                return nt.defaultOptions = it(et.defaultOptions, {}), rt(nt.prototype, {
                    inverted: !0
                }), Q.registerSeriesType("bar", nt), nt
            }), ft(Y, "Series/Scatter/ScatterSeriesDefaults.js", [], function() {
                return {
                    lineWidth: 0,
                    findNearestPointBy: "xy",
                    jitter: {
                        x: 0,
                        y: 0
                    },
                    marker: {
                        enabled: !0
                    },
                    tooltip: {
                        headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {series.name}</span><br/>',
                        pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
                    }
                }
            }), ft(Y, "Series/Scatter/ScatterSeries.js", [Y["Series/Scatter/ScatterSeriesDefaults.js"], Y["Core/Series/SeriesRegistry.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                let {
                    column: rt,
                    line: it
                } = Q.seriesTypes, {
                    addEvent: nt,
                    extend: ot,
                    merge: K
                } = ht;
                class Z extends it {
                    constructor() {
                        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0
                    }
                    applyJitter() {
                        let S = this,
                            R = this.options.jitter,
                            E = this.points.length;
                        R && this.points.forEach(function(M, k) {
                            ["x", "y"].forEach(function(g, f) {
                                let m, C = "plot" + g.toUpperCase(),
                                    T, P, o;
                                R[g] && !M.isNull && (m = S[g + "Axis"], o = R[g] * m.transA, m && !m.isLog && (T = Math.max(0, M[C] - o), P = Math.min(m.len, M[C] + o), M[C] = T + (P - T) * function(l) {
                                    let n = 1e4 * Math.sin(l);
                                    return n - Math.floor(n)
                                }(k + f * E), g === "x" && (M.clientX = M.plotX)))
                            })
                        })
                    }
                    drawGraph() {
                        this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy())
                    }
                }
                return Z.defaultOptions = K(it.defaultOptions, et), ot(Z.prototype, {
                    drawTracker: rt.prototype.drawTracker,
                    sorted: !1,
                    requireSorting: !1,
                    noSharedTooltip: !0,
                    trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
                    takeOrdinalPosition: !1
                }), nt(Z, "afterTranslate", function() {
                    this.applyJitter()
                }), Q.registerSeriesType("scatter", Z), Z
            }), ft(Y, "Series/CenteredUtilities.js", [Y["Core/Globals.js"], Y["Core/Series/Series.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                var rt, it;
                let {
                    deg2rad: nt
                } = et, {
                    fireEvent: ot,
                    isNumber: K,
                    pick: Z,
                    relativeLength: U
                } = ht;
                return (it = rt || (rt = {})).getCenter = function() {
                    let S = this.options,
                        R = this.chart,
                        E = 2 * (S.slicedOffset || 0),
                        M = R.plotWidth - 2 * E,
                        k = R.plotHeight - 2 * E,
                        g = S.center,
                        f = Math.min(M, k),
                        m = S.thickness,
                        C, T = S.size,
                        P = S.innerSize || 0,
                        o, l;
                    typeof T == "string" && (T = parseFloat(T)), typeof P == "string" && (P = parseFloat(P));
                    let n = [Z(g[0], "50%"), Z(g[1], "50%"), Z(T && T < 0 ? void 0 : S.size, "100%"), Z(P && P < 0 ? void 0 : S.innerSize || 0, "0%")];
                    for (!R.angular || this instanceof Q || (n[3] = 0), o = 0; o < 4; ++o) l = n[o], C = o < 2 || o === 2 && /%$/.test(l), n[o] = U(l, [M, k, f, n[2]][o]) + (C ? E : 0);
                    return n[3] > n[2] && (n[3] = n[2]), K(m) && 2 * m < n[2] && m > 0 && (n[3] = n[2] - 2 * m), ot(this, "afterGetCenter", {
                        positions: n
                    }), n
                }, it.getStartAndEndRadians = function(S, R) {
                    let E = K(S) ? S : 0,
                        M = K(R) && R > E && R - E < 360 ? R : E + 360;
                    return {
                        start: nt * (E + -90),
                        end: nt * (M + -90)
                    }
                }, rt
            }), ft(Y, "Series/Pie/PiePoint.js", [Y["Core/Animation/AnimationUtilities.js"], Y["Core/Series/Point.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                let {
                    setAnimation: rt
                } = et, {
                    addEvent: it,
                    defined: nt,
                    extend: ot,
                    isNumber: K,
                    isString: Z,
                    pick: U,
                    relativeLength: S
                } = ht;
                class R extends Q {
                    constructor() {
                        super(...arguments), this.half = 0, this.options = void 0, this.series = void 0
                    }
                    getConnectorPath(M) {
                        let k = M.dataLabelPosition,
                            g = M.options || {},
                            f = g.connectorShape,
                            m = this.connectorShapes[f] || f;
                        return k && m.call(this, {
                            ...k.computed,
                            alignment: k.alignment
                        }, k.connectorPosition, g) || []
                    }
                    getTranslate() {
                        return this.sliced && this.slicedTranslation || {
                            translateX: 0,
                            translateY: 0
                        }
                    }
                    haloPath(M) {
                        let k = this.shapeArgs;
                        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(k.x, k.y, k.r + M, k.r + M, {
                            innerR: k.r - 1,
                            start: k.start,
                            end: k.end,
                            borderRadius: k.borderRadius
                        })
                    }
                    init() {
                        super.init.apply(this, arguments), this.name = U(this.name, "Slice");
                        let M = k => {
                            this.slice(k.type === "select")
                        };
                        return it(this, "select", M), it(this, "unselect", M), this
                    }
                    isValid() {
                        return K(this.y) && this.y >= 0
                    }
                    setVisible(M, k) {
                        let g = this.series,
                            f = g.chart,
                            m = g.options.ignoreHiddenPoint;
                        k = U(k, m), M !== this.visible && (this.visible = this.options.visible = M = M === void 0 ? !this.visible : M, g.options.data[g.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector"].forEach(C => {
                            this[C] && this[C][M ? "show" : "hide"](M)
                        }), this.legendItem && f.legend.colorizeItem(this, M), M || this.state !== "hover" || this.setState(""), m && (g.isDirty = !0), k && f.redraw())
                    }
                    slice(M, k, g) {
                        let f = this.series,
                            m = f.chart;
                        rt(g, m), k = U(k, !0), this.sliced = this.options.sliced = M = nt(M) ? M : !this.sliced, f.options.data[f.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate())
                    }
                }
                return ot(R.prototype, {
                    connectorShapes: {
                        fixedOffset: function(E, M, k) {
                            let g = M.breakAt,
                                f = M.touchingSliceAt,
                                m = k.softConnector ? ["C", E.x + (E.alignment === "left" ? -5 : 5), E.y, 2 * g.x - f.x, 2 * g.y - f.y, g.x, g.y] : ["L", g.x, g.y];
                            return [
                                ["M", E.x, E.y], m, ["L", f.x, f.y]
                            ]
                        },
                        straight: function(E, M) {
                            let k = M.touchingSliceAt;
                            return [
                                ["M", E.x, E.y],
                                ["L", k.x, k.y]
                            ]
                        },
                        crookedLine: function(E, M, k) {
                            let {
                                breakAt: g,
                                touchingSliceAt: f
                            } = M, {
                                series: m
                            } = this, [C, T, P] = m.center, o = P / 2, {
                                plotLeft: l,
                                plotWidth: n
                            } = m.chart, h = E.alignment === "left", {
                                x: u,
                                y: e
                            } = E, t = g.x;
                            if (k.crookDistance) {
                                let s = S(k.crookDistance, 1);
                                t = h ? C + o + (n + l - C - o) * (1 - s) : l + (C - o) * s
                            } else t = C + (T - e) * Math.tan((this.angle || 0) - Math.PI / 2);
                            let i = [
                                ["M", u, e]
                            ];
                            return (h ? t <= u && t >= g.x : t >= u && t <= g.x) && i.push(["L", t, e]), i.push(["L", g.x, g.y], ["L", f.x, f.y]), i
                        }
                    }
                }), R
            }), ft(Y, "Series/Pie/PieSeriesDefaults.js", [], function() {
                return {
                    borderRadius: 3,
                    center: [null, null],
                    clip: !1,
                    colorByPoint: !0,
                    dataLabels: {
                        connectorPadding: 5,
                        connectorShape: "crookedLine",
                        crookDistance: void 0,
                        distance: 30,
                        enabled: !0,
                        formatter: function() {
                            return this.point.isNull ? void 0 : this.point.name
                        },
                        softConnector: !0,
                        x: 0
                    },
                    fillColor: void 0,
                    ignoreHiddenPoint: !0,
                    inactiveOtherPoints: !0,
                    legendType: "point",
                    marker: null,
                    size: null,
                    showInLegend: !1,
                    slicedOffset: 10,
                    stickyTracking: !1,
                    tooltip: {
                        followPointer: !0
                    },
                    borderColor: "#ffffff",
                    borderWidth: 1,
                    lineWidth: void 0,
                    states: {
                        hover: {
                            brightness: .1
                        }
                    }
                }
            }), ft(Y, "Series/Pie/PieSeries.js", [Y["Series/CenteredUtilities.js"], Y["Series/Column/ColumnSeries.js"], Y["Core/Globals.js"], Y["Series/Pie/PiePoint.js"], Y["Series/Pie/PieSeriesDefaults.js"], Y["Core/Series/Series.js"], Y["Core/Series/SeriesRegistry.js"], Y["Core/Renderer/SVG/Symbols.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt, it, nt, ot, K, Z) {
                let {
                    getStartAndEndRadians: U
                } = et, {
                    noop: S
                } = ht, {
                    clamp: R,
                    extend: E,
                    fireEvent: M,
                    merge: k,
                    pick: g,
                    relativeLength: f,
                    splat: m
                } = Z;
                class C extends nt {
                    constructor() {
                        super(...arguments), this.center = void 0, this.data = void 0, this.options = void 0, this.points = void 0
                    }
                    animate(P) {
                        let o = this,
                            l = o.points,
                            n = o.startAngleRad;
                        P || l.forEach(function(h) {
                            let u = h.graphic,
                                e = h.shapeArgs;
                            u && e && (u.attr({
                                r: g(h.startR, o.center && o.center[3] / 2),
                                start: n,
                                end: n
                            }), u.animate({
                                r: e.r,
                                start: e.start,
                                end: e.end
                            }, o.options.animation))
                        })
                    }
                    drawEmpty() {
                        let P, o, l = this.startAngleRad,
                            n = this.endAngleRad,
                            h = this.options;
                        this.total === 0 && this.center ? (P = this.center[0], o = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(P, o, this.center[1] / 2, 0, l, n).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({
                            d: K.arc(P, o, this.center[2] / 2, 0, {
                                start: l,
                                end: n,
                                innerR: this.center[3] / 2
                            })
                        }), this.chart.styledMode || this.graph.attr({
                            "stroke-width": h.borderWidth,
                            fill: h.fillColor || "none",
                            stroke: h.color || "#cccccc"
                        })) : this.graph && (this.graph = this.graph.destroy())
                    }
                    drawPoints() {
                        let P = this.chart.renderer;
                        this.points.forEach(function(o) {
                            o.graphic && o.hasNewShapeType() && (o.graphic = o.graphic.destroy()), o.graphic || (o.graphic = P[o.shapeType](o.shapeArgs).add(o.series.group), o.delayedRendering = !0)
                        })
                    }
                    generatePoints() {
                        super.generatePoints(), this.updateTotals()
                    }
                    getX(P, o, l, n) {
                        let h = this.center,
                            u = this.radii ? this.radii[l.index] || 0 : h[2] / 2,
                            e = n.dataLabelPosition,
                            t = (e == null ? void 0 : e.distance) || 0,
                            i = Math.asin(R((P - h[1]) / (u + t), -1, 1));
                        return h[0] + (o ? -1 : 1) * (Math.cos(i) * (u + t)) + (t > 0 ? (o ? -1 : 1) * (n.padding || 0) : 0)
                    }
                    hasData() {
                        return !!this.processedXData.length
                    }
                    redrawPoints() {
                        let P, o, l, n, h = this,
                            u = h.chart;
                        this.drawEmpty(), h.group && !u.styledMode && h.group.shadow(h.options.shadow), h.points.forEach(function(e) {
                            let t = {};
                            o = e.graphic, !e.isNull && o ? (n = e.shapeArgs, P = e.getTranslate(), u.styledMode || (l = h.pointAttribs(e, e.selected && "select")), e.delayedRendering ? (o.setRadialReference(h.center).attr(n).attr(P), u.styledMode || o.attr(l).attr({
                                "stroke-linejoin": "round"
                            }), e.delayedRendering = !1) : (o.setRadialReference(h.center), u.styledMode || k(!0, t, l), k(!0, t, n, P), o.animate(t)), o.attr({
                                visibility: e.visible ? "inherit" : "hidden"
                            }), o.addClass(e.getClassName(), !0)) : o && (e.graphic = o.destroy())
                        })
                    }
                    sortByAngle(P, o) {
                        P.sort(function(l, n) {
                            return l.angle !== void 0 && (n.angle - l.angle) * o
                        })
                    }
                    translate(P) {
                        M(this, "translate"), this.generatePoints();
                        let o = this.options,
                            l = o.slicedOffset,
                            n = U(o.startAngle, o.endAngle),
                            h = this.startAngleRad = n.start,
                            u = this.endAngleRad = n.end,
                            e = u - h,
                            t = this.points,
                            i = o.ignoreHiddenPoint,
                            s = t.length,
                            p, x, O, d, A, L, V, B = 0;
                        for (P || (this.center = P = this.getCenter()), L = 0; L < s; L++) {
                            V = t[L], p = h + B * e, V.isValid() && (!i || V.visible) && (B += V.percentage / 100), x = h + B * e;
                            let r = {
                                x: P[0],
                                y: P[1],
                                r: P[2] / 2,
                                innerR: P[3] / 2,
                                start: Math.round(1e3 * p) / 1e3,
                                end: Math.round(1e3 * x) / 1e3
                            };
                            V.shapeType = "arc", V.shapeArgs = r, (O = (x + p) / 2) > 1.5 * Math.PI ? O -= 2 * Math.PI : O < -Math.PI / 2 && (O += 2 * Math.PI), V.slicedTranslation = {
                                translateX: Math.round(Math.cos(O) * l),
                                translateY: Math.round(Math.sin(O) * l)
                            }, d = Math.cos(O) * P[2] / 2, A = Math.sin(O) * P[2] / 2, V.tooltipPos = [P[0] + .7 * d, P[1] + .7 * A], V.half = O < -Math.PI / 2 || O > Math.PI / 2 ? 1 : 0, V.angle = O
                        }
                        M(this, "afterTranslate")
                    }
                    updateTotals() {
                        let P = this.points,
                            o = P.length,
                            l = this.options.ignoreHiddenPoint,
                            n, h, u = 0;
                        for (n = 0; n < o; n++)(h = P[n]).isValid() && (!l || h.visible) && (u += h.y);
                        for (n = 0, this.total = u; n < o; n++)(h = P[n]).percentage = u > 0 && (h.visible || !l) ? h.y / u * 100 : 0, h.total = u
                    }
                }
                return C.defaultOptions = k(nt.defaultOptions, it), E(C.prototype, {
                    axisTypes: [],
                    directTouch: !0,
                    drawGraph: void 0,
                    drawTracker: Q.prototype.drawTracker,
                    getCenter: et.getCenter,
                    getSymbol: S,
                    isCartesian: !1,
                    noSharedTooltip: !0,
                    pointAttribs: Q.prototype.pointAttribs,
                    pointClass: rt,
                    requireSorting: !1,
                    searchPoint: S,
                    trackerGroups: ["group", "dataLabelsGroup"]
                }), ot.registerSeriesType("pie", C), C
            }), ft(Y, "Series/Pie/PieDataLabel.js", [Y["Core/Series/DataLabel.js"], Y["Core/Globals.js"], Y["Core/Renderer/RendererUtilities.js"], Y["Core/Series/SeriesRegistry.js"], Y["Core/Utilities.js"]], function(et, Q, ht, rt, it) {
                var nt;
                let {
                    noop: ot
                } = Q, {
                    distribute: K
                } = ht, {
                    series: Z
                } = rt, {
                    arrayMax: U,
                    clamp: S,
                    defined: R,
                    pick: E,
                    relativeLength: M
                } = it;
                return function(k) {
                    let g = [],
                        f = {
                            radialDistributionY: function(o, l) {
                                var n;
                                return (((n = l.dataLabelPosition) == null ? void 0 : n.top) || 0) + o.distributeBox.pos
                            },
                            radialDistributionX: function(o, l, n, h, u) {
                                let e = u.dataLabelPosition;
                                return o.getX(n < ((e == null ? void 0 : e.top) || 0) + 2 || n > ((e == null ? void 0 : e.bottom) || 0) - 2 ? h : n, l.half, l, u)
                            },
                            justify: function(o, l, n, h) {
                                var u;
                                return h[0] + (o.half ? -1 : 1) * (n + (((u = l.dataLabelPosition) == null ? void 0 : u.distance) || 0))
                            },
                            alignToPlotEdges: function(o, l, n, h) {
                                let u = o.getBBox().width;
                                return l ? u + h : n - u - h
                            },
                            alignToConnectors: function(o, l, n, h) {
                                let u = 0,
                                    e;
                                return o.forEach(function(t) {
                                    (e = t.dataLabel.getBBox().width) > u && (u = e)
                                }), l ? u + h : n - u - h
                            }
                        };

                    function m(o, l) {
                        let {
                            center: n,
                            options: h
                        } = this, u = n[2] / 2, e = o.angle || 0, t = Math.cos(e), i = Math.sin(e), s = n[0] + t * u, p = n[1] + i * u, x = Math.min((h.slicedOffset || 0) + (h.borderWidth || 0), l / 5);
                        return {
                            natural: {
                                x: s + t * l,
                                y: p + i * l
                            },
                            computed: {},
                            alignment: l < 0 ? "center" : o.half ? "right" : "left",
                            connectorPosition: {
                                breakAt: {
                                    x: s + t * x,
                                    y: p + i * x
                                },
                                touchingSliceAt: {
                                    x: s,
                                    y: p
                                }
                            },
                            distance: l
                        }
                    }

                    function C() {
                        var r;
                        let o = this,
                            l = o.points,
                            n = o.chart,
                            h = n.plotWidth,
                            u = n.plotHeight,
                            e = n.plotLeft,
                            t = Math.round(n.chartWidth / 3),
                            i = o.center,
                            s = i[2] / 2,
                            p = i[1],
                            x = [
                                [],
                                []
                            ],
                            O = [0, 0, 0, 0],
                            d = o.dataLabelPositioners,
                            A, L, V, B = 0;
                        o.visible && ((r = o.hasDataLabels) != null && r.call(o)) && (l.forEach(c => {
                            (c.dataLabels || []).forEach(b => {
                                b.shortened && (b.attr({
                                    width: "auto"
                                }).css({
                                    width: "auto",
                                    textOverflow: "clip"
                                }), b.shortened = !1)
                            })
                        }), Z.prototype.drawDataLabels.apply(o), l.forEach(c => {
                            (c.dataLabels || []).forEach((b, N) => {
                                var v;
                                let z = i[2] / 2,
                                    W = b.options,
                                    a = M((W == null ? void 0 : W.distance) || 0, z);
                                N === 0 && x[c.half].push(c), !R((v = W == null ? void 0 : W.style) == null ? void 0 : v.width) && b.getBBox().width > t && (b.css({
                                    width: Math.round(.7 * t) + "px"
                                }), b.shortened = !0), b.dataLabelPosition = this.getDataLabelPosition(c, a), B = Math.max(B, a)
                            })
                        }), x.forEach((c, b) => {
                            let N = c.length,
                                z = [],
                                W, a, v = 0,
                                y;
                            N && (o.sortByAngle(c, b - .5), B > 0 && (W = Math.max(0, p - s - B), a = Math.min(p + s + B, n.plotHeight), c.forEach(I => {
                                (I.dataLabels || []).forEach((w, G) => {
                                    var _;
                                    let X = w.dataLabelPosition;
                                    X && X.distance > 0 && (X.top = Math.max(0, p - s - X.distance), X.bottom = Math.min(p + s + X.distance, n.plotHeight), v = w.getBBox().height || 21, I.distributeBox = {
                                        target: (((_ = w.dataLabelPosition) == null ? void 0 : _.natural.y) || 0) - X.top + v / 2,
                                        size: v,
                                        rank: I.y
                                    }, z.push(I.distributeBox))
                                })
                            }), K(z, y = a + v - W, y / 5)), c.forEach(I => {
                                (I.dataLabels || []).forEach(w => {
                                    let G = w.options || {},
                                        X = I.distributeBox,
                                        _ = w.dataLabelPosition,
                                        $ = (_ == null ? void 0 : _.natural.y) || 0,
                                        st = G.connectorPadding || 0,
                                        D = 0,
                                        j = $,
                                        F = "inherit";
                                    if (_) {
                                        if (z && R(X) && _.distance > 0 && (X.pos === void 0 ? F = "hidden" : (V = X.size, j = d.radialDistributionY(I, w))), G.justify) D = d.justify(I, w, s, i);
                                        else switch (G.alignTo) {
                                            case "connectors":
                                                D = d.alignToConnectors(c, b, h, e);
                                                break;
                                            case "plotEdges":
                                                D = d.alignToPlotEdges(w, b, h, e);
                                                break;
                                            default:
                                                D = d.radialDistributionX(o, I, j, $, w)
                                        }
                                        if (_.attribs = {
                                            visibility: F,
                                            align: _.alignment
                                        }, _.posAttribs = {
                                            x: D + (G.x || 0) + ({
                                                left: st,
                                                right: -st
                                            } [_.alignment] || 0),
                                            y: j + (G.y || 0) - w.getBBox().height / 2
                                        }, _.computed.x = D, _.computed.y = j, E(G.crop, !0)) {
                                            let H;
                                            D - (L = w.getBBox().width) < st && b === 1 ? (H = Math.round(L - D + st), O[3] = Math.max(H, O[3])) : D + L > h - st && b === 0 && (H = Math.round(D + L - h + st), O[1] = Math.max(H, O[1])), j - V / 2 < 0 ? O[0] = Math.max(Math.round(-j + V / 2), O[0]) : j + V / 2 > u && (O[2] = Math.max(Math.round(j + V / 2 - u), O[2])), _.sideOverflow = H
                                        }
                                    }
                                })
                            }))
                        }), (U(O) === 0 || this.verifyDataLabelOverflow(O)) && (this.placeDataLabels(), this.points.forEach(c => {
                            (c.dataLabels || []).forEach(b => {
                                var a;
                                let {
                                    connectorColor: N,
                                    connectorWidth: z = 1
                                } = b.options || {}, W = b.dataLabelPosition;
                                if (z) {
                                    let v;
                                    A = b.connector, W && W.distance > 0 ? (v = !A, A || (b.connector = A = n.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + c.colorIndex + (c.className ? " " + c.className : "")).add(o.dataLabelsGroup)), n.styledMode || A.attr({
                                        "stroke-width": z,
                                        stroke: N || c.color || "#666666"
                                    }), A[v ? "attr" : "animate"]({
                                        d: c.getConnectorPath(b)
                                    }), A.attr({
                                        visibility: (a = W.attribs) == null ? void 0 : a.visibility
                                    })) : A && (b.connector = A.destroy())
                                }
                            })
                        })))
                    }

                    function T() {
                        this.points.forEach(o => {
                            (o.dataLabels || []).forEach(l => {
                                var h;
                                let n = l.dataLabelPosition;
                                n ? (n.sideOverflow && (l.css({
                                    width: Math.max(l.getBBox().width - n.sideOverflow, 0) + "px",
                                    textOverflow: (((h = l.options) == null ? void 0 : h.style) || {}).textOverflow || "ellipsis"
                                }), l.shortened = !0), l.attr(n.attribs), l[l.moved ? "animate" : "attr"](n.posAttribs), l.moved = !0) : l && l.attr({
                                    y: -9999
                                })
                            }), delete o.distributeBox
                        }, this)
                    }

                    function P(o) {
                        let l = this.center,
                            n = this.options,
                            h = n.center,
                            u = n.minSize || 80,
                            e = u,
                            t = n.size !== null;
                        return !t && (h[0] !== null ? e = Math.max(l[2] - Math.max(o[1], o[3]), u) : (e = Math.max(l[2] - o[1] - o[3], u), l[0] += (o[3] - o[1]) / 2), h[1] !== null ? e = S(e, u, l[2] - Math.max(o[0], o[2])) : (e = S(e, u, l[2] - o[0] - o[2]), l[1] += (o[0] - o[2]) / 2), e < l[2] ? (l[2] = e, l[3] = Math.min(n.thickness ? Math.max(0, e - 2 * n.thickness) : Math.max(0, M(n.innerSize || 0, e)), e), this.translate(l), this.drawDataLabels && this.drawDataLabels()) : t = !0), t
                    }
                    k.compose = function(o) {
                        if (et.compose(Z), it.pushUnique(g, o)) {
                            let l = o.prototype;
                            l.dataLabelPositioners = f, l.alignDataLabel = ot, l.drawDataLabels = C, l.getDataLabelPosition = m, l.placeDataLabels = T, l.verifyDataLabelOverflow = P
                        }
                    }
                }(nt || (nt = {})), nt
            }), ft(Y, "Extensions/OverlappingDataLabels.js", [Y["Core/Utilities.js"]], function(et) {
                let {
                    addEvent: Q,
                    fireEvent: ht,
                    isNumber: rt,
                    objectEach: it,
                    pick: nt,
                    pushUnique: ot
                } = et, K = [];

                function Z(R) {
                    let E = R.length,
                        M = this.renderer,
                        k = (l, n) => !(n.x >= l.x + l.width || n.x + n.width <= l.x || n.y >= l.y + l.height || n.y + n.height <= l.y),
                        g = l => {
                            let n = l.box ? 0 : l.padding || 0,
                                h, u, e, t = 0,
                                i = 0,
                                s, p;
                            if (l && (!l.alignAttr || l.placed)) return h = l.alignAttr || {
                                x: l.attr("x"),
                                y: l.attr("y")
                            }, u = l.parentGroup, l.width || (e = l.getBBox(), l.width = e.width, l.height = e.height, t = M.fontMetrics(l.element).h), s = l.width - 2 * n, (p = {
                                left: "0",
                                center: "0.5",
                                right: "1"
                            } [l.alignValue]) ? i = +p * s : rt(l.x) && Math.round(l.x) !== l.translateX && (i = l.x - (l.translateX || 0)), {
                                x: h.x + (u.translateX || 0) + n - (i || 0),
                                y: h.y + (u.translateY || 0) + n - t,
                                width: l.width - 2 * n,
                                height: (l.height || 0) - 2 * n
                            }
                        },
                        f, m, C, T, P, o = !1;
                    for (let l = 0; l < E; l++)(f = R[l]) && (f.oldOpacity = f.opacity, f.newOpacity = 1, f.absoluteBox = g(f));
                    R.sort((l, n) => (n.labelrank || 0) - (l.labelrank || 0));
                    for (let l = 0; l < E; ++l) {
                        T = (m = R[l]) && m.absoluteBox;
                        for (let n = l + 1; n < E; ++n) P = (C = R[n]) && C.absoluteBox, T && P && m !== C && m.newOpacity !== 0 && C.newOpacity !== 0 && m.visibility !== "hidden" && C.visibility !== "hidden" && k(T, P) && ((m.labelrank < C.labelrank ? m : C).newOpacity = 0)
                    }
                    for (let l of R) U(l, this) && (o = !0);
                    o && ht(this, "afterHideAllOverlappingLabels")
                }

                function U(R, E) {
                    let M, k = !1;
                    return R && (M = R.newOpacity, R.oldOpacity !== M && (R.alignAttr && R.placed ? (R[M ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), k = !0, R.alignAttr.opacity = M, R[R.isOld ? "animate" : "attr"](R.alignAttr, null, function() {
                        E.styledMode || R.css({
                            pointerEvents: M ? "auto" : "none"
                        })
                    }), ht(E, "afterHideOverlappingLabel")) : R.attr({
                        opacity: M
                    })), R.isOld = !0), k
                }

                function S() {
                    var M;
                    let R = this,
                        E = [];
                    for (let k of R.labelCollectors || []) E = E.concat(k());
                    for (let k of R.yAxis || []) k.stacking && k.options.stackLabels && !k.options.stackLabels.allowOverlap && it(k.stacking.stacks, g => {
                        it(g, f => {
                            f.label && E.push(f.label)
                        })
                    });
                    for (let k of R.series || [])
                        if (k.visible && ((M = k.hasDataLabels) != null && M.call(k))) {
                            let g = f => {
                                for (let m of f) m.visible && (m.dataLabels || []).forEach(C => {
                                    var P;
                                    let T = C.options || {};
                                    C.labelrank = nt(T.labelrank, m.labelrank, (P = m.shapeArgs) == null ? void 0 : P.height), T.allowOverlap ?? Number(T.distance) > 0 ? (C.oldOpacity = C.opacity, C.newOpacity = 1, U(C, R)) : E.push(C)
                                })
                            };
                            g(k.nodes || []), g(k.points)
                        } this.hideOverlappingLabels(E)
                }
                return {
                    compose: function(R) {
                        if (ot(K, R)) {
                            let E = R.prototype;
                            E.hideOverlappingLabels = Z, Q(R, "render", S)
                        }
                    }
                }
            }), ft(Y, "Extensions/BorderRadius.js", [Y["Core/Defaults.js"], Y["Core/Globals.js"], Y["Core/Utilities.js"]], function(et, Q, ht) {
                let {
                    defaultOptions: rt
                } = et, {
                    noop: it
                } = Q, {
                    addEvent: nt,
                    extend: ot,
                    isObject: K,
                    merge: Z,
                    pushUnique: U,
                    relativeLength: S
                } = ht, R = [], E = {
                    radius: 0,
                    scope: "stack",
                    where: void 0
                }, M = it, k = it;

                function g(P, o, l, n, h = {}) {
                    let u = M(P, o, l, n, h),
                        {
                            innerR: e = 0,
                            r: t = l,
                            start: i = 0,
                            end: s = 0
                        } = h;
                    if (h.open || !h.borderRadius) return u;
                    let p = s - i,
                        x = Math.sin(p / 2),
                        O = Math.max(Math.min(S(h.borderRadius || 0, t - e), (t - e) / 2, t * x / (1 + x)), 0),
                        d = Math.min(O, 2 * (p / Math.PI) * e),
                        A = u.length - 1;
                    for (; A--;)(function(L, V, B) {
                        let r, c, b, N = L[V],
                            z = L[V + 1];
                        if (z[0] === "Z" && (z = L[0]), (N[0] === "M" || N[0] === "L") && z[0] === "A" ? (r = N, c = z, b = !0) : N[0] === "A" && (z[0] === "M" || z[0] === "L") && (r = z, c = N), r && c && c.params) {
                            let W = c[1],
                                a = c[5],
                                v = c.params,
                                {
                                    start: y,
                                    end: I,
                                    cx: w,
                                    cy: G
                                } = v,
                                X = a ? W - B : W + B,
                                _ = X ? Math.asin(B / X) : 0,
                                $ = a ? _ : -_,
                                st = Math.cos(_) * X;
                            b ? (v.start = y + $, r[1] = w + st * Math.cos(y), r[2] = G + st * Math.sin(y), L.splice(V + 1, 0, ["A", B, B, 0, 0, 1, w + W * Math.cos(v.start), G + W * Math.sin(v.start)])) : (v.end = I - $, c[6] = w + W * Math.cos(v.end), c[7] = G + W * Math.sin(v.end), L.splice(V + 1, 0, ["A", B, B, 0, 0, 1, w + st * Math.cos(I), G + st * Math.sin(I)])), c[4] = Math.abs(v.end - v.start) < Math.PI ? 0 : 1
                        }
                    })(u, A, A > 1 ? d : O);
                    return u
                }

                function f() {
                    var P, o;
                    if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {
                        let {
                            options: l,
                            yAxis: n
                        } = this, h = l.stacking === "percent", u = (o = (P = rt.plotOptions) == null ? void 0 : P[this.type]) == null ? void 0 : o.borderRadius, e = m(l.borderRadius, K(u) ? u : {}), t = n.options.reversed;
                        for (let i of this.points) {
                            let {
                                shapeArgs: s
                            } = i;
                            if (i.shapeType === "roundedRect" && s) {
                                let {
                                    width: p = 0,
                                    height: x = 0,
                                    y: O = 0
                                } = s, d = O, A = x;
                                if (e.scope === "stack" && i.stackTotal) {
                                    let r = n.translate(h ? 100 : i.stackTotal, !1, !0, !1, !0),
                                        c = n.translate(l.threshold || 0, !1, !0, !1, !0),
                                        b = this.crispCol(0, Math.min(r, c), 0, Math.abs(r - c));
                                    d = b.y, A = b.height
                                }
                                let L = (i.negative ? -1 : 1) * (t ? -1 : 1) == -1,
                                    V = e.where;
                                !V && this.is("waterfall") && Math.abs((i.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (V = "all"), V || (V = "end");
                                let B = Math.min(S(e.radius, p), p / 2, V === "all" ? x / 2 : 1 / 0) || 0;
                                V === "end" && (L && (d -= B), A += B), ot(s, {
                                    brBoxHeight: A,
                                    brBoxY: d,
                                    r: B
                                })
                            }
                        }
                    }
                }

                function m(P, o) {
                    return K(P) || (P = {
                        radius: P || 0
                    }), Z(E, o, P)
                }

                function C() {
                    let P = m(this.options.borderRadius);
                    for (let o of this.points) {
                        let l = o.shapeArgs;
                        l && (l.borderRadius = S(P.radius, (l.r || 0) - (l.innerR || 0)))
                    }
                }

                function T(P, o, l, n, h = {}) {
                    let u = k(P, o, l, n, h),
                        {
                            r: e = 0,
                            brBoxHeight: t = n,
                            brBoxY: i = o
                        } = h,
                        s = o - i,
                        p = i + t - (o + n),
                        x = s - e > -.1 ? 0 : e,
                        O = p - e > -.1 ? 0 : e,
                        d = Math.max(x && s, 0),
                        A = Math.max(O && p, 0),
                        L = [P + x, o],
                        V = [P + l - x, o],
                        B = [P + l, o + x],
                        r = [P + l, o + n - O],
                        c = [P + l - O, o + n],
                        b = [P + O, o + n],
                        N = [P, o + n - O],
                        z = [P, o + x],
                        W = (a, v) => Math.sqrt(Math.pow(a, 2) - Math.pow(v, 2));
                    if (d) {
                        let a = W(x, x - d);
                        L[0] -= a, V[0] += a, B[1] = z[1] = o + x - d
                    }
                    if (n < x - d) {
                        let a = W(x, x - d - n);
                        B[0] = r[0] = P + l - x + a, c[0] = Math.min(B[0], c[0]), b[0] = Math.max(r[0], b[0]), N[0] = z[0] = P + x - a, B[1] = z[1] = o + n
                    }
                    if (A) {
                        let a = W(O, O - A);
                        c[0] += a, b[0] -= a, r[1] = N[1] = o + n - O + A
                    }
                    if (n < O - A) {
                        let a = W(O, O - A - n);
                        B[0] = r[0] = P + l - O + a, V[0] = Math.min(B[0], V[0]), L[0] = Math.max(r[0], L[0]), N[0] = z[0] = P + O - a, r[1] = N[1] = o
                    }
                    return u.length = 0, u.push(["M", ...L], ["L", ...V], ["A", x, x, 0, 0, 1, ...B], ["L", ...r], ["A", O, O, 0, 0, 1, ...c], ["L", ...b], ["A", O, O, 0, 0, 1, ...N], ["L", ...z], ["A", x, x, 0, 0, 1, ...L], ["Z"]), u
                }
                return {
                    compose: function(P, o, l, n) {
                        if (U(R, P) && nt(P, "afterColumnTranslate", f, {
                            order: 9
                        }), U(R, o) && nt(o, "afterTranslate", C), U(R, l) && l.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY"), U(R, n)) {
                            let h = n.prototype.symbols;
                            M = h.arc, k = h.roundedRect, h.arc = g, h.roundedRect = T
                        }
                    },
                    optionsToObject: m
                }
            }), ft(Y, "Core/Responsive.js", [Y["Core/Utilities.js"]], function(et) {
                var Q;
                let {
                    diffObjects: ht,
                    extend: rt,
                    find: it,
                    isArray: nt,
                    isObject: ot,
                    merge: K,
                    objectEach: Z,
                    pick: U,
                    splat: S,
                    uniqueKey: R
                } = et;
                return function(E) {
                    let M = [];

                    function k(f, m) {
                        let C = f.condition;
                        (C.callback || function() {
                            return this.chartWidth <= U(C.maxWidth, Number.MAX_VALUE) && this.chartHeight <= U(C.maxHeight, Number.MAX_VALUE) && this.chartWidth >= U(C.minWidth, 0) && this.chartHeight >= U(C.minHeight, 0)
                        }).call(this) && m.push(f._id)
                    }

                    function g(f, m) {
                        let C = this.options.responsive,
                            T = this.currentResponsive,
                            P = [],
                            o;
                        !m && C && C.rules && C.rules.forEach(h => {
                            h._id === void 0 && (h._id = R()), this.matchResponsiveRule(h, P)
                        }, this);
                        let l = K(...P.map(h => it((C || {}).rules || [], u => u._id === h)).map(h => h && h.chartOptions));
                        l.isResponsiveOptions = !0, P = P.toString() || void 0;
                        let n = T && T.ruleIds;
                        P !== n && (T && this.update(T.undoOptions, f, !0), P ? ((o = ht(l, this.options, !0, this.collectionsWithUpdate)).isResponsiveOptions = !0, this.currentResponsive = {
                            ruleIds: P,
                            mergedOptions: l,
                            undoOptions: o
                        }, this.update(l, f, !0)) : this.currentResponsive = void 0)
                    }
                    E.compose = function(f) {
                        return et.pushUnique(M, f) && rt(f.prototype, {
                            matchResponsiveRule: k,
                            setResponsive: g
                        }), f
                    }
                }(Q || (Q = {})), Q
            }), ft(Y, "masters/highcharts.src.js", [Y["Core/Globals.js"], Y["Core/Utilities.js"], Y["Core/Defaults.js"], Y["Core/Animation/Fx.js"], Y["Core/Animation/AnimationUtilities.js"], Y["Core/Renderer/HTML/AST.js"], Y["Core/Templating.js"], Y["Core/Renderer/RendererUtilities.js"], Y["Core/Renderer/SVG/SVGElement.js"], Y["Core/Renderer/SVG/SVGRenderer.js"], Y["Core/Renderer/HTML/HTMLElement.js"], Y["Core/Renderer/HTML/HTMLRenderer.js"], Y["Core/Axis/Axis.js"], Y["Core/Axis/DateTimeAxis.js"], Y["Core/Axis/LogarithmicAxis.js"], Y["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], Y["Core/Axis/Tick.js"], Y["Core/Tooltip.js"], Y["Core/Series/Point.js"], Y["Core/Pointer.js"], Y["Core/Legend/Legend.js"], Y["Core/Chart/Chart.js"], Y["Core/Axis/Stacking/StackingAxis.js"], Y["Core/Axis/Stacking/StackItem.js"], Y["Core/Series/Series.js"], Y["Core/Series/SeriesRegistry.js"], Y["Series/Column/ColumnSeries.js"], Y["Series/Column/ColumnDataLabel.js"], Y["Series/Pie/PieSeries.js"], Y["Series/Pie/PieDataLabel.js"], Y["Core/Series/DataLabel.js"], Y["Extensions/OverlappingDataLabels.js"], Y["Extensions/BorderRadius.js"], Y["Core/Responsive.js"], Y["Core/Color/Color.js"], Y["Core/Time.js"]], function(et, Q, ht, rt, it, nt, ot, K, Z, U, S, R, E, M, k, g, f, m, C, T, P, o, l, n, h, u, e, t, i, s, p, x, O, d, A, L) {
                return et.animate = it.animate, et.animObject = it.animObject, et.getDeferredAnimation = it.getDeferredAnimation, et.setAnimation = it.setAnimation, et.stop = it.stop, et.timers = rt.timers, et.AST = nt, et.Axis = E, et.Chart = o, et.chart = o.chart, et.Fx = rt, et.Legend = P, et.PlotLineOrBand = g, et.Point = C, et.Pointer = T, et.Series = h, et.StackItem = n, et.SVGElement = Z, et.SVGRenderer = U, et.Templating = ot, et.Tick = f, et.Time = L, et.Tooltip = m, et.Color = A, et.color = A.parse, R.compose(U), S.compose(Z), T.compose(o), P.compose(o), et.defaultOptions = ht.defaultOptions, et.getOptions = ht.getOptions, et.time = ht.defaultTime, et.setOptions = ht.setOptions, et.dateFormat = ot.dateFormat, et.format = ot.format, et.numberFormat = ot.numberFormat, Q.extend(et, Q), et.distribute = K.distribute, et.seriesType = u.seriesType, t.compose(e), O.compose(h, i, Z, U), p.compose(h), M.compose(E), k.compose(E), x.compose(o), s.compose(i), g.compose(E), d.compose(o), l.compose(E, o, h), m.compose(T), et
            }), Y["masters/highcharts.src.js"]._modules = Y, Y["masters/highcharts.src.js"]
        })
    }(It)), It.exports
}
const Is = Wt(Ds);
(function(Pt, Tt) {
    (function(Y, ft) {
        Pt.exports = ft(js(), Is)
    })(window, function(Y, ft) {
        return Q = [function(rt, it) {
            rt.exports = Y
        }, function(rt, it) {
            rt.exports = ft
        }, function(rt, ot, nt) {
            nt.r(ot), nt.d(ot, "Chart", function() {
                return m
            }), nt.d(ot, "default", function() {
                return C
            });
            var ot = nt(0),
                K = nt.n(ot);

            function Z(T, P) {
                return function o(l, n, h) {
                    function u(e, t) {
                        !K.a.isObject(e, !h) || K.a.isClass(e) || K.a.isDOMElement(e) ? l[t] = n[t] : l[t] = o(l[t] || K.a.isArray(e) ? [] : {}, e, h)
                    }
                    return K.a.isArray(n) ? n.forEach(u) : K.a.objectEach(n, u), l
                }({}, T, P)
            }
            var U = nt(1);

            function S(T) {
                return (S = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(P) {
                    return typeof P
                } : function(P) {
                    return P && typeof Symbol == "function" && P.constructor === Symbol && P !== Symbol.prototype ? "symbol" : typeof P
                })(T)
            }

            function R(T) {
                return function(P) {
                    if (Array.isArray(P)) return E(P)
                }(T) || function(P) {
                    if (typeof Symbol < "u" && P[Symbol.iterator] != null || P["@@iterator"] != null) return Array.from(P)
                }(T) || function(P, o) {
                    var l;
                    if (P) return typeof P == "string" ? E(P, o) : (l = (l = Object.prototype.toString.call(P).slice(8, -1)) === "Object" && P.constructor ? P.constructor.name : l) === "Map" || l === "Set" ? Array.from(P) : l === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(l) ? E(P, o) : void 0
                }(T) || function() {
                    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                }()
            }

            function E(T, P) {
                (P == null || P > T.length) && (P = T.length);
                for (var o = 0, l = new Array(P); o < P; o++) l[o] = T[o];
                return l
            }

            function M(T, P) {
                var o, l = Object.keys(T);
                return Object.getOwnPropertySymbols && (o = Object.getOwnPropertySymbols(T), P && (o = o.filter(function(n) {
                    return Object.getOwnPropertyDescriptor(T, n).enumerable
                })), l.push.apply(l, o)), l
            }

            function k(T) {
                for (var P = 1; P < arguments.length; P++) {
                    var o = arguments[P] != null ? arguments[P] : {};
                    P % 2 ? M(Object(o), !0).forEach(function(l) {
                        var n, h;
                        n = T, h = o[l = l], (l = function(u) {
                            return u = function(e, t) {
                                if (S(e) !== "object" || e === null) return e;
                                var i = e[Symbol.toPrimitive];
                                if (i === void 0) return (t === "string" ? String : Number)(e);
                                if (i = i.call(e, t || "default"), S(i) !== "object") return i;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }(u, "string"), S(u) === "symbol" ? u : String(u)
                        }(l)) in n ? Object.defineProperty(n, l, {
                            value: h,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : n[l] = h
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(T, Object.getOwnPropertyDescriptors(o)) : M(Object(o)).forEach(function(l) {
                        Object.defineProperty(T, l, Object.getOwnPropertyDescriptor(o, l))
                    })
                }
                return T
            }
            var g = {
                    template: '<div ref="chart"></div>',
                    props: {
                        constructorType: {
                            type: String,
                            default: "chart"
                        },
                        options: {
                            type: Object,
                            required: !0
                        },
                        callback: Function,
                        updateArgs: {
                            type: Array,
                            default: function() {
                                return [!0, !0]
                            }
                        },
                        highcharts: {
                            type: Object
                        },
                        deepCopyOnUpdate: {
                            type: Boolean,
                            default: !0
                        }
                    }
                },
                f = function(T, P) {
                    return P.split(".")[0] < 3 ? k(k({}, g), {}, {
                        render: function(o) {
                            return o("div", {
                                ref: "chart"
                            })
                        },
                        beforeDestroy: function() {
                            this.chart && this.chart.destroy()
                        },
                        watch: {
                            options: {
                                handler: function(o) {
                                    var l;
                                    (l = this.chart).update.apply(l, [Z(o, this.deepCopyOnUpdate)].concat(R(this.updateArgs)))
                                },
                                deep: !0
                            }
                        },
                        mounted: function() {
                            var o = this.highcharts || T;
                            this.options && o[this.constructorType] ? this.chart = o[this.constructorType](this.$refs.chart, Z(this.options, !0), this.callback || null) : this.options ? console.warn("'".concat(this.constructorType, "' constructor-type is incorrect. Sometimes this error is caused by the fact, that the corresponding module wasn't imported.")) : console.warn('The "options" parameter was not passed.')
                        }
                    }) : k(k({}, g), {}, {
                        render: function() {
                            return Object(U.h)("div", {
                                ref: "chartContainer"
                            })
                        },
                        setup: function(o) {
                            var l = Object(U.ref)(null),
                                n = Object(U.shallowRef)({});
                            return Object(U.onMounted)(function() {
                                var h = o.highcharts || T;
                                o.options && h[o.constructorType] ? n.value = h[o.constructorType](l.value, Z(o.options, !0), o.callback || null) : o.options ? console.warn("'".concat(o.constructorType, "' constructor-type is incorrect. Sometimes this error is caused by the fact, that the corresponding module wasn't imported.")) : console.warn('The "options" parameter was not passed.')
                            }), Object(U.watch)(function() {
                                return o.options
                            }, function(h, u) {
                                var e;
                                (e = n.value).update.apply(e, [Z(h, o.deepCopyOnUpdate)].concat(R(o.updateArgs)))
                            }, {
                                deep: !0
                            }), Object(U.onBeforeUnmount)(function() {
                                n.value && n.value.destroy()
                            }), {
                                chart: n,
                                chartContainer: l,
                                props: o
                            }
                        }
                    })
                },
                m = f(K.a, U.version || nt.n(U).a.version);

            function C(T) {
                var P = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {};
                T.component(P.tagName || "highcharts", f(P.highcharts || K.a, T.version))
            }
        }], ht = {}, et.m = Q, et.c = ht, et.d = function(rt, it, nt) {
            et.o(rt, it) || Object.defineProperty(rt, it, {
                enumerable: !0,
                get: nt
            })
        }, et.r = function(rt) {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(rt, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(rt, "__esModule", {
                value: !0
            })
        }, et.t = function(rt, it) {
            if (1 & it && (rt = et(rt)), 8 & it || 4 & it && typeof rt == "object" && rt && rt.__esModule) return rt;
            var nt = Object.create(null);
            if (et.r(nt), Object.defineProperty(nt, "default", {
                enumerable: !0,
                value: rt
            }), 2 & it && typeof rt != "string")
                for (var ot in rt) et.d(nt, ot, (function(K) {
                    return rt[K]
                }).bind(null, ot));
            return nt
        }, et.n = function(rt) {
            var it = rt && rt.__esModule ? function() {
                return rt.default
            } : function() {
                return rt
            };
            return et.d(it, "a", it), it
        }, et.o = function(rt, it) {
            return Object.prototype.hasOwnProperty.call(rt, it)
        }, et.p = "", et(et.s = 2);

        function et(rt) {
            var it;
            return (ht[rt] || (it = ht[rt] = {
                i: rt,
                l: !1,
                exports: {}
            }, Q[rt].call(it.exports, it, it.exports, et), it.l = !0, it)).exports
        }
        var Q, ht
    })
})(Rt);
var zs = Rt.exports;
export {
    zs as h, js as r
};